"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@peculiar";
exports.ids = ["vendor-chunks/@peculiar"];
exports.modules = {

/***/ "(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/convert.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/convert.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnConvert = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(action-browser)/./node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(action-browser)/./node_modules/pvtsutils/build/index.js\");\nconst parser_1 = __webpack_require__(/*! ./parser */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/parser.js\");\nconst serializer_1 = __webpack_require__(/*! ./serializer */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\");\nclass AsnConvert {\n    static serialize(obj) {\n        return serializer_1.AsnSerializer.serialize(obj);\n    }\n    static parse(data, target) {\n        return parser_1.AsnParser.parse(data, target);\n    }\n    static toString(data) {\n        const buf = pvtsutils_1.BufferSourceConverter.isBufferSource(data) ? pvtsutils_1.BufferSourceConverter.toArrayBuffer(data) : AsnConvert.serialize(data);\n        const asn = asn1js.fromBER(buf);\n        if (asn.offset === -1) {\n            throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);\n        }\n        return asn.result.toString();\n    }\n}\nexports.AsnConvert = AsnConvert;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2NvbnZlcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHLEtBQUs7QUFDMUIsTUFBTUcsU0FBU0MsbUJBQU9BLENBQUMscUVBQVE7QUFDL0IsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsMkVBQVc7QUFDdkMsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMsMkZBQVU7QUFDbkMsTUFBTUcsZUFBZUgsbUJBQU9BLENBQUMsbUdBQWM7QUFDM0MsTUFBTUY7SUFDRixPQUFPTSxVQUFVQyxHQUFHLEVBQUU7UUFDbEIsT0FBT0YsYUFBYUcsYUFBYSxDQUFDRixTQUFTLENBQUNDO0lBQ2hEO0lBQ0EsT0FBT0UsTUFBTUMsSUFBSSxFQUFFQyxNQUFNLEVBQUU7UUFDdkIsT0FBT1AsU0FBU1EsU0FBUyxDQUFDSCxLQUFLLENBQUNDLE1BQU1DO0lBQzFDO0lBQ0EsT0FBT0UsU0FBU0gsSUFBSSxFQUFFO1FBQ2xCLE1BQU1JLE1BQU1YLFlBQVlZLHFCQUFxQixDQUFDQyxjQUFjLENBQUNOLFFBQ3ZEUCxZQUFZWSxxQkFBcUIsQ0FBQ0UsYUFBYSxDQUFDUCxRQUNoRFYsV0FBV00sU0FBUyxDQUFDSTtRQUMzQixNQUFNUSxNQUFNakIsT0FBT2tCLE9BQU8sQ0FBQ0w7UUFDM0IsSUFBSUksSUFBSUUsTUFBTSxLQUFLLENBQUMsR0FBRztZQUNuQixNQUFNLElBQUlDLE1BQU0sQ0FBQywwQkFBMEIsRUFBRUgsSUFBSUksTUFBTSxDQUFDQyxLQUFLLENBQUMsQ0FBQztRQUNuRTtRQUNBLE9BQU9MLElBQUlJLE1BQU0sQ0FBQ1QsUUFBUTtJQUM5QjtBQUNKO0FBQ0FmLGtCQUFrQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1ha2V0cGxhY2UtYWRtaW4vLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9jb252ZXJ0LmpzPzA3ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzbkNvbnZlcnQgPSB2b2lkIDA7XG5jb25zdCBhc24xanMgPSByZXF1aXJlKFwiYXNuMWpzXCIpO1xuY29uc3QgcHZ0c3V0aWxzXzEgPSByZXF1aXJlKFwicHZ0c3V0aWxzXCIpO1xuY29uc3QgcGFyc2VyXzEgPSByZXF1aXJlKFwiLi9wYXJzZXJcIik7XG5jb25zdCBzZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVyXCIpO1xuY2xhc3MgQXNuQ29udmVydCB7XG4gICAgc3RhdGljIHNlcmlhbGl6ZShvYmopIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXJfMS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShvYmopO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2UoZGF0YSwgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBwYXJzZXJfMS5Bc25QYXJzZXIucGFyc2UoZGF0YSwgdGFyZ2V0KTtcbiAgICB9XG4gICAgc3RhdGljIHRvU3RyaW5nKGRhdGEpIHtcbiAgICAgICAgY29uc3QgYnVmID0gcHZ0c3V0aWxzXzEuQnVmZmVyU291cmNlQ29udmVydGVyLmlzQnVmZmVyU291cmNlKGRhdGEpXG4gICAgICAgICAgICA/IHB2dHN1dGlsc18xLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGRhdGEpXG4gICAgICAgICAgICA6IEFzbkNvbnZlcnQuc2VyaWFsaXplKGRhdGEpO1xuICAgICAgICBjb25zdCBhc24gPSBhc24xanMuZnJvbUJFUihidWYpO1xuICAgICAgICBpZiAoYXNuLm9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGRlY29kZSBBU04uMSBkYXRhLiAke2Fzbi5yZXN1bHQuZXJyb3J9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzbi5yZXN1bHQudG9TdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLkFzbkNvbnZlcnQgPSBBc25Db252ZXJ0O1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQXNuQ29udmVydCIsImFzbjFqcyIsInJlcXVpcmUiLCJwdnRzdXRpbHNfMSIsInBhcnNlcl8xIiwic2VyaWFsaXplcl8xIiwic2VyaWFsaXplIiwib2JqIiwiQXNuU2VyaWFsaXplciIsInBhcnNlIiwiZGF0YSIsInRhcmdldCIsIkFzblBhcnNlciIsInRvU3RyaW5nIiwiYnVmIiwiQnVmZmVyU291cmNlQ29udmVydGVyIiwiaXNCdWZmZXJTb3VyY2UiLCJ0b0FycmF5QnVmZmVyIiwiYXNuIiwiZnJvbUJFUiIsIm9mZnNldCIsIkVycm9yIiwicmVzdWx0IiwiZXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/convert.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/convert.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/convert.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnConvert = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(rsc)/./node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(rsc)/./node_modules/pvtsutils/build/index.js\");\nconst parser_1 = __webpack_require__(/*! ./parser */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/parser.js\");\nconst serializer_1 = __webpack_require__(/*! ./serializer */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\");\nclass AsnConvert {\n    static serialize(obj) {\n        return serializer_1.AsnSerializer.serialize(obj);\n    }\n    static parse(data, target) {\n        return parser_1.AsnParser.parse(data, target);\n    }\n    static toString(data) {\n        const buf = pvtsutils_1.BufferSourceConverter.isBufferSource(data) ? pvtsutils_1.BufferSourceConverter.toArrayBuffer(data) : AsnConvert.serialize(data);\n        const asn = asn1js.fromBER(buf);\n        if (asn.offset === -1) {\n            throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);\n        }\n        return asn.result.toString();\n    }\n}\nexports.AsnConvert = AsnConvert;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9jb252ZXJ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBRyxLQUFLO0FBQzFCLE1BQU1HLFNBQVNDLG1CQUFPQSxDQUFDLDBEQUFRO0FBQy9CLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLGdFQUFXO0FBQ3ZDLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLGdGQUFVO0FBQ25DLE1BQU1HLGVBQWVILG1CQUFPQSxDQUFDLHdGQUFjO0FBQzNDLE1BQU1GO0lBQ0YsT0FBT00sVUFBVUMsR0FBRyxFQUFFO1FBQ2xCLE9BQU9GLGFBQWFHLGFBQWEsQ0FBQ0YsU0FBUyxDQUFDQztJQUNoRDtJQUNBLE9BQU9FLE1BQU1DLElBQUksRUFBRUMsTUFBTSxFQUFFO1FBQ3ZCLE9BQU9QLFNBQVNRLFNBQVMsQ0FBQ0gsS0FBSyxDQUFDQyxNQUFNQztJQUMxQztJQUNBLE9BQU9FLFNBQVNILElBQUksRUFBRTtRQUNsQixNQUFNSSxNQUFNWCxZQUFZWSxxQkFBcUIsQ0FBQ0MsY0FBYyxDQUFDTixRQUN2RFAsWUFBWVkscUJBQXFCLENBQUNFLGFBQWEsQ0FBQ1AsUUFDaERWLFdBQVdNLFNBQVMsQ0FBQ0k7UUFDM0IsTUFBTVEsTUFBTWpCLE9BQU9rQixPQUFPLENBQUNMO1FBQzNCLElBQUlJLElBQUlFLE1BQU0sS0FBSyxDQUFDLEdBQUc7WUFDbkIsTUFBTSxJQUFJQyxNQUFNLENBQUMsMEJBQTBCLEVBQUVILElBQUlJLE1BQU0sQ0FBQ0MsS0FBSyxDQUFDLENBQUM7UUFDbkU7UUFDQSxPQUFPTCxJQUFJSSxNQUFNLENBQUNULFFBQVE7SUFDOUI7QUFDSjtBQUNBZixrQkFBa0IsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYWtldHBsYWNlLWFkbWluLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvY29udmVydC5qcz8wN2QwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25Db252ZXJ0ID0gdm9pZCAwO1xuY29uc3QgYXNuMWpzID0gcmVxdWlyZShcImFzbjFqc1wiKTtcbmNvbnN0IHB2dHN1dGlsc18xID0gcmVxdWlyZShcInB2dHN1dGlsc1wiKTtcbmNvbnN0IHBhcnNlcl8xID0gcmVxdWlyZShcIi4vcGFyc2VyXCIpO1xuY29uc3Qgc2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vc2VyaWFsaXplclwiKTtcbmNsYXNzIEFzbkNvbnZlcnQge1xuICAgIHN0YXRpYyBzZXJpYWxpemUob2JqKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyXzEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUob2JqKTtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlKGRhdGEsIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gcGFyc2VyXzEuQXNuUGFyc2VyLnBhcnNlKGRhdGEsIHRhcmdldCk7XG4gICAgfVxuICAgIHN0YXRpYyB0b1N0cmluZyhkYXRhKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHB2dHN1dGlsc18xLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci5pc0J1ZmZlclNvdXJjZShkYXRhKVxuICAgICAgICAgICAgPyBwdnRzdXRpbHNfMS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihkYXRhKVxuICAgICAgICAgICAgOiBBc25Db252ZXJ0LnNlcmlhbGl6ZShkYXRhKTtcbiAgICAgICAgY29uc3QgYXNuID0gYXNuMWpzLmZyb21CRVIoYnVmKTtcbiAgICAgICAgaWYgKGFzbi5vZmZzZXQgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkZWNvZGUgQVNOLjEgZGF0YS4gJHthc24ucmVzdWx0LmVycm9yfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc24ucmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Bc25Db252ZXJ0ID0gQXNuQ29udmVydDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFzbkNvbnZlcnQiLCJhc24xanMiLCJyZXF1aXJlIiwicHZ0c3V0aWxzXzEiLCJwYXJzZXJfMSIsInNlcmlhbGl6ZXJfMSIsInNlcmlhbGl6ZSIsIm9iaiIsIkFzblNlcmlhbGl6ZXIiLCJwYXJzZSIsImRhdGEiLCJ0YXJnZXQiLCJBc25QYXJzZXIiLCJ0b1N0cmluZyIsImJ1ZiIsIkJ1ZmZlclNvdXJjZUNvbnZlcnRlciIsImlzQnVmZmVyU291cmNlIiwidG9BcnJheUJ1ZmZlciIsImFzbiIsImZyb21CRVIiLCJvZmZzZXQiLCJFcnJvciIsInJlc3VsdCIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/convert.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js":
/*!********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/converters.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.defaultConverter = exports.AsnNullConverter = exports.AsnGeneralizedTimeConverter = exports.AsnUTCTimeConverter = exports.AsnCharacterStringConverter = exports.AsnGeneralStringConverter = exports.AsnVisibleStringConverter = exports.AsnGraphicStringConverter = exports.AsnIA5StringConverter = exports.AsnVideotexStringConverter = exports.AsnTeletexStringConverter = exports.AsnPrintableStringConverter = exports.AsnNumericStringConverter = exports.AsnUniversalStringConverter = exports.AsnBmpStringConverter = exports.AsnUtf8StringConverter = exports.AsnConstructedOctetStringConverter = exports.AsnOctetStringConverter = exports.AsnBooleanConverter = exports.AsnObjectIdentifierConverter = exports.AsnBitStringConverter = exports.AsnIntegerBigIntConverter = exports.AsnIntegerArrayBufferConverter = exports.AsnEnumeratedConverter = exports.AsnIntegerConverter = exports.AsnAnyConverter = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(action-browser)/./node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst index_1 = __webpack_require__(/*! ./types/index */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\");\nexports.AsnAnyConverter = {\n    fromASN: (value)=>value instanceof asn1js.Null ? null : value.valueBeforeDecodeView,\n    toASN: (value)=>{\n        if (value === null) {\n            return new asn1js.Null();\n        }\n        const schema = asn1js.fromBER(value);\n        if (schema.result.error) {\n            throw new Error(schema.result.error);\n        }\n        return schema.result;\n    }\n};\nexports.AsnIntegerConverter = {\n    fromASN: (value)=>value.valueBlock.valueHexView.byteLength >= 4 ? value.valueBlock.toString() : value.valueBlock.valueDec,\n    toASN: (value)=>new asn1js.Integer({\n            value: +value\n        })\n};\nexports.AsnEnumeratedConverter = {\n    fromASN: (value)=>value.valueBlock.valueDec,\n    toASN: (value)=>new asn1js.Enumerated({\n            value\n        })\n};\nexports.AsnIntegerArrayBufferConverter = {\n    fromASN: (value)=>value.valueBlock.valueHexView,\n    toASN: (value)=>new asn1js.Integer({\n            valueHex: value\n        })\n};\nexports.AsnIntegerBigIntConverter = {\n    fromASN: (value)=>value.toBigInt(),\n    toASN: (value)=>asn1js.Integer.fromBigInt(value)\n};\nexports.AsnBitStringConverter = {\n    fromASN: (value)=>value.valueBlock.valueHexView,\n    toASN: (value)=>new asn1js.BitString({\n            valueHex: value\n        })\n};\nexports.AsnObjectIdentifierConverter = {\n    fromASN: (value)=>value.valueBlock.toString(),\n    toASN: (value)=>new asn1js.ObjectIdentifier({\n            value\n        })\n};\nexports.AsnBooleanConverter = {\n    fromASN: (value)=>value.valueBlock.value,\n    toASN: (value)=>new asn1js.Boolean({\n            value\n        })\n};\nexports.AsnOctetStringConverter = {\n    fromASN: (value)=>value.valueBlock.valueHexView,\n    toASN: (value)=>new asn1js.OctetString({\n            valueHex: value\n        })\n};\nexports.AsnConstructedOctetStringConverter = {\n    fromASN: (value)=>new index_1.OctetString(value.getValue()),\n    toASN: (value)=>value.toASN()\n};\nfunction createStringConverter(Asn1Type) {\n    return {\n        fromASN: (value)=>value.valueBlock.value,\n        toASN: (value)=>new Asn1Type({\n                value\n            })\n    };\n}\nexports.AsnUtf8StringConverter = createStringConverter(asn1js.Utf8String);\nexports.AsnBmpStringConverter = createStringConverter(asn1js.BmpString);\nexports.AsnUniversalStringConverter = createStringConverter(asn1js.UniversalString);\nexports.AsnNumericStringConverter = createStringConverter(asn1js.NumericString);\nexports.AsnPrintableStringConverter = createStringConverter(asn1js.PrintableString);\nexports.AsnTeletexStringConverter = createStringConverter(asn1js.TeletexString);\nexports.AsnVideotexStringConverter = createStringConverter(asn1js.VideotexString);\nexports.AsnIA5StringConverter = createStringConverter(asn1js.IA5String);\nexports.AsnGraphicStringConverter = createStringConverter(asn1js.GraphicString);\nexports.AsnVisibleStringConverter = createStringConverter(asn1js.VisibleString);\nexports.AsnGeneralStringConverter = createStringConverter(asn1js.GeneralString);\nexports.AsnCharacterStringConverter = createStringConverter(asn1js.CharacterString);\nexports.AsnUTCTimeConverter = {\n    fromASN: (value)=>value.toDate(),\n    toASN: (value)=>new asn1js.UTCTime({\n            valueDate: value\n        })\n};\nexports.AsnGeneralizedTimeConverter = {\n    fromASN: (value)=>value.toDate(),\n    toASN: (value)=>new asn1js.GeneralizedTime({\n            valueDate: value\n        })\n};\nexports.AsnNullConverter = {\n    fromASN: ()=>null,\n    toASN: ()=>{\n        return new asn1js.Null();\n    }\n};\nfunction defaultConverter(type) {\n    switch(type){\n        case enums_1.AsnPropTypes.Any:\n            return exports.AsnAnyConverter;\n        case enums_1.AsnPropTypes.BitString:\n            return exports.AsnBitStringConverter;\n        case enums_1.AsnPropTypes.BmpString:\n            return exports.AsnBmpStringConverter;\n        case enums_1.AsnPropTypes.Boolean:\n            return exports.AsnBooleanConverter;\n        case enums_1.AsnPropTypes.CharacterString:\n            return exports.AsnCharacterStringConverter;\n        case enums_1.AsnPropTypes.Enumerated:\n            return exports.AsnEnumeratedConverter;\n        case enums_1.AsnPropTypes.GeneralString:\n            return exports.AsnGeneralStringConverter;\n        case enums_1.AsnPropTypes.GeneralizedTime:\n            return exports.AsnGeneralizedTimeConverter;\n        case enums_1.AsnPropTypes.GraphicString:\n            return exports.AsnGraphicStringConverter;\n        case enums_1.AsnPropTypes.IA5String:\n            return exports.AsnIA5StringConverter;\n        case enums_1.AsnPropTypes.Integer:\n            return exports.AsnIntegerConverter;\n        case enums_1.AsnPropTypes.Null:\n            return exports.AsnNullConverter;\n        case enums_1.AsnPropTypes.NumericString:\n            return exports.AsnNumericStringConverter;\n        case enums_1.AsnPropTypes.ObjectIdentifier:\n            return exports.AsnObjectIdentifierConverter;\n        case enums_1.AsnPropTypes.OctetString:\n            return exports.AsnOctetStringConverter;\n        case enums_1.AsnPropTypes.PrintableString:\n            return exports.AsnPrintableStringConverter;\n        case enums_1.AsnPropTypes.TeletexString:\n            return exports.AsnTeletexStringConverter;\n        case enums_1.AsnPropTypes.UTCTime:\n            return exports.AsnUTCTimeConverter;\n        case enums_1.AsnPropTypes.UniversalString:\n            return exports.AsnUniversalStringConverter;\n        case enums_1.AsnPropTypes.Utf8String:\n            return exports.AsnUtf8StringConverter;\n        case enums_1.AsnPropTypes.VideotexString:\n            return exports.AsnVideotexStringConverter;\n        case enums_1.AsnPropTypes.VisibleString:\n            return exports.AsnVisibleStringConverter;\n        default:\n            return null;\n    }\n}\nexports.defaultConverter = defaultConverter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2NvbnZlcnRlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHdCQUF3QixHQUFHQSx3QkFBd0IsR0FBR0EsbUNBQW1DLEdBQUdBLDJCQUEyQixHQUFHQSxtQ0FBbUMsR0FBR0EsaUNBQWlDLEdBQUdBLGlDQUFpQyxHQUFHQSxpQ0FBaUMsR0FBR0EsNkJBQTZCLEdBQUdBLGtDQUFrQyxHQUFHQSxpQ0FBaUMsR0FBR0EsbUNBQW1DLEdBQUdBLGlDQUFpQyxHQUFHQSxtQ0FBbUMsR0FBR0EsNkJBQTZCLEdBQUdBLDhCQUE4QixHQUFHQSwwQ0FBMEMsR0FBR0EsK0JBQStCLEdBQUdBLDJCQUEyQixHQUFHQSxvQ0FBb0MsR0FBR0EsNkJBQTZCLEdBQUdBLGlDQUFpQyxHQUFHQSxzQ0FBc0MsR0FBR0EsOEJBQThCLEdBQUdBLDJCQUEyQixHQUFHQSx1QkFBdUIsR0FBRyxLQUFLO0FBQ3I0QixNQUFNNEIsU0FBU0MsbUJBQU9BLENBQUMscUVBQVE7QUFDL0IsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMseUZBQVM7QUFDakMsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMscUdBQWU7QUFDdkM3Qix1QkFBdUIsR0FBRztJQUN0QmdDLFNBQVMsQ0FBQy9CLFFBQVVBLGlCQUFpQjJCLE9BQU9LLElBQUksR0FBRyxPQUFPaEMsTUFBTWlDLHFCQUFxQjtJQUNyRkMsT0FBTyxDQUFDbEM7UUFDSixJQUFJQSxVQUFVLE1BQU07WUFDaEIsT0FBTyxJQUFJMkIsT0FBT0ssSUFBSTtRQUMxQjtRQUNBLE1BQU1HLFNBQVNSLE9BQU9TLE9BQU8sQ0FBQ3BDO1FBQzlCLElBQUltQyxPQUFPRSxNQUFNLENBQUNDLEtBQUssRUFBRTtZQUNyQixNQUFNLElBQUlDLE1BQU1KLE9BQU9FLE1BQU0sQ0FBQ0MsS0FB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TzFELFFBQVFpQixzQkFBc0I7UUFDekMsS0FBS2EsUUFBUTZDLFlBQVksQ0FBQ1gsY0FBYztZQUNwQyxPQUFPaEUsUUFBUVcsMEJBQTBCO1FBQzdDLEtBQUttQixRQUFRNkMsWUFBWSxDQUFDUixhQUFhO1lBQ25DLE9BQU9uRSxRQUFRUSx5QkFBeUI7UUFDNUM7WUFDSSxPQUFPO0lBQ2Y7QUFDSjtBQUNBUix3QkFBd0IsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYWtldHBsYWNlLWFkbWluLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvY29udmVydGVycy5qcz9lNDVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0Q29udmVydGVyID0gZXhwb3J0cy5Bc25OdWxsQ29udmVydGVyID0gZXhwb3J0cy5Bc25HZW5lcmFsaXplZFRpbWVDb252ZXJ0ZXIgPSBleHBvcnRzLkFzblVUQ1RpbWVDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkNoYXJhY3RlclN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuR2VuZXJhbFN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuVmlzaWJsZVN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuR3JhcGhpY1N0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuSUE1U3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25WaWRlb3RleFN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuVGVsZXRleFN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuUHJpbnRhYmxlU3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25OdW1lcmljU3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25Vbml2ZXJzYWxTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkJtcFN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuVXRmOFN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuQ29uc3RydWN0ZWRPY3RldFN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuT2N0ZXRTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkJvb2xlYW5Db252ZXJ0ZXIgPSBleHBvcnRzLkFzbk9iamVjdElkZW50aWZpZXJDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkJpdFN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuSW50ZWdlckJpZ0ludENvbnZlcnRlciA9IGV4cG9ydHMuQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyID0gZXhwb3J0cy5Bc25FbnVtZXJhdGVkQ29udmVydGVyID0gZXhwb3J0cy5Bc25JbnRlZ2VyQ29udmVydGVyID0gZXhwb3J0cy5Bc25BbnlDb252ZXJ0ZXIgPSB2b2lkIDA7XG5jb25zdCBhc24xanMgPSByZXF1aXJlKFwiYXNuMWpzXCIpO1xuY29uc3QgZW51bXNfMSA9IHJlcXVpcmUoXCIuL2VudW1zXCIpO1xuY29uc3QgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL2luZGV4XCIpO1xuZXhwb3J0cy5Bc25BbnlDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIGFzbjFqcy5OdWxsID8gbnVsbCA6IHZhbHVlLnZhbHVlQmVmb3JlRGVjb2RlVmlldyxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBhc24xanMuTnVsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IGFzbjFqcy5mcm9tQkVSKHZhbHVlKTtcbiAgICAgICAgaWYgKHNjaGVtYS5yZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzY2hlbWEucmVzdWx0LmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hLnJlc3VsdDtcbiAgICB9LFxufTtcbmV4cG9ydHMuQXNuSW50ZWdlckNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3LmJ5dGVMZW5ndGggPj0gNFxuICAgICAgICA/IHZhbHVlLnZhbHVlQmxvY2sudG9TdHJpbmcoKVxuICAgICAgICA6IHZhbHVlLnZhbHVlQmxvY2sudmFsdWVEZWMsXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gbmV3IGFzbjFqcy5JbnRlZ2VyKHsgdmFsdWU6ICt2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbkVudW1lcmF0ZWRDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlRGVjLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuRW51bWVyYXRlZCh7IHZhbHVlIH0pLFxufTtcbmV4cG9ydHMuQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudmFsdWVCbG9jay52YWx1ZUhleFZpZXcsXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gbmV3IGFzbjFqcy5JbnRlZ2VyKHsgdmFsdWVIZXg6IHZhbHVlIH0pLFxufTtcbmV4cG9ydHMuQXNuSW50ZWdlckJpZ0ludENvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnRvQmlnSW50KCksXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gYXNuMWpzLkludGVnZXIuZnJvbUJpZ0ludCh2YWx1ZSksXG59O1xuZXhwb3J0cy5Bc25CaXRTdHJpbmdDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlSGV4VmlldyxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgYXNuMWpzLkJpdFN0cmluZyh7IHZhbHVlSGV4OiB2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbk9iamVjdElkZW50aWZpZXJDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS52YWx1ZUJsb2NrLnRvU3RyaW5nKCksXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gbmV3IGFzbjFqcy5PYmplY3RJZGVudGlmaWVyKHsgdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25Cb29sZWFuQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudmFsdWVCbG9jay52YWx1ZSxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgYXNuMWpzLkJvb2xlYW4oeyB2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbk9jdGV0U3RyaW5nQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudmFsdWVCbG9jay52YWx1ZUhleFZpZXcsXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gbmV3IGFzbjFqcy5PY3RldFN0cmluZyh7IHZhbHVlSGV4OiB2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbkNvbnN0cnVjdGVkT2N0ZXRTdHJpbmdDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiBuZXcgaW5kZXhfMS5PY3RldFN0cmluZyh2YWx1ZS5nZXRWYWx1ZSgpKSxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiB2YWx1ZS50b0FTTigpLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihBc24xVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudmFsdWVCbG9jay52YWx1ZSxcbiAgICAgICAgdG9BU046ICh2YWx1ZSkgPT4gbmV3IEFzbjFUeXBlKHsgdmFsdWUgfSksXG4gICAgfTtcbn1cbmV4cG9ydHMuQXNuVXRmOFN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuVXRmOFN0cmluZyk7XG5leHBvcnRzLkFzbkJtcFN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuQm1wU3RyaW5nKTtcbmV4cG9ydHMuQXNuVW5pdmVyc2FsU3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5Vbml2ZXJzYWxTdHJpbmcpO1xuZXhwb3J0cy5Bc25OdW1lcmljU3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5OdW1lcmljU3RyaW5nKTtcbmV4cG9ydHMuQXNuUHJpbnRhYmxlU3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5QcmludGFibGVTdHJpbmcpO1xuZXhwb3J0cy5Bc25UZWxldGV4U3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5UZWxldGV4U3RyaW5nKTtcbmV4cG9ydHMuQXNuVmlkZW90ZXhTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLlZpZGVvdGV4U3RyaW5nKTtcbmV4cG9ydHMuQXNuSUE1U3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5JQTVTdHJpbmcpO1xuZXhwb3J0cy5Bc25HcmFwaGljU3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5HcmFwaGljU3RyaW5nKTtcbmV4cG9ydHMuQXNuVmlzaWJsZVN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuVmlzaWJsZVN0cmluZyk7XG5leHBvcnRzLkFzbkdlbmVyYWxTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLkdlbmVyYWxTdHJpbmcpO1xuZXhwb3J0cy5Bc25DaGFyYWN0ZXJTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLkNoYXJhY3RlclN0cmluZyk7XG5leHBvcnRzLkFzblVUQ1RpbWVDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS50b0RhdGUoKSxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgYXNuMWpzLlVUQ1RpbWUoeyB2YWx1ZURhdGU6IHZhbHVlIH0pLFxufTtcbmV4cG9ydHMuQXNuR2VuZXJhbGl6ZWRUaW1lQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudG9EYXRlKCksXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gbmV3IGFzbjFqcy5HZW5lcmFsaXplZFRpbWUoeyB2YWx1ZURhdGU6IHZhbHVlIH0pLFxufTtcbmV4cG9ydHMuQXNuTnVsbENvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAoKSA9PiBudWxsLFxuICAgIHRvQVNOOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgYXNuMWpzLk51bGwoKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGRlZmF1bHRDb252ZXJ0ZXIodHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkFueTpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkFueUNvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5CaXRTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25CaXRTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuQm1wU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuQm1wU3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkJvb2xlYW46XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25Cb29sZWFuQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkNoYXJhY3RlclN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkNoYXJhY3RlclN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5FbnVtZXJhdGVkOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuRW51bWVyYXRlZENvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5HZW5lcmFsU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuR2VuZXJhbFN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5HZW5lcmFsaXplZFRpbWU6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25HZW5lcmFsaXplZFRpbWVDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuR3JhcGhpY1N0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkdyYXBoaWNTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuSUE1U3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuSUE1U3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkludGVnZXI6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25JbnRlZ2VyQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLk51bGw6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25OdWxsQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLk51bWVyaWNTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25OdW1lcmljU3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLk9iamVjdElkZW50aWZpZXI6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25PYmplY3RJZGVudGlmaWVyQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLk9jdGV0U3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuT2N0ZXRTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuUHJpbnRhYmxlU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuUHJpbnRhYmxlU3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLlRlbGV0ZXhTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25UZWxldGV4U3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLlVUQ1RpbWU6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25VVENUaW1lQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLlVuaXZlcnNhbFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzblVuaXZlcnNhbFN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5VdGY4U3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuVXRmOFN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5WaWRlb3RleFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzblZpZGVvdGV4U3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLlZpc2libGVTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25WaXNpYmxlU3RyaW5nQ29udmVydGVyO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0Q29udmVydGVyID0gZGVmYXVsdENvbnZlcnRlcjtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImRlZmF1bHRDb252ZXJ0ZXIiLCJBc25OdWxsQ29udmVydGVyIiwiQXNuR2VuZXJhbGl6ZWRUaW1lQ29udmVydGVyIiwiQXNuVVRDVGltZUNvbnZlcnRlciIsIkFzbkNoYXJhY3RlclN0cmluZ0NvbnZlcnRlciIsIkFzbkdlbmVyYWxTdHJpbmdDb252ZXJ0ZXIiLCJBc25WaXNpYmxlU3RyaW5nQ29udmVydGVyIiwiQXNuR3JhcGhpY1N0cmluZ0NvbnZlcnRlciIsIkFzbklBNVN0cmluZ0NvbnZlcnRlciIsIkFzblZpZGVvdGV4U3RyaW5nQ29udmVydGVyIiwiQXNuVGVsZXRleFN0cmluZ0NvbnZlcnRlciIsIkFzblByaW50YWJsZVN0cmluZ0NvbnZlcnRlciIsIkFzbk51bWVyaWNTdHJpbmdDb252ZXJ0ZXIiLCJBc25Vbml2ZXJzYWxTdHJpbmdDb252ZXJ0ZXIiLCJBc25CbXBTdHJpbmdDb252ZXJ0ZXIiLCJBc25VdGY4U3RyaW5nQ29udmVydGVyIiwiQXNuQ29uc3RydWN0ZWRPY3RldFN0cmluZ0NvbnZlcnRlciIsIkFzbk9jdGV0U3RyaW5nQ29udmVydGVyIiwiQXNuQm9vbGVhbkNvbnZlcnRlciIsIkFzbk9iamVjdElkZW50aWZpZXJDb252ZXJ0ZXIiLCJBc25CaXRTdHJpbmdDb252ZXJ0ZXIiLCJBc25JbnRlZ2VyQmlnSW50Q29udmVydGVyIiwiQXNuSW50ZWdlckFycmF5QnVmZmVyQ29udmVydGVyIiwiQXNuRW51bWVyYXRlZENvbnZlcnRlciIsIkFzbkludGVnZXJDb252ZXJ0ZXIiLCJBc25BbnlDb252ZXJ0ZXIiLCJhc24xanMiLCJyZXF1aXJlIiwiZW51bXNfMSIsImluZGV4XzEiLCJmcm9tQVNOIiwiTnVsbCIsInZhbHVlQmVmb3JlRGVjb2RlVmlldyIsInRvQVNOIiwic2NoZW1hIiwiZnJvbUJFUiIsInJlc3VsdCIsImVycm9yIiwiRXJyb3IiLCJ2YWx1ZUJsb2NrIiwidmFsdWVIZXhWaWV3IiwiYnl0ZUxlbmd0aCIsInRvU3RyaW5nIiwidmFsdWVEZWMiLCJJbnRlZ2VyIiwiRW51bWVyYXRlZCIsInZhbHVlSGV4IiwidG9CaWdJbnQiLCJmcm9tQmlnSW50IiwiQml0U3RyaW5nIiwiT2JqZWN0SWRlbnRpZmllciIsIkJvb2xlYW4iLCJPY3RldFN0cmluZyIsImdldFZhbHVlIiwiY3JlYXRlU3RyaW5nQ29udmVydGVyIiwiQXNuMVR5cGUiLCJVdGY4U3RyaW5nIiwiQm1wU3RyaW5nIiwiVW5pdmVyc2FsU3RyaW5nIiwiTnVtZXJpY1N0cmluZyIsIlByaW50YWJsZVN0cmluZyIsIlRlbGV0ZXhTdHJpbmciLCJWaWRlb3RleFN0cmluZyIsIklBNVN0cmluZyIsIkdyYXBoaWNTdHJpbmciLCJWaXNpYmxlU3RyaW5nIiwiR2VuZXJhbFN0cmluZyIsIkNoYXJhY3RlclN0cmluZyIsInRvRGF0ZSIsIlVUQ1RpbWUiLCJ2YWx1ZURhdGUiLCJHZW5lcmFsaXplZFRpbWUiLCJ0eXBlIiwiQXNuUHJvcFR5cGVzIiwiQW55Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js":
/*!********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/converters.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.defaultConverter = exports.AsnNullConverter = exports.AsnGeneralizedTimeConverter = exports.AsnUTCTimeConverter = exports.AsnCharacterStringConverter = exports.AsnGeneralStringConverter = exports.AsnVisibleStringConverter = exports.AsnGraphicStringConverter = exports.AsnIA5StringConverter = exports.AsnVideotexStringConverter = exports.AsnTeletexStringConverter = exports.AsnPrintableStringConverter = exports.AsnNumericStringConverter = exports.AsnUniversalStringConverter = exports.AsnBmpStringConverter = exports.AsnUtf8StringConverter = exports.AsnConstructedOctetStringConverter = exports.AsnOctetStringConverter = exports.AsnBooleanConverter = exports.AsnObjectIdentifierConverter = exports.AsnBitStringConverter = exports.AsnIntegerBigIntConverter = exports.AsnIntegerArrayBufferConverter = exports.AsnEnumeratedConverter = exports.AsnIntegerConverter = exports.AsnAnyConverter = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(rsc)/./node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst index_1 = __webpack_require__(/*! ./types/index */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\");\nexports.AsnAnyConverter = {\n    fromASN: (value)=>value instanceof asn1js.Null ? null : value.valueBeforeDecodeView,\n    toASN: (value)=>{\n        if (value === null) {\n            return new asn1js.Null();\n        }\n        const schema = asn1js.fromBER(value);\n        if (schema.result.error) {\n            throw new Error(schema.result.error);\n        }\n        return schema.result;\n    }\n};\nexports.AsnIntegerConverter = {\n    fromASN: (value)=>value.valueBlock.valueHexView.byteLength >= 4 ? value.valueBlock.toString() : value.valueBlock.valueDec,\n    toASN: (value)=>new asn1js.Integer({\n            value: +value\n        })\n};\nexports.AsnEnumeratedConverter = {\n    fromASN: (value)=>value.valueBlock.valueDec,\n    toASN: (value)=>new asn1js.Enumerated({\n            value\n        })\n};\nexports.AsnIntegerArrayBufferConverter = {\n    fromASN: (value)=>value.valueBlock.valueHexView,\n    toASN: (value)=>new asn1js.Integer({\n            valueHex: value\n        })\n};\nexports.AsnIntegerBigIntConverter = {\n    fromASN: (value)=>value.toBigInt(),\n    toASN: (value)=>asn1js.Integer.fromBigInt(value)\n};\nexports.AsnBitStringConverter = {\n    fromASN: (value)=>value.valueBlock.valueHexView,\n    toASN: (value)=>new asn1js.BitString({\n            valueHex: value\n        })\n};\nexports.AsnObjectIdentifierConverter = {\n    fromASN: (value)=>value.valueBlock.toString(),\n    toASN: (value)=>new asn1js.ObjectIdentifier({\n            value\n        })\n};\nexports.AsnBooleanConverter = {\n    fromASN: (value)=>value.valueBlock.value,\n    toASN: (value)=>new asn1js.Boolean({\n            value\n        })\n};\nexports.AsnOctetStringConverter = {\n    fromASN: (value)=>value.valueBlock.valueHexView,\n    toASN: (value)=>new asn1js.OctetString({\n            valueHex: value\n        })\n};\nexports.AsnConstructedOctetStringConverter = {\n    fromASN: (value)=>new index_1.OctetString(value.getValue()),\n    toASN: (value)=>value.toASN()\n};\nfunction createStringConverter(Asn1Type) {\n    return {\n        fromASN: (value)=>value.valueBlock.value,\n        toASN: (value)=>new Asn1Type({\n                value\n            })\n    };\n}\nexports.AsnUtf8StringConverter = createStringConverter(asn1js.Utf8String);\nexports.AsnBmpStringConverter = createStringConverter(asn1js.BmpString);\nexports.AsnUniversalStringConverter = createStringConverter(asn1js.UniversalString);\nexports.AsnNumericStringConverter = createStringConverter(asn1js.NumericString);\nexports.AsnPrintableStringConverter = createStringConverter(asn1js.PrintableString);\nexports.AsnTeletexStringConverter = createStringConverter(asn1js.TeletexString);\nexports.AsnVideotexStringConverter = createStringConverter(asn1js.VideotexString);\nexports.AsnIA5StringConverter = createStringConverter(asn1js.IA5String);\nexports.AsnGraphicStringConverter = createStringConverter(asn1js.GraphicString);\nexports.AsnVisibleStringConverter = createStringConverter(asn1js.VisibleString);\nexports.AsnGeneralStringConverter = createStringConverter(asn1js.GeneralString);\nexports.AsnCharacterStringConverter = createStringConverter(asn1js.CharacterString);\nexports.AsnUTCTimeConverter = {\n    fromASN: (value)=>value.toDate(),\n    toASN: (value)=>new asn1js.UTCTime({\n            valueDate: value\n        })\n};\nexports.AsnGeneralizedTimeConverter = {\n    fromASN: (value)=>value.toDate(),\n    toASN: (value)=>new asn1js.GeneralizedTime({\n            valueDate: value\n        })\n};\nexports.AsnNullConverter = {\n    fromASN: ()=>null,\n    toASN: ()=>{\n        return new asn1js.Null();\n    }\n};\nfunction defaultConverter(type) {\n    switch(type){\n        case enums_1.AsnPropTypes.Any:\n            return exports.AsnAnyConverter;\n        case enums_1.AsnPropTypes.BitString:\n            return exports.AsnBitStringConverter;\n        case enums_1.AsnPropTypes.BmpString:\n            return exports.AsnBmpStringConverter;\n        case enums_1.AsnPropTypes.Boolean:\n            return exports.AsnBooleanConverter;\n        case enums_1.AsnPropTypes.CharacterString:\n            return exports.AsnCharacterStringConverter;\n        case enums_1.AsnPropTypes.Enumerated:\n            return exports.AsnEnumeratedConverter;\n        case enums_1.AsnPropTypes.GeneralString:\n            return exports.AsnGeneralStringConverter;\n        case enums_1.AsnPropTypes.GeneralizedTime:\n            return exports.AsnGeneralizedTimeConverter;\n        case enums_1.AsnPropTypes.GraphicString:\n            return exports.AsnGraphicStringConverter;\n        case enums_1.AsnPropTypes.IA5String:\n            return exports.AsnIA5StringConverter;\n        case enums_1.AsnPropTypes.Integer:\n            return exports.AsnIntegerConverter;\n        case enums_1.AsnPropTypes.Null:\n            return exports.AsnNullConverter;\n        case enums_1.AsnPropTypes.NumericString:\n            return exports.AsnNumericStringConverter;\n        case enums_1.AsnPropTypes.ObjectIdentifier:\n            return exports.AsnObjectIdentifierConverter;\n        case enums_1.AsnPropTypes.OctetString:\n            return exports.AsnOctetStringConverter;\n        case enums_1.AsnPropTypes.PrintableString:\n            return exports.AsnPrintableStringConverter;\n        case enums_1.AsnPropTypes.TeletexString:\n            return exports.AsnTeletexStringConverter;\n        case enums_1.AsnPropTypes.UTCTime:\n            return exports.AsnUTCTimeConverter;\n        case enums_1.AsnPropTypes.UniversalString:\n            return exports.AsnUniversalStringConverter;\n        case enums_1.AsnPropTypes.Utf8String:\n            return exports.AsnUtf8StringConverter;\n        case enums_1.AsnPropTypes.VideotexString:\n            return exports.AsnVideotexStringConverter;\n        case enums_1.AsnPropTypes.VisibleString:\n            return exports.AsnVisibleStringConverter;\n        default:\n            return null;\n    }\n}\nexports.defaultConverter = defaultConverter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9jb252ZXJ0ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx3QkFBd0IsR0FBR0Esd0JBQXdCLEdBQUdBLG1DQUFtQyxHQUFHQSwyQkFBMkIsR0FBR0EsbUNBQW1DLEdBQUdBLGlDQUFpQyxHQUFHQSxpQ0FBaUMsR0FBR0EsaUNBQWlDLEdBQUdBLDZCQUE2QixHQUFHQSxrQ0FBa0MsR0FBR0EsaUNBQWlDLEdBQUdBLG1DQUFtQyxHQUFHQSxpQ0FBaUMsR0FBR0EsbUNBQW1DLEdBQUdBLDZCQUE2QixHQUFHQSw4QkFBOEIsR0FBR0EsMENBQTBDLEdBQUdBLCtCQUErQixHQUFHQSwyQkFBMkIsR0FBR0Esb0NBQW9DLEdBQUdBLDZCQUE2QixHQUFHQSxpQ0FBaUMsR0FBR0Esc0NBQXNDLEdBQUdBLDhCQUE4QixHQUFHQSwyQkFBMkIsR0FBR0EsdUJBQXVCLEdBQUcsS0FBSztBQUNyNEIsTUFBTTRCLFNBQVNDLG1CQUFPQSxDQUFDLDBEQUFRO0FBQy9CLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLDhFQUFTO0FBQ2pDLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLDBGQUFlO0FBQ3ZDN0IsdUJBQXVCLEdBQUc7SUFDdEJnQyxTQUFTLENBQUMvQixRQUFVQSxpQkFBaUIyQixPQUFPSyxJQUFJLEdBQUcsT0FBT2hDLE1BQU1pQyxxQkFBcUI7SUFDckZDLE9BQU8sQ0FBQ2xDO1FBQ0osSUFBSUEsVUFBVSxNQUFNO1lBQ2hCLE9BQU8sSUFBSTJCLE9BQU9LLElBQUk7UUFDMUI7UUFDQSxNQUFNRyxTQUFTUixPQUFPUyxPQUFPLENBQUNwQztRQUM5QixJQUFJbUMsT0FBT0UsTUFBTSxDQUFDQyxLQUFLLEVBQUU7WUFDckIsTUFBTSxJQUFJQyxNQUFNSixPQUFPRSxNQUFNLENBQUNDLEtBQUs7UUFDdkM7UUFD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c0JBQXNCO1FBQ3pDLEtBQUthLFFBQVE2QyxZQUFZLENBQUNYLGNBQWM7WUFDcEMsT0FBT2hFLFFBQVFXLDBCQUEwQjtRQUM3QyxLQUFLbUIsUUFBUTZDLFlBQVksQ0FBQ1IsYUFBYTtZQUNuQyxPQUFPbkUsUUFBUVEseUJBQXlCO1FBQzVDO1lBQ0ksT0FBTztJQUNmO0FBQ0o7QUFDQVIsd0JBQXdCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktbWFrZXRwbGFjZS1hZG1pbi8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2NvbnZlcnRlcnMuanM/ZTQ1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVmYXVsdENvbnZlcnRlciA9IGV4cG9ydHMuQXNuTnVsbENvbnZlcnRlciA9IGV4cG9ydHMuQXNuR2VuZXJhbGl6ZWRUaW1lQ29udmVydGVyID0gZXhwb3J0cy5Bc25VVENUaW1lQ29udmVydGVyID0gZXhwb3J0cy5Bc25DaGFyYWN0ZXJTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkdlbmVyYWxTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzblZpc2libGVTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkdyYXBoaWNTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbklBNVN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuVmlkZW90ZXhTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzblRlbGV0ZXhTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzblByaW50YWJsZVN0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuTnVtZXJpY1N0cmluZ0NvbnZlcnRlciA9IGV4cG9ydHMuQXNuVW5pdmVyc2FsU3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25CbXBTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzblV0ZjhTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkNvbnN0cnVjdGVkT2N0ZXRTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbk9jdGV0U3RyaW5nQ29udmVydGVyID0gZXhwb3J0cy5Bc25Cb29sZWFuQ29udmVydGVyID0gZXhwb3J0cy5Bc25PYmplY3RJZGVudGlmaWVyQ29udmVydGVyID0gZXhwb3J0cy5Bc25CaXRTdHJpbmdDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkludGVnZXJCaWdJbnRDb252ZXJ0ZXIgPSBleHBvcnRzLkFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciA9IGV4cG9ydHMuQXNuRW51bWVyYXRlZENvbnZlcnRlciA9IGV4cG9ydHMuQXNuSW50ZWdlckNvbnZlcnRlciA9IGV4cG9ydHMuQXNuQW55Q29udmVydGVyID0gdm9pZCAwO1xuY29uc3QgYXNuMWpzID0gcmVxdWlyZShcImFzbjFqc1wiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbmNvbnN0IGluZGV4XzEgPSByZXF1aXJlKFwiLi90eXBlcy9pbmRleFwiKTtcbmV4cG9ydHMuQXNuQW55Q29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiBhc24xanMuTnVsbCA/IG51bGwgOiB2YWx1ZS52YWx1ZUJlZm9yZURlY29kZVZpZXcsXG4gICAgdG9BU046ICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYXNuMWpzLk51bGwoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY2hlbWEgPSBhc24xanMuZnJvbUJFUih2YWx1ZSk7XG4gICAgICAgIGlmIChzY2hlbWEucmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc2NoZW1hLnJlc3VsdC5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYS5yZXN1bHQ7XG4gICAgfSxcbn07XG5leHBvcnRzLkFzbkludGVnZXJDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlSGV4Vmlldy5ieXRlTGVuZ3RoID49IDRcbiAgICAgICAgPyB2YWx1ZS52YWx1ZUJsb2NrLnRvU3RyaW5nKClcbiAgICAgICAgOiB2YWx1ZS52YWx1ZUJsb2NrLnZhbHVlRGVjLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuSW50ZWdlcih7IHZhbHVlOiArdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25FbnVtZXJhdGVkQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudmFsdWVCbG9jay52YWx1ZURlYyxcbiAgICB0b0FTTjogKHZhbHVlKSA9PiBuZXcgYXNuMWpzLkVudW1lcmF0ZWQoeyB2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3LFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuSW50ZWdlcih7IHZhbHVlSGV4OiB2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbkludGVnZXJCaWdJbnRDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKHZhbHVlKSA9PiB2YWx1ZS50b0JpZ0ludCgpLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IGFzbjFqcy5JbnRlZ2VyLmZyb21CaWdJbnQodmFsdWUpLFxufTtcbmV4cG9ydHMuQXNuQml0U3RyaW5nQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudmFsdWVCbG9jay52YWx1ZUhleFZpZXcsXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gbmV3IGFzbjFqcy5CaXRTdHJpbmcoeyB2YWx1ZUhleDogdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25PYmplY3RJZGVudGlmaWVyQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudmFsdWVCbG9jay50b1N0cmluZygpLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuT2JqZWN0SWRlbnRpZmllcih7IHZhbHVlIH0pLFxufTtcbmV4cG9ydHMuQXNuQm9vbGVhbkNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudmFsdWUsXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gbmV3IGFzbjFqcy5Cb29sZWFuKHsgdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25PY3RldFN0cmluZ0NvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudmFsdWVIZXhWaWV3LFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuT2N0ZXRTdHJpbmcoeyB2YWx1ZUhleDogdmFsdWUgfSksXG59O1xuZXhwb3J0cy5Bc25Db25zdHJ1Y3RlZE9jdGV0U3RyaW5nQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gbmV3IGluZGV4XzEuT2N0ZXRTdHJpbmcodmFsdWUuZ2V0VmFsdWUoKSksXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gdmFsdWUudG9BU04oKSxcbn07XG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoQXNuMVR5cGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnZhbHVlQmxvY2sudmFsdWUsXG4gICAgICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBBc24xVHlwZSh7IHZhbHVlIH0pLFxuICAgIH07XG59XG5leHBvcnRzLkFzblV0ZjhTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLlV0ZjhTdHJpbmcpO1xuZXhwb3J0cy5Bc25CbXBTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLkJtcFN0cmluZyk7XG5leHBvcnRzLkFzblVuaXZlcnNhbFN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuVW5pdmVyc2FsU3RyaW5nKTtcbmV4cG9ydHMuQXNuTnVtZXJpY1N0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuTnVtZXJpY1N0cmluZyk7XG5leHBvcnRzLkFzblByaW50YWJsZVN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuUHJpbnRhYmxlU3RyaW5nKTtcbmV4cG9ydHMuQXNuVGVsZXRleFN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuVGVsZXRleFN0cmluZyk7XG5leHBvcnRzLkFzblZpZGVvdGV4U3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5WaWRlb3RleFN0cmluZyk7XG5leHBvcnRzLkFzbklBNVN0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuSUE1U3RyaW5nKTtcbmV4cG9ydHMuQXNuR3JhcGhpY1N0cmluZ0NvbnZlcnRlciA9IGNyZWF0ZVN0cmluZ0NvbnZlcnRlcihhc24xanMuR3JhcGhpY1N0cmluZyk7XG5leHBvcnRzLkFzblZpc2libGVTdHJpbmdDb252ZXJ0ZXIgPSBjcmVhdGVTdHJpbmdDb252ZXJ0ZXIoYXNuMWpzLlZpc2libGVTdHJpbmcpO1xuZXhwb3J0cy5Bc25HZW5lcmFsU3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5HZW5lcmFsU3RyaW5nKTtcbmV4cG9ydHMuQXNuQ2hhcmFjdGVyU3RyaW5nQ29udmVydGVyID0gY3JlYXRlU3RyaW5nQ29udmVydGVyKGFzbjFqcy5DaGFyYWN0ZXJTdHJpbmcpO1xuZXhwb3J0cy5Bc25VVENUaW1lQ29udmVydGVyID0ge1xuICAgIGZyb21BU046ICh2YWx1ZSkgPT4gdmFsdWUudG9EYXRlKCksXG4gICAgdG9BU046ICh2YWx1ZSkgPT4gbmV3IGFzbjFqcy5VVENUaW1lKHsgdmFsdWVEYXRlOiB2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbkdlbmVyYWxpemVkVGltZUNvbnZlcnRlciA9IHtcbiAgICBmcm9tQVNOOiAodmFsdWUpID0+IHZhbHVlLnRvRGF0ZSgpLFxuICAgIHRvQVNOOiAodmFsdWUpID0+IG5ldyBhc24xanMuR2VuZXJhbGl6ZWRUaW1lKHsgdmFsdWVEYXRlOiB2YWx1ZSB9KSxcbn07XG5leHBvcnRzLkFzbk51bGxDb252ZXJ0ZXIgPSB7XG4gICAgZnJvbUFTTjogKCkgPT4gbnVsbCxcbiAgICB0b0FTTjogKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5OdWxsKCk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBkZWZhdWx0Q29udmVydGVyKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5Bbnk6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25BbnlDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuQml0U3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuQml0U3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkJtcFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkJtcFN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5Cb29sZWFuOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuQm9vbGVhbkNvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5DaGFyYWN0ZXJTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25DaGFyYWN0ZXJTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuRW51bWVyYXRlZDpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkVudW1lcmF0ZWRDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuR2VuZXJhbFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbkdlbmVyYWxTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuR2VuZXJhbGl6ZWRUaW1lOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuR2VuZXJhbGl6ZWRUaW1lQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLkdyYXBoaWNTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25HcmFwaGljU3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLklBNVN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbklBNVN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5JbnRlZ2VyOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuSW50ZWdlckNvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5OdWxsOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuTnVsbENvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5OdW1lcmljU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuTnVtZXJpY1N0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5PYmplY3RJZGVudGlmaWVyOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuT2JqZWN0SWRlbnRpZmllckNvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5PY3RldFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzbk9jdGV0U3RyaW5nQ29udmVydGVyO1xuICAgICAgICBjYXNlIGVudW1zXzEuQXNuUHJvcFR5cGVzLlByaW50YWJsZVN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzblByaW50YWJsZVN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5UZWxldGV4U3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuVGVsZXRleFN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5VVENUaW1lOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuVVRDVGltZUNvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5Vbml2ZXJzYWxTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25Vbml2ZXJzYWxTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuVXRmOFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLkFzblV0ZjhTdHJpbmdDb252ZXJ0ZXI7XG4gICAgICAgIGNhc2UgZW51bXNfMS5Bc25Qcm9wVHlwZXMuVmlkZW90ZXhTdHJpbmc6XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5Bc25WaWRlb3RleFN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgY2FzZSBlbnVtc18xLkFzblByb3BUeXBlcy5WaXNpYmxlU3RyaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuQXNuVmlzaWJsZVN0cmluZ0NvbnZlcnRlcjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdENvbnZlcnRlciA9IGRlZmF1bHRDb252ZXJ0ZXI7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0Q29udmVydGVyIiwiQXNuTnVsbENvbnZlcnRlciIsIkFzbkdlbmVyYWxpemVkVGltZUNvbnZlcnRlciIsIkFzblVUQ1RpbWVDb252ZXJ0ZXIiLCJBc25DaGFyYWN0ZXJTdHJpbmdDb252ZXJ0ZXIiLCJBc25HZW5lcmFsU3RyaW5nQ29udmVydGVyIiwiQXNuVmlzaWJsZVN0cmluZ0NvbnZlcnRlciIsIkFzbkdyYXBoaWNTdHJpbmdDb252ZXJ0ZXIiLCJBc25JQTVTdHJpbmdDb252ZXJ0ZXIiLCJBc25WaWRlb3RleFN0cmluZ0NvbnZlcnRlciIsIkFzblRlbGV0ZXhTdHJpbmdDb252ZXJ0ZXIiLCJBc25QcmludGFibGVTdHJpbmdDb252ZXJ0ZXIiLCJBc25OdW1lcmljU3RyaW5nQ29udmVydGVyIiwiQXNuVW5pdmVyc2FsU3RyaW5nQ29udmVydGVyIiwiQXNuQm1wU3RyaW5nQ29udmVydGVyIiwiQXNuVXRmOFN0cmluZ0NvbnZlcnRlciIsIkFzbkNvbnN0cnVjdGVkT2N0ZXRTdHJpbmdDb252ZXJ0ZXIiLCJBc25PY3RldFN0cmluZ0NvbnZlcnRlciIsIkFzbkJvb2xlYW5Db252ZXJ0ZXIiLCJBc25PYmplY3RJZGVudGlmaWVyQ29udmVydGVyIiwiQXNuQml0U3RyaW5nQ29udmVydGVyIiwiQXNuSW50ZWdlckJpZ0ludENvbnZlcnRlciIsIkFzbkludGVnZXJBcnJheUJ1ZmZlckNvbnZlcnRlciIsIkFzbkVudW1lcmF0ZWRDb252ZXJ0ZXIiLCJBc25JbnRlZ2VyQ29udmVydGVyIiwiQXNuQW55Q29udmVydGVyIiwiYXNuMWpzIiwicmVxdWlyZSIsImVudW1zXzEiLCJpbmRleF8xIiwiZnJvbUFTTiIsIk51bGwiLCJ2YWx1ZUJlZm9yZURlY29kZVZpZXciLCJ0b0FTTiIsInNjaGVtYSIsImZyb21CRVIiLCJyZXN1bHQiLCJlcnJvciIsIkVycm9yIiwidmFsdWVCbG9jayIsInZhbHVlSGV4VmlldyIsImJ5dGVMZW5ndGgiLCJ0b1N0cmluZyIsInZhbHVlRGVjIiwiSW50ZWdlciIsIkVudW1lcmF0ZWQiLCJ2YWx1ZUhleCIsInRvQmlnSW50IiwiZnJvbUJpZ0ludCIsIkJpdFN0cmluZyIsIk9iamVjdElkZW50aWZpZXIiLCJCb29sZWFuIiwiT2N0ZXRTdHJpbmciLCJnZXRWYWx1ZSIsImNyZWF0ZVN0cmluZ0NvbnZlcnRlciIsIkFzbjFUeXBlIiwiVXRmOFN0cmluZyIsIkJtcFN0cmluZyIsIlVuaXZlcnNhbFN0cmluZyIsIk51bWVyaWNTdHJpbmciLCJQcmludGFibGVTdHJpbmciLCJUZWxldGV4U3RyaW5nIiwiVmlkZW90ZXhTdHJpbmciLCJJQTVTdHJpbmciLCJHcmFwaGljU3RyaW5nIiwiVmlzaWJsZVN0cmluZyIsIkdlbmVyYWxTdHJpbmciLCJDaGFyYWN0ZXJTdHJpbmciLCJ0b0RhdGUiLCJVVENUaW1lIiwidmFsdWVEYXRlIiwiR2VuZXJhbGl6ZWRUaW1lIiwidHlwZSIsIkFzblByb3BUeXBlcyIsIkFueSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/decorators.js":
/*!********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/decorators.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnProp = exports.AsnSequenceType = exports.AsnSetType = exports.AsnChoiceType = exports.AsnType = void 0;\nconst converters = __webpack_require__(/*! ./converters */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nconst AsnType = (options)=>(target)=>{\n        let schema;\n        if (!storage_1.schemaStorage.has(target)) {\n            schema = storage_1.schemaStorage.createDefault(target);\n            storage_1.schemaStorage.set(target, schema);\n        } else {\n            schema = storage_1.schemaStorage.get(target);\n        }\n        Object.assign(schema, options);\n    };\nexports.AsnType = AsnType;\nconst AsnChoiceType = ()=>(0, exports.AsnType)({\n        type: enums_1.AsnTypeTypes.Choice\n    });\nexports.AsnChoiceType = AsnChoiceType;\nconst AsnSetType = (options)=>(0, exports.AsnType)({\n        type: enums_1.AsnTypeTypes.Set,\n        ...options\n    });\nexports.AsnSetType = AsnSetType;\nconst AsnSequenceType = (options)=>(0, exports.AsnType)({\n        type: enums_1.AsnTypeTypes.Sequence,\n        ...options\n    });\nexports.AsnSequenceType = AsnSequenceType;\nconst AsnProp = (options)=>(target, propertyKey)=>{\n        let schema;\n        if (!storage_1.schemaStorage.has(target.constructor)) {\n            schema = storage_1.schemaStorage.createDefault(target.constructor);\n            storage_1.schemaStorage.set(target.constructor, schema);\n        } else {\n            schema = storage_1.schemaStorage.get(target.constructor);\n        }\n        const copyOptions = Object.assign({}, options);\n        if (typeof copyOptions.type === \"number\" && !copyOptions.converter) {\n            const defaultConverter = converters.defaultConverter(options.type);\n            if (!defaultConverter) {\n                throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);\n            }\n            copyOptions.converter = defaultConverter;\n        }\n        schema.items[propertyKey] = copyOptions;\n    };\nexports.AsnProp = AsnProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2RlY29yYXRvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGVBQWUsR0FBR0EsdUJBQXVCLEdBQUdBLGtCQUFrQixHQUFHQSxxQkFBcUIsR0FBR0EsZUFBZSxHQUFHLEtBQUs7QUFDaEgsTUFBTU8sYUFBYUMsbUJBQU9BLENBQUMsbUdBQWM7QUFDekMsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMseUZBQVM7QUFDakMsTUFBTUUsWUFBWUYsbUJBQU9BLENBQUMsNkZBQVc7QUFDckMsTUFBTUYsVUFBVSxDQUFDSyxVQUFZLENBQUNDO1FBQzFCLElBQUlDO1FBQ0osSUFBSSxDQUFDSCxVQUFVSSxhQUFhLENBQUNDLEdBQUcsQ0FBQ0gsU0FBUztZQUN0Q0MsU0FBU0gsVUFBVUksYUFBYSxDQUFDRSxhQUFhLENBQUNKO1lBQy9DRixVQUFVSSxhQUFhLENBQUNHLEdBQUcsQ0FBQ0wsUUFBUUM7UUFDeEMsT0FDSztZQUNEQSxTQUFTSCxVQUFVSSxhQUFhLENBQUNJLEdBQUcsQ0FBQ047UUFDekM7UUFDQWQsT0FBT3FCLE1BQU0sQ0FBQ04sUUFBUUY7SUFDMUI7QUFDQVgsZUFBZSxHQUFHTTtBQUNsQixNQUFNRCxnQkFBZ0IsSUFBTSxDQUFDLEdBQUdMLFFBQVFNLE9BQU8sRUFBRTtRQUFFYyxNQUFNWCxRQUFRWSxZQUFZLENBQUNDLE1BQU07SUFBQztBQUNyRnRCLHFCQUFxQixHQUFHSztBQUN4QixNQUFNRCxhQUFhLENBQUNPLFVBQVksQ0FBQyxHQUFHWCxRQUFRTSxPQUFPLEVBQUU7UUFBRWMsTUFBTVgsUUFBUVksWUFBWSxDQUFDRSxHQUFHO1FBQUUsR0FBR1osT0FBTztJQUFDO0FBQ2xHWCxrQkFBa0IsR0FBR0k7QUFDckIsTUFBTUQsa0JBQWtCLENBQUNRLFVBQVksQ0FBQyxHQUFHWCxRQUFRTSxPQUFPLEVBQUU7UUFBRWMsTUFBTVgsUUFBUVksWUFBWSxDQUFDRyxRQUFRO1FBQUUsR0FBR2IsT0FBTztJQUFDO0FBQzVHWCx1QkFBdUIsR0FBR0c7QUFDMUIsTUFBTUQsVUFBVSxDQUFDUyxVQUFZLENBQUNDLFFBQVFhO1FBQ2xDLElBQUlaO1FBQ0osSUFBSSxDQUFDSCxVQUFVSSxhQUFhLENBQUNDLEdBQUcsQ0FBQ0gsT0FBT2MsV0FBVyxHQUFHO1lBQ2xEYixTQUFTSCxVQUFVSSxhQUFhLENBQUNFLGFBQWEsQ0FBQ0osT0FBT2MsV0FBVztZQUNqRWhCLFVBQVVJLGFBQWEsQ0FBQ0csR0FBRyxDQUFDTCxPQUFPYyxXQUFXLEVBQUViO1FBQ3BELE9BQ0s7WUFDREEsU0FBU0gsVUFBVUksYUFBYSxDQUFDSSxHQUFHLENBQUNOLE9BQU9jLFdBQVc7UUFDM0Q7UUFDQSxNQUFNQyxjQUFjN0IsT0FBT3FCLE1BQU0sQ0FBQyxDQUFDLEdBQUdSO1FBQ3RDLElBQUksT0FBT2dCLFlBQVlQLElBQUksS0FBSyxZQUFZLENBQUNPLFlBQVlDLFNBQVMsRUFBRTtZQUNoRSxNQUFNQyxtQkFBbUJ0QixXQUFXc0IsZ0JBQWdCLENBQUNsQixRQUFRUyxJQUFJO1lBQ2pFLElBQUksQ0FBQ1Msa0JBQWtCO2dCQUNuQixNQUFNLElBQUlDLE1BQU0sQ0FBQywyQ0FBMkMsRUFBRUwsWUFBWSxLQUFLLEVBQUViLE9BQU9jLFdBQVcsQ0FBQ0ssSUFBSSxDQUFDLENBQUM7WUFDOUc7WUFDQUosWUFBWUMsU0FBUyxHQUFHQztRQUM1QjtRQUNBaEIsT0FBT21CLEtBQUssQ0FBQ1AsWUFBWSxHQUFHRTtJQUNoQztBQUNBM0IsZUFBZSxHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1ha2V0cGxhY2UtYWRtaW4vLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9kZWNvcmF0b3JzLmpzPzMxNWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzblByb3AgPSBleHBvcnRzLkFzblNlcXVlbmNlVHlwZSA9IGV4cG9ydHMuQXNuU2V0VHlwZSA9IGV4cG9ydHMuQXNuQ2hvaWNlVHlwZSA9IGV4cG9ydHMuQXNuVHlwZSA9IHZvaWQgMDtcbmNvbnN0IGNvbnZlcnRlcnMgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzXCIpO1xuY29uc3QgZW51bXNfMSA9IHJlcXVpcmUoXCIuL2VudW1zXCIpO1xuY29uc3Qgc3RvcmFnZV8xID0gcmVxdWlyZShcIi4vc3RvcmFnZVwiKTtcbmNvbnN0IEFzblR5cGUgPSAob3B0aW9ucykgPT4gKHRhcmdldCkgPT4ge1xuICAgIGxldCBzY2hlbWE7XG4gICAgaWYgKCFzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5oYXModGFyZ2V0KSkge1xuICAgICAgICBzY2hlbWEgPSBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5jcmVhdGVEZWZhdWx0KHRhcmdldCk7XG4gICAgICAgIHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLnNldCh0YXJnZXQsIHNjaGVtYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzY2hlbWEgPSBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0KTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihzY2hlbWEsIG9wdGlvbnMpO1xufTtcbmV4cG9ydHMuQXNuVHlwZSA9IEFzblR5cGU7XG5jb25zdCBBc25DaG9pY2VUeXBlID0gKCkgPT4gKDAsIGV4cG9ydHMuQXNuVHlwZSkoeyB0eXBlOiBlbnVtc18xLkFzblR5cGVUeXBlcy5DaG9pY2UgfSk7XG5leHBvcnRzLkFzbkNob2ljZVR5cGUgPSBBc25DaG9pY2VUeXBlO1xuY29uc3QgQXNuU2V0VHlwZSA9IChvcHRpb25zKSA9PiAoMCwgZXhwb3J0cy5Bc25UeXBlKSh7IHR5cGU6IGVudW1zXzEuQXNuVHlwZVR5cGVzLlNldCwgLi4ub3B0aW9ucyB9KTtcbmV4cG9ydHMuQXNuU2V0VHlwZSA9IEFzblNldFR5cGU7XG5jb25zdCBBc25TZXF1ZW5jZVR5cGUgPSAob3B0aW9ucykgPT4gKDAsIGV4cG9ydHMuQXNuVHlwZSkoeyB0eXBlOiBlbnVtc18xLkFzblR5cGVUeXBlcy5TZXF1ZW5jZSwgLi4ub3B0aW9ucyB9KTtcbmV4cG9ydHMuQXNuU2VxdWVuY2VUeXBlID0gQXNuU2VxdWVuY2VUeXBlO1xuY29uc3QgQXNuUHJvcCA9IChvcHRpb25zKSA9PiAodGFyZ2V0LCBwcm9wZXJ0eUtleSkgPT4ge1xuICAgIGxldCBzY2hlbWE7XG4gICAgaWYgKCFzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5oYXModGFyZ2V0LmNvbnN0cnVjdG9yKSkge1xuICAgICAgICBzY2hlbWEgPSBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5jcmVhdGVEZWZhdWx0KHRhcmdldC5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLnNldCh0YXJnZXQuY29uc3RydWN0b3IsIHNjaGVtYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzY2hlbWEgPSBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0LmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgY29uc3QgY29weU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICBpZiAodHlwZW9mIGNvcHlPcHRpb25zLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWNvcHlPcHRpb25zLmNvbnZlcnRlcikge1xuICAgICAgICBjb25zdCBkZWZhdWx0Q29udmVydGVyID0gY29udmVydGVycy5kZWZhdWx0Q29udmVydGVyKG9wdGlvbnMudHlwZSk7XG4gICAgICAgIGlmICghZGVmYXVsdENvbnZlcnRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2V0IGRlZmF1bHQgY29udmVydGVyIGZvciBwcm9wZXJ0eSAnJHtwcm9wZXJ0eUtleX0nIG9mICR7dGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29weU9wdGlvbnMuY29udmVydGVyID0gZGVmYXVsdENvbnZlcnRlcjtcbiAgICB9XG4gICAgc2NoZW1hLml0ZW1zW3Byb3BlcnR5S2V5XSA9IGNvcHlPcHRpb25zO1xufTtcbmV4cG9ydHMuQXNuUHJvcCA9IEFzblByb3A7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBc25Qcm9wIiwiQXNuU2VxdWVuY2VUeXBlIiwiQXNuU2V0VHlwZSIsIkFzbkNob2ljZVR5cGUiLCJBc25UeXBlIiwiY29udmVydGVycyIsInJlcXVpcmUiLCJlbnVtc18xIiwic3RvcmFnZV8xIiwib3B0aW9ucyIsInRhcmdldCIsInNjaGVtYSIsInNjaGVtYVN0b3JhZ2UiLCJoYXMiLCJjcmVhdGVEZWZhdWx0Iiwic2V0IiwiZ2V0IiwiYXNzaWduIiwidHlwZSIsIkFzblR5cGVUeXBlcyIsIkNob2ljZSIsIlNldCIsIlNlcXVlbmNlIiwicHJvcGVydHlLZXkiLCJjb25zdHJ1Y3RvciIsImNvcHlPcHRpb25zIiwiY29udmVydGVyIiwiZGVmYXVsdENvbnZlcnRlciIsIkVycm9yIiwibmFtZSIsIml0ZW1zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/decorators.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/decorators.js":
/*!********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/decorators.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnProp = exports.AsnSequenceType = exports.AsnSetType = exports.AsnChoiceType = exports.AsnType = void 0;\nconst converters = __webpack_require__(/*! ./converters */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nconst AsnType = (options)=>(target)=>{\n        let schema;\n        if (!storage_1.schemaStorage.has(target)) {\n            schema = storage_1.schemaStorage.createDefault(target);\n            storage_1.schemaStorage.set(target, schema);\n        } else {\n            schema = storage_1.schemaStorage.get(target);\n        }\n        Object.assign(schema, options);\n    };\nexports.AsnType = AsnType;\nconst AsnChoiceType = ()=>(0, exports.AsnType)({\n        type: enums_1.AsnTypeTypes.Choice\n    });\nexports.AsnChoiceType = AsnChoiceType;\nconst AsnSetType = (options)=>(0, exports.AsnType)({\n        type: enums_1.AsnTypeTypes.Set,\n        ...options\n    });\nexports.AsnSetType = AsnSetType;\nconst AsnSequenceType = (options)=>(0, exports.AsnType)({\n        type: enums_1.AsnTypeTypes.Sequence,\n        ...options\n    });\nexports.AsnSequenceType = AsnSequenceType;\nconst AsnProp = (options)=>(target, propertyKey)=>{\n        let schema;\n        if (!storage_1.schemaStorage.has(target.constructor)) {\n            schema = storage_1.schemaStorage.createDefault(target.constructor);\n            storage_1.schemaStorage.set(target.constructor, schema);\n        } else {\n            schema = storage_1.schemaStorage.get(target.constructor);\n        }\n        const copyOptions = Object.assign({}, options);\n        if (typeof copyOptions.type === \"number\" && !copyOptions.converter) {\n            const defaultConverter = converters.defaultConverter(options.type);\n            if (!defaultConverter) {\n                throw new Error(`Cannot get default converter for property '${propertyKey}' of ${target.constructor.name}`);\n            }\n            copyOptions.converter = defaultConverter;\n        }\n        schema.items[propertyKey] = copyOptions;\n    };\nexports.AsnProp = AsnProp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9kZWNvcmF0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxlQUFlLEdBQUdBLHVCQUF1QixHQUFHQSxrQkFBa0IsR0FBR0EscUJBQXFCLEdBQUdBLGVBQWUsR0FBRyxLQUFLO0FBQ2hILE1BQU1PLGFBQWFDLG1CQUFPQSxDQUFDLHdGQUFjO0FBQ3pDLE1BQU1DLFVBQVVELG1CQUFPQSxDQUFDLDhFQUFTO0FBQ2pDLE1BQU1FLFlBQVlGLG1CQUFPQSxDQUFDLGtGQUFXO0FBQ3JDLE1BQU1GLFVBQVUsQ0FBQ0ssVUFBWSxDQUFDQztRQUMxQixJQUFJQztRQUNKLElBQUksQ0FBQ0gsVUFBVUksYUFBYSxDQUFDQyxHQUFHLENBQUNILFNBQVM7WUFDdENDLFNBQVNILFVBQVVJLGFBQWEsQ0FBQ0UsYUFBYSxDQUFDSjtZQUMvQ0YsVUFBVUksYUFBYSxDQUFDRyxHQUFHLENBQUNMLFFBQVFDO1FBQ3hDLE9BQ0s7WUFDREEsU0FBU0gsVUFBVUksYUFBYSxDQUFDSSxHQUFHLENBQUNOO1FBQ3pDO1FBQ0FkLE9BQU9xQixNQUFNLENBQUNOLFFBQVFGO0lBQzFCO0FBQ0FYLGVBQWUsR0FBR007QUFDbEIsTUFBTUQsZ0JBQWdCLElBQU0sQ0FBQyxHQUFHTCxRQUFRTSxPQUFPLEVBQUU7UUFBRWMsTUFBTVgsUUFBUVksWUFBWSxDQUFDQyxNQUFNO0lBQUM7QUFDckZ0QixxQkFBcUIsR0FBR0s7QUFDeEIsTUFBTUQsYUFBYSxDQUFDTyxVQUFZLENBQUMsR0FBR1gsUUFBUU0sT0FBTyxFQUFFO1FBQUVjLE1BQU1YLFFBQVFZLFlBQVksQ0FBQ0UsR0FBRztRQUFFLEdBQUdaLE9BQU87SUFBQztBQUNsR1gsa0JBQWtCLEdBQUdJO0FBQ3JCLE1BQU1ELGtCQUFrQixDQUFDUSxVQUFZLENBQUMsR0FBR1gsUUFBUU0sT0FBTyxFQUFFO1FBQUVjLE1BQU1YLFFBQVFZLFlBQVksQ0FBQ0csUUFBUTtRQUFFLEdBQUdiLE9BQU87SUFBQztBQUM1R1gsdUJBQXVCLEdBQUdHO0FBQzFCLE1BQU1ELFVBQVUsQ0FBQ1MsVUFBWSxDQUFDQyxRQUFRYTtRQUNsQyxJQUFJWjtRQUNKLElBQUksQ0FBQ0gsVUFBVUksYUFBYSxDQUFDQyxHQUFHLENBQUNILE9BQU9jLFdBQVcsR0FBRztZQUNsRGIsU0FBU0gsVUFBVUksYUFBYSxDQUFDRSxhQUFhLENBQUNKLE9BQU9jLFdBQVc7WUFDakVoQixVQUFVSSxhQUFhLENBQUNHLEdBQUcsQ0FBQ0wsT0FBT2MsV0FBVyxFQUFFYjtRQUNwRCxPQUNLO1lBQ0RBLFNBQVNILFVBQVVJLGFBQWEsQ0FBQ0ksR0FBRyxDQUFDTixPQUFPYyxXQUFXO1FBQzNEO1FBQ0EsTUFBTUMsY0FBYzdCLE9BQU9xQixNQUFNLENBQUMsQ0FBQyxHQUFHUjtRQUN0QyxJQUFJLE9BQU9nQixZQUFZUCxJQUFJLEtBQUssWUFBWSxDQUFDTyxZQUFZQyxTQUFTLEVBQUU7WUFDaEUsTUFBTUMsbUJBQW1CdEIsV0FBV3NCLGdCQUFnQixDQUFDbEIsUUFBUVMsSUFBSTtZQUNqRSxJQUFJLENBQUNTLGtCQUFrQjtnQkFDbkIsTUFBTSxJQUFJQyxNQUFNLENBQUMsMkNBQTJDLEVBQUVMLFlBQVksS0FBSyxFQUFFYixPQUFPYyxXQUFXLENBQUNLLElBQUksQ0FBQyxDQUFDO1lBQzlHO1lBQ0FKLFlBQVlDLFNBQVMsR0FBR0M7UUFDNUI7UUFDQWhCLE9BQU9tQixLQUFLLENBQUNQLFlBQVksR0FBR0U7SUFDaEM7QUFDQTNCLGVBQWUsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYWtldHBsYWNlLWFkbWluLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvZGVjb3JhdG9ycy5qcz8zMTVhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25Qcm9wID0gZXhwb3J0cy5Bc25TZXF1ZW5jZVR5cGUgPSBleHBvcnRzLkFzblNldFR5cGUgPSBleHBvcnRzLkFzbkNob2ljZVR5cGUgPSBleHBvcnRzLkFzblR5cGUgPSB2b2lkIDA7XG5jb25zdCBjb252ZXJ0ZXJzID0gcmVxdWlyZShcIi4vY29udmVydGVyc1wiKTtcbmNvbnN0IGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbmNvbnN0IHN0b3JhZ2VfMSA9IHJlcXVpcmUoXCIuL3N0b3JhZ2VcIik7XG5jb25zdCBBc25UeXBlID0gKG9wdGlvbnMpID0+ICh0YXJnZXQpID0+IHtcbiAgICBsZXQgc2NoZW1hO1xuICAgIGlmICghc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuaGFzKHRhcmdldCkpIHtcbiAgICAgICAgc2NoZW1hID0gc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuY3JlYXRlRGVmYXVsdCh0YXJnZXQpO1xuICAgICAgICBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5zZXQodGFyZ2V0LCBzY2hlbWEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2NoZW1hID0gc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuZ2V0KHRhcmdldCk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oc2NoZW1hLCBvcHRpb25zKTtcbn07XG5leHBvcnRzLkFzblR5cGUgPSBBc25UeXBlO1xuY29uc3QgQXNuQ2hvaWNlVHlwZSA9ICgpID0+ICgwLCBleHBvcnRzLkFzblR5cGUpKHsgdHlwZTogZW51bXNfMS5Bc25UeXBlVHlwZXMuQ2hvaWNlIH0pO1xuZXhwb3J0cy5Bc25DaG9pY2VUeXBlID0gQXNuQ2hvaWNlVHlwZTtcbmNvbnN0IEFzblNldFR5cGUgPSAob3B0aW9ucykgPT4gKDAsIGV4cG9ydHMuQXNuVHlwZSkoeyB0eXBlOiBlbnVtc18xLkFzblR5cGVUeXBlcy5TZXQsIC4uLm9wdGlvbnMgfSk7XG5leHBvcnRzLkFzblNldFR5cGUgPSBBc25TZXRUeXBlO1xuY29uc3QgQXNuU2VxdWVuY2VUeXBlID0gKG9wdGlvbnMpID0+ICgwLCBleHBvcnRzLkFzblR5cGUpKHsgdHlwZTogZW51bXNfMS5Bc25UeXBlVHlwZXMuU2VxdWVuY2UsIC4uLm9wdGlvbnMgfSk7XG5leHBvcnRzLkFzblNlcXVlbmNlVHlwZSA9IEFzblNlcXVlbmNlVHlwZTtcbmNvbnN0IEFzblByb3AgPSAob3B0aW9ucykgPT4gKHRhcmdldCwgcHJvcGVydHlLZXkpID0+IHtcbiAgICBsZXQgc2NoZW1hO1xuICAgIGlmICghc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuaGFzKHRhcmdldC5jb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgc2NoZW1hID0gc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuY3JlYXRlRGVmYXVsdCh0YXJnZXQuY29uc3RydWN0b3IpO1xuICAgICAgICBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5zZXQodGFyZ2V0LmNvbnN0cnVjdG9yLCBzY2hlbWEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2NoZW1hID0gc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuZ2V0KHRhcmdldC5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuICAgIGNvbnN0IGNvcHlPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgaWYgKHR5cGVvZiBjb3B5T3B0aW9ucy50eXBlID09PSBcIm51bWJlclwiICYmICFjb3B5T3B0aW9ucy5jb252ZXJ0ZXIpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdENvbnZlcnRlciA9IGNvbnZlcnRlcnMuZGVmYXVsdENvbnZlcnRlcihvcHRpb25zLnR5cGUpO1xuICAgICAgICBpZiAoIWRlZmF1bHRDb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGdldCBkZWZhdWx0IGNvbnZlcnRlciBmb3IgcHJvcGVydHkgJyR7cHJvcGVydHlLZXl9JyBvZiAke3RhcmdldC5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvcHlPcHRpb25zLmNvbnZlcnRlciA9IGRlZmF1bHRDb252ZXJ0ZXI7XG4gICAgfVxuICAgIHNjaGVtYS5pdGVtc1twcm9wZXJ0eUtleV0gPSBjb3B5T3B0aW9ucztcbn07XG5leHBvcnRzLkFzblByb3AgPSBBc25Qcm9wO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQXNuUHJvcCIsIkFzblNlcXVlbmNlVHlwZSIsIkFzblNldFR5cGUiLCJBc25DaG9pY2VUeXBlIiwiQXNuVHlwZSIsImNvbnZlcnRlcnMiLCJyZXF1aXJlIiwiZW51bXNfMSIsInN0b3JhZ2VfMSIsIm9wdGlvbnMiLCJ0YXJnZXQiLCJzY2hlbWEiLCJzY2hlbWFTdG9yYWdlIiwiaGFzIiwiY3JlYXRlRGVmYXVsdCIsInNldCIsImdldCIsImFzc2lnbiIsInR5cGUiLCJBc25UeXBlVHlwZXMiLCJDaG9pY2UiLCJTZXQiLCJTZXF1ZW5jZSIsInByb3BlcnR5S2V5IiwiY29uc3RydWN0b3IiLCJjb3B5T3B0aW9ucyIsImNvbnZlcnRlciIsImRlZmF1bHRDb252ZXJ0ZXIiLCJFcnJvciIsIm5hbWUiLCJpdGVtcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/decorators.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js":
/*!***************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/enums.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnPropTypes = exports.AsnTypeTypes = void 0;\nvar AsnTypeTypes;\n(function(AsnTypeTypes) {\n    AsnTypeTypes[AsnTypeTypes[\"Sequence\"] = 0] = \"Sequence\";\n    AsnTypeTypes[AsnTypeTypes[\"Set\"] = 1] = \"Set\";\n    AsnTypeTypes[AsnTypeTypes[\"Choice\"] = 2] = \"Choice\";\n})(AsnTypeTypes = exports.AsnTypeTypes || (exports.AsnTypeTypes = {}));\nvar AsnPropTypes;\n(function(AsnPropTypes) {\n    AsnPropTypes[AsnPropTypes[\"Any\"] = 1] = \"Any\";\n    AsnPropTypes[AsnPropTypes[\"Boolean\"] = 2] = \"Boolean\";\n    AsnPropTypes[AsnPropTypes[\"OctetString\"] = 3] = \"OctetString\";\n    AsnPropTypes[AsnPropTypes[\"BitString\"] = 4] = \"BitString\";\n    AsnPropTypes[AsnPropTypes[\"Integer\"] = 5] = \"Integer\";\n    AsnPropTypes[AsnPropTypes[\"Enumerated\"] = 6] = \"Enumerated\";\n    AsnPropTypes[AsnPropTypes[\"ObjectIdentifier\"] = 7] = \"ObjectIdentifier\";\n    AsnPropTypes[AsnPropTypes[\"Utf8String\"] = 8] = \"Utf8String\";\n    AsnPropTypes[AsnPropTypes[\"BmpString\"] = 9] = \"BmpString\";\n    AsnPropTypes[AsnPropTypes[\"UniversalString\"] = 10] = \"UniversalString\";\n    AsnPropTypes[AsnPropTypes[\"NumericString\"] = 11] = \"NumericString\";\n    AsnPropTypes[AsnPropTypes[\"PrintableString\"] = 12] = \"PrintableString\";\n    AsnPropTypes[AsnPropTypes[\"TeletexString\"] = 13] = \"TeletexString\";\n    AsnPropTypes[AsnPropTypes[\"VideotexString\"] = 14] = \"VideotexString\";\n    AsnPropTypes[AsnPropTypes[\"IA5String\"] = 15] = \"IA5String\";\n    AsnPropTypes[AsnPropTypes[\"GraphicString\"] = 16] = \"GraphicString\";\n    AsnPropTypes[AsnPropTypes[\"VisibleString\"] = 17] = \"VisibleString\";\n    AsnPropTypes[AsnPropTypes[\"GeneralString\"] = 18] = \"GeneralString\";\n    AsnPropTypes[AsnPropTypes[\"CharacterString\"] = 19] = \"CharacterString\";\n    AsnPropTypes[AsnPropTypes[\"UTCTime\"] = 20] = \"UTCTime\";\n    AsnPropTypes[AsnPropTypes[\"GeneralizedTime\"] = 21] = \"GeneralizedTime\";\n    AsnPropTypes[AsnPropTypes[\"DATE\"] = 22] = \"DATE\";\n    AsnPropTypes[AsnPropTypes[\"TimeOfDay\"] = 23] = \"TimeOfDay\";\n    AsnPropTypes[AsnPropTypes[\"DateTime\"] = 24] = \"DateTime\";\n    AsnPropTypes[AsnPropTypes[\"Duration\"] = 25] = \"Duration\";\n    AsnPropTypes[AsnPropTypes[\"TIME\"] = 26] = \"TIME\";\n    AsnPropTypes[AsnPropTypes[\"Null\"] = 27] = \"Null\";\n})(AsnPropTypes = exports.AsnPropTypes || (exports.AsnPropTypes = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2VudW1zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxvQkFBb0IsR0FBR0Esb0JBQW9CLEdBQUcsS0FBSztBQUNuRCxJQUFJRztBQUNILFVBQVVBLFlBQVk7SUFDbkJBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFdBQVcsR0FBRyxFQUFFLEdBQUc7SUFDN0NBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUc7SUFDeENBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7QUFDL0MsR0FBR0EsZUFBZUgsUUFBUUcsWUFBWSxJQUFLSCxDQUFBQSxvQkFBb0IsR0FBRyxDQUFDO0FBQ25FLElBQUlFO0FBQ0gsVUFBVUEsWUFBWTtJQUNuQkEsWUFBWSxDQUFDQSxZQUFZLENBQUMsTUFBTSxHQUFHLEVBQUUsR0FBRztJQUN4Q0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUM1Q0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsY0FBYyxHQUFHLEVBQUUsR0FBRztJQUNoREEsWUFBWSxDQUFDQSxZQUFZLENBQUMsWUFBWSxHQUFHLEVBQUUsR0FBRztJQUM5Q0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUM1Q0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsYUFBYSxHQUFHLEVBQUUsR0FBRztJQUMvQ0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsbUJBQW1CLEdBQUcsRUFBRSxHQUFHO0lBQ3JEQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxhQUFhLEdBQUcsRUFBRSxHQUFHO0lBQy9DQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxZQUFZLEdBQUcsRUFBRSxHQUFHO0lBQzlDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxrQkFBa0IsR0FBRyxHQUFHLEdBQUc7SUFDckRBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLGdCQUFnQixHQUFHLEdBQUcsR0FBRztJQUNuREEsWUFBWSxDQUFDQSxZQUFZLENBQUMsa0JBQWtCLEdBQUcsR0FBRyxHQUFHO0lBQ3JEQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxnQkFBZ0IsR0FBRyxHQUFHLEdBQUc7SUFDbkRBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLGlCQUFpQixHQUFHLEdBQUcsR0FBRztJQUNwREEsWUFBWSxDQUFDQSxZQUFZLENBQUMsWUFBWSxHQUFHLEdBQUcsR0FBRztJQUMvQ0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsZ0JBQWdCLEdBQUcsR0FBRyxHQUFHO0lBQ25EQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxnQkFBZ0IsR0FBRyxHQUFHLEdBQUc7SUFDbkRBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLGdCQUFnQixHQUFHLEdBQUcsR0FBRztJQUNuREEsWUFBWSxDQUFDQSxZQUFZLENBQUMsa0JBQWtCLEdBQUcsR0FBRyxHQUFHO0lBQ3JEQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxVQUFVLEdBQUcsR0FBRyxHQUFHO0lBQzdDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxrQkFBa0IsR0FBRyxHQUFHLEdBQUc7SUFDckRBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLE9BQU8sR0FBRyxHQUFHLEdBQUc7SUFDMUNBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFlBQVksR0FBRyxHQUFHLEdBQUc7SUFDL0NBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUc7SUFDOUNBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFdBQVcsR0FBRyxHQUFHLEdBQUc7SUFDOUNBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLE9BQU8sR0FBRyxHQUFHLEdBQUc7SUFDMUNBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLE9BQU8sR0FBRyxHQUFHLEdBQUc7QUFDOUMsR0FBR0EsZUFBZUYsUUFBUUUsWUFBWSxJQUFLRixDQUFBQSxvQkFBb0IsR0FBRyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktbWFrZXRwbGFjZS1hZG1pbi8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2VudW1zLmpzP2JhMTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzblByb3BUeXBlcyA9IGV4cG9ydHMuQXNuVHlwZVR5cGVzID0gdm9pZCAwO1xudmFyIEFzblR5cGVUeXBlcztcbihmdW5jdGlvbiAoQXNuVHlwZVR5cGVzKSB7XG4gICAgQXNuVHlwZVR5cGVzW0FzblR5cGVUeXBlc1tcIlNlcXVlbmNlXCJdID0gMF0gPSBcIlNlcXVlbmNlXCI7XG4gICAgQXNuVHlwZVR5cGVzW0FzblR5cGVUeXBlc1tcIlNldFwiXSA9IDFdID0gXCJTZXRcIjtcbiAgICBBc25UeXBlVHlwZXNbQXNuVHlwZVR5cGVzW1wiQ2hvaWNlXCJdID0gMl0gPSBcIkNob2ljZVwiO1xufSkoQXNuVHlwZVR5cGVzID0gZXhwb3J0cy5Bc25UeXBlVHlwZXMgfHwgKGV4cG9ydHMuQXNuVHlwZVR5cGVzID0ge30pKTtcbnZhciBBc25Qcm9wVHlwZXM7XG4oZnVuY3Rpb24gKEFzblByb3BUeXBlcykge1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJBbnlcIl0gPSAxXSA9IFwiQW55XCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkJvb2xlYW5cIl0gPSAyXSA9IFwiQm9vbGVhblwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJPY3RldFN0cmluZ1wiXSA9IDNdID0gXCJPY3RldFN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJCaXRTdHJpbmdcIl0gPSA0XSA9IFwiQml0U3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkludGVnZXJcIl0gPSA1XSA9IFwiSW50ZWdlclwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJFbnVtZXJhdGVkXCJdID0gNl0gPSBcIkVudW1lcmF0ZWRcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiT2JqZWN0SWRlbnRpZmllclwiXSA9IDddID0gXCJPYmplY3RJZGVudGlmaWVyXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIlV0ZjhTdHJpbmdcIl0gPSA4XSA9IFwiVXRmOFN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJCbXBTdHJpbmdcIl0gPSA5XSA9IFwiQm1wU3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIlVuaXZlcnNhbFN0cmluZ1wiXSA9IDEwXSA9IFwiVW5pdmVyc2FsU3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIk51bWVyaWNTdHJpbmdcIl0gPSAxMV0gPSBcIk51bWVyaWNTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiUHJpbnRhYmxlU3RyaW5nXCJdID0gMTJdID0gXCJQcmludGFibGVTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiVGVsZXRleFN0cmluZ1wiXSA9IDEzXSA9IFwiVGVsZXRleFN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJWaWRlb3RleFN0cmluZ1wiXSA9IDE0XSA9IFwiVmlkZW90ZXhTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiSUE1U3RyaW5nXCJdID0gMTVdID0gXCJJQTVTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiR3JhcGhpY1N0cmluZ1wiXSA9IDE2XSA9IFwiR3JhcGhpY1N0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJWaXNpYmxlU3RyaW5nXCJdID0gMTddID0gXCJWaXNpYmxlU3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkdlbmVyYWxTdHJpbmdcIl0gPSAxOF0gPSBcIkdlbmVyYWxTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiQ2hhcmFjdGVyU3RyaW5nXCJdID0gMTldID0gXCJDaGFyYWN0ZXJTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiVVRDVGltZVwiXSA9IDIwXSA9IFwiVVRDVGltZVwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJHZW5lcmFsaXplZFRpbWVcIl0gPSAyMV0gPSBcIkdlbmVyYWxpemVkVGltZVwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJEQVRFXCJdID0gMjJdID0gXCJEQVRFXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIlRpbWVPZkRheVwiXSA9IDIzXSA9IFwiVGltZU9mRGF5XCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkRhdGVUaW1lXCJdID0gMjRdID0gXCJEYXRlVGltZVwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJEdXJhdGlvblwiXSA9IDI1XSA9IFwiRHVyYXRpb25cIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiVElNRVwiXSA9IDI2XSA9IFwiVElNRVwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJOdWxsXCJdID0gMjddID0gXCJOdWxsXCI7XG59KShBc25Qcm9wVHlwZXMgPSBleHBvcnRzLkFzblByb3BUeXBlcyB8fCAoZXhwb3J0cy5Bc25Qcm9wVHlwZXMgPSB7fSkpO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQXNuUHJvcFR5cGVzIiwiQXNuVHlwZVR5cGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js":
/*!***************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/enums.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnPropTypes = exports.AsnTypeTypes = void 0;\nvar AsnTypeTypes;\n(function(AsnTypeTypes) {\n    AsnTypeTypes[AsnTypeTypes[\"Sequence\"] = 0] = \"Sequence\";\n    AsnTypeTypes[AsnTypeTypes[\"Set\"] = 1] = \"Set\";\n    AsnTypeTypes[AsnTypeTypes[\"Choice\"] = 2] = \"Choice\";\n})(AsnTypeTypes = exports.AsnTypeTypes || (exports.AsnTypeTypes = {}));\nvar AsnPropTypes;\n(function(AsnPropTypes) {\n    AsnPropTypes[AsnPropTypes[\"Any\"] = 1] = \"Any\";\n    AsnPropTypes[AsnPropTypes[\"Boolean\"] = 2] = \"Boolean\";\n    AsnPropTypes[AsnPropTypes[\"OctetString\"] = 3] = \"OctetString\";\n    AsnPropTypes[AsnPropTypes[\"BitString\"] = 4] = \"BitString\";\n    AsnPropTypes[AsnPropTypes[\"Integer\"] = 5] = \"Integer\";\n    AsnPropTypes[AsnPropTypes[\"Enumerated\"] = 6] = \"Enumerated\";\n    AsnPropTypes[AsnPropTypes[\"ObjectIdentifier\"] = 7] = \"ObjectIdentifier\";\n    AsnPropTypes[AsnPropTypes[\"Utf8String\"] = 8] = \"Utf8String\";\n    AsnPropTypes[AsnPropTypes[\"BmpString\"] = 9] = \"BmpString\";\n    AsnPropTypes[AsnPropTypes[\"UniversalString\"] = 10] = \"UniversalString\";\n    AsnPropTypes[AsnPropTypes[\"NumericString\"] = 11] = \"NumericString\";\n    AsnPropTypes[AsnPropTypes[\"PrintableString\"] = 12] = \"PrintableString\";\n    AsnPropTypes[AsnPropTypes[\"TeletexString\"] = 13] = \"TeletexString\";\n    AsnPropTypes[AsnPropTypes[\"VideotexString\"] = 14] = \"VideotexString\";\n    AsnPropTypes[AsnPropTypes[\"IA5String\"] = 15] = \"IA5String\";\n    AsnPropTypes[AsnPropTypes[\"GraphicString\"] = 16] = \"GraphicString\";\n    AsnPropTypes[AsnPropTypes[\"VisibleString\"] = 17] = \"VisibleString\";\n    AsnPropTypes[AsnPropTypes[\"GeneralString\"] = 18] = \"GeneralString\";\n    AsnPropTypes[AsnPropTypes[\"CharacterString\"] = 19] = \"CharacterString\";\n    AsnPropTypes[AsnPropTypes[\"UTCTime\"] = 20] = \"UTCTime\";\n    AsnPropTypes[AsnPropTypes[\"GeneralizedTime\"] = 21] = \"GeneralizedTime\";\n    AsnPropTypes[AsnPropTypes[\"DATE\"] = 22] = \"DATE\";\n    AsnPropTypes[AsnPropTypes[\"TimeOfDay\"] = 23] = \"TimeOfDay\";\n    AsnPropTypes[AsnPropTypes[\"DateTime\"] = 24] = \"DateTime\";\n    AsnPropTypes[AsnPropTypes[\"Duration\"] = 25] = \"Duration\";\n    AsnPropTypes[AsnPropTypes[\"TIME\"] = 26] = \"TIME\";\n    AsnPropTypes[AsnPropTypes[\"Null\"] = 27] = \"Null\";\n})(AsnPropTypes = exports.AsnPropTypes || (exports.AsnPropTypes = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9lbnVtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsb0JBQW9CLEdBQUdBLG9CQUFvQixHQUFHLEtBQUs7QUFDbkQsSUFBSUc7QUFDSCxVQUFVQSxZQUFZO0lBQ25CQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxXQUFXLEdBQUcsRUFBRSxHQUFHO0lBQzdDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxNQUFNLEdBQUcsRUFBRSxHQUFHO0lBQ3hDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0FBQy9DLEdBQUdBLGVBQWVILFFBQVFHLFlBQVksSUFBS0gsQ0FBQUEsb0JBQW9CLEdBQUcsQ0FBQztBQUNuRSxJQUFJRTtBQUNILFVBQVVBLFlBQVk7SUFDbkJBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLE1BQU0sR0FBRyxFQUFFLEdBQUc7SUFDeENBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDNUNBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLGNBQWMsR0FBRyxFQUFFLEdBQUc7SUFDaERBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7SUFDOUNBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDNUNBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDL0NBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLG1CQUFtQixHQUFHLEVBQUUsR0FBRztJQUNyREEsWUFBWSxDQUFDQSxZQUFZLENBQUMsYUFBYSxHQUFHLEVBQUUsR0FBRztJQUMvQ0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsWUFBWSxHQUFHLEVBQUUsR0FBRztJQUM5Q0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsa0JBQWtCLEdBQUcsR0FBRyxHQUFHO0lBQ3JEQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxnQkFBZ0IsR0FBRyxHQUFHLEdBQUc7SUFDbkRBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLGtCQUFrQixHQUFHLEdBQUcsR0FBRztJQUNyREEsWUFBWSxDQUFDQSxZQUFZLENBQUMsZ0JBQWdCLEdBQUcsR0FBRyxHQUFHO0lBQ25EQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxpQkFBaUIsR0FBRyxHQUFHLEdBQUc7SUFDcERBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLFlBQVksR0FBRyxHQUFHLEdBQUc7SUFDL0NBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLGdCQUFnQixHQUFHLEdBQUcsR0FBRztJQUNuREEsWUFBWSxDQUFDQSxZQUFZLENBQUMsZ0JBQWdCLEdBQUcsR0FBRyxHQUFHO0lBQ25EQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxnQkFBZ0IsR0FBRyxHQUFHLEdBQUc7SUFDbkRBLFlBQVksQ0FBQ0EsWUFBWSxDQUFDLGtCQUFrQixHQUFHLEdBQUcsR0FBRztJQUNyREEsWUFBWSxDQUFDQSxZQUFZLENBQUMsVUFBVSxHQUFHLEdBQUcsR0FBRztJQUM3Q0EsWUFBWSxDQUFDQSxZQUFZLENBQUMsa0JBQWtCLEdBQUcsR0FBRyxHQUFHO0lBQ3JEQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxPQUFPLEdBQUcsR0FBRyxHQUFHO0lBQzFDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxZQUFZLEdBQUcsR0FBRyxHQUFHO0lBQy9DQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxXQUFXLEdBQUcsR0FBRyxHQUFHO0lBQzlDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxXQUFXLEdBQUcsR0FBRyxHQUFHO0lBQzlDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxPQUFPLEdBQUcsR0FBRyxHQUFHO0lBQzFDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxPQUFPLEdBQUcsR0FBRyxHQUFHO0FBQzlDLEdBQUdBLGVBQWVGLFFBQVFFLFlBQVksSUFBS0YsQ0FBQUEsb0JBQW9CLEdBQUcsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1ha2V0cGxhY2UtYWRtaW4vLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9lbnVtcy5qcz9iYTE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25Qcm9wVHlwZXMgPSBleHBvcnRzLkFzblR5cGVUeXBlcyA9IHZvaWQgMDtcbnZhciBBc25UeXBlVHlwZXM7XG4oZnVuY3Rpb24gKEFzblR5cGVUeXBlcykge1xuICAgIEFzblR5cGVUeXBlc1tBc25UeXBlVHlwZXNbXCJTZXF1ZW5jZVwiXSA9IDBdID0gXCJTZXF1ZW5jZVwiO1xuICAgIEFzblR5cGVUeXBlc1tBc25UeXBlVHlwZXNbXCJTZXRcIl0gPSAxXSA9IFwiU2V0XCI7XG4gICAgQXNuVHlwZVR5cGVzW0FzblR5cGVUeXBlc1tcIkNob2ljZVwiXSA9IDJdID0gXCJDaG9pY2VcIjtcbn0pKEFzblR5cGVUeXBlcyA9IGV4cG9ydHMuQXNuVHlwZVR5cGVzIHx8IChleHBvcnRzLkFzblR5cGVUeXBlcyA9IHt9KSk7XG52YXIgQXNuUHJvcFR5cGVzO1xuKGZ1bmN0aW9uIChBc25Qcm9wVHlwZXMpIHtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiQW55XCJdID0gMV0gPSBcIkFueVwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJCb29sZWFuXCJdID0gMl0gPSBcIkJvb2xlYW5cIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiT2N0ZXRTdHJpbmdcIl0gPSAzXSA9IFwiT2N0ZXRTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiQml0U3RyaW5nXCJdID0gNF0gPSBcIkJpdFN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJJbnRlZ2VyXCJdID0gNV0gPSBcIkludGVnZXJcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiRW51bWVyYXRlZFwiXSA9IDZdID0gXCJFbnVtZXJhdGVkXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIk9iamVjdElkZW50aWZpZXJcIl0gPSA3XSA9IFwiT2JqZWN0SWRlbnRpZmllclwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJVdGY4U3RyaW5nXCJdID0gOF0gPSBcIlV0ZjhTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiQm1wU3RyaW5nXCJdID0gOV0gPSBcIkJtcFN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJVbml2ZXJzYWxTdHJpbmdcIl0gPSAxMF0gPSBcIlVuaXZlcnNhbFN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJOdW1lcmljU3RyaW5nXCJdID0gMTFdID0gXCJOdW1lcmljU3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIlByaW50YWJsZVN0cmluZ1wiXSA9IDEyXSA9IFwiUHJpbnRhYmxlU3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIlRlbGV0ZXhTdHJpbmdcIl0gPSAxM10gPSBcIlRlbGV0ZXhTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiVmlkZW90ZXhTdHJpbmdcIl0gPSAxNF0gPSBcIlZpZGVvdGV4U3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIklBNVN0cmluZ1wiXSA9IDE1XSA9IFwiSUE1U3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkdyYXBoaWNTdHJpbmdcIl0gPSAxNl0gPSBcIkdyYXBoaWNTdHJpbmdcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiVmlzaWJsZVN0cmluZ1wiXSA9IDE3XSA9IFwiVmlzaWJsZVN0cmluZ1wiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJHZW5lcmFsU3RyaW5nXCJdID0gMThdID0gXCJHZW5lcmFsU3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIkNoYXJhY3RlclN0cmluZ1wiXSA9IDE5XSA9IFwiQ2hhcmFjdGVyU3RyaW5nXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIlVUQ1RpbWVcIl0gPSAyMF0gPSBcIlVUQ1RpbWVcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiR2VuZXJhbGl6ZWRUaW1lXCJdID0gMjFdID0gXCJHZW5lcmFsaXplZFRpbWVcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiREFURVwiXSA9IDIyXSA9IFwiREFURVwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJUaW1lT2ZEYXlcIl0gPSAyM10gPSBcIlRpbWVPZkRheVwiO1xuICAgIEFzblByb3BUeXBlc1tBc25Qcm9wVHlwZXNbXCJEYXRlVGltZVwiXSA9IDI0XSA9IFwiRGF0ZVRpbWVcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiRHVyYXRpb25cIl0gPSAyNV0gPSBcIkR1cmF0aW9uXCI7XG4gICAgQXNuUHJvcFR5cGVzW0FzblByb3BUeXBlc1tcIlRJTUVcIl0gPSAyNl0gPSBcIlRJTUVcIjtcbiAgICBBc25Qcm9wVHlwZXNbQXNuUHJvcFR5cGVzW1wiTnVsbFwiXSA9IDI3XSA9IFwiTnVsbFwiO1xufSkoQXNuUHJvcFR5cGVzID0gZXhwb3J0cy5Bc25Qcm9wVHlwZXMgfHwgKGV4cG9ydHMuQXNuUHJvcFR5cGVzID0ge30pKTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFzblByb3BUeXBlcyIsIkFzblR5cGVUeXBlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(action-browser)/./node_modules/tslib/tslib.es6.mjs\");\ntslib_1.__exportStar(__webpack_require__(/*! ./schema_validation */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2Vycm9ycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxVQUFVQyxtQkFBT0EsQ0FBQyxrRUFBTztBQUMvQkQsUUFBUUUsWUFBWSxDQUFDRCxtQkFBT0EsQ0FBQyx3SEFBcUIsR0FBR0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYWtldHBsYWNlLWFkbWluLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvZXJyb3JzL2luZGV4LmpzP2UxY2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2NoZW1hX3ZhbGlkYXRpb25cIiksIGV4cG9ydHMpO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidHNsaWJfMSIsInJlcXVpcmUiLCJfX2V4cG9ydFN0YXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\ntslib_1.__exportStar(__webpack_require__(/*! ./schema_validation */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9lcnJvcnMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsVUFBVUMsbUJBQU9BLENBQUMsdURBQU87QUFDL0JELFFBQVFFLFlBQVksQ0FBQ0QsbUJBQU9BLENBQUMsNkdBQXFCLEdBQUdIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktbWFrZXRwbGFjZS1hZG1pbi8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2Vycm9ycy9pbmRleC5qcz9lMWNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NjaGVtYV92YWxpZGF0aW9uXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRzbGliXzEiLCJyZXF1aXJlIiwiX19leHBvcnRTdGFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnSchemaValidationError = void 0;\nclass AsnSchemaValidationError extends Error {\n    constructor(){\n        super(...arguments);\n        this.schemas = [];\n    }\n}\nexports.AsnSchemaValidationError = AsnSchemaValidationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2Vycm9ycy9zY2hlbWFfdmFsaWRhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0NBQWdDLEdBQUcsS0FBSztBQUN4QyxNQUFNRSxpQ0FBaUNDO0lBQ25DQyxhQUFjO1FBQ1YsS0FBSyxJQUFJQztRQUNULElBQUksQ0FBQ0MsT0FBTyxHQUFHLEVBQUU7SUFDckI7QUFDSjtBQUNBTixnQ0FBZ0MsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYWtldHBsYWNlLWFkbWluLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvZXJyb3JzL3NjaGVtYV92YWxpZGF0aW9uLmpzPzZjYzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzblNjaGVtYVZhbGlkYXRpb25FcnJvciA9IHZvaWQgMDtcbmNsYXNzIEFzblNjaGVtYVZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zY2hlbWFzID0gW107XG4gICAgfVxufVxuZXhwb3J0cy5Bc25TY2hlbWFWYWxpZGF0aW9uRXJyb3IgPSBBc25TY2hlbWFWYWxpZGF0aW9uRXJyb3I7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBc25TY2hlbWFWYWxpZGF0aW9uRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiYXJndW1lbnRzIiwic2NoZW1hcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnSchemaValidationError = void 0;\nclass AsnSchemaValidationError extends Error {\n    constructor(){\n        super(...arguments);\n        this.schemas = [];\n    }\n}\nexports.AsnSchemaValidationError = AsnSchemaValidationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9lcnJvcnMvc2NoZW1hX3ZhbGlkYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdDQUFnQyxHQUFHLEtBQUs7QUFDeEMsTUFBTUUsaUNBQWlDQztJQUNuQ0MsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUNDLE9BQU8sR0FBRyxFQUFFO0lBQ3JCO0FBQ0o7QUFDQU4sZ0NBQWdDLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktbWFrZXRwbGFjZS1hZG1pbi8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2Vycm9ycy9zY2hlbWFfdmFsaWRhdGlvbi5qcz82Y2M4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25TY2hlbWFWYWxpZGF0aW9uRXJyb3IgPSB2b2lkIDA7XG5jbGFzcyBBc25TY2hlbWFWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc2NoZW1hcyA9IFtdO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNuU2NoZW1hVmFsaWRhdGlvbkVycm9yID0gQXNuU2NoZW1hVmFsaWRhdGlvbkVycm9yO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQXNuU2NoZW1hVmFsaWRhdGlvbkVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImFyZ3VtZW50cyIsInNjaGVtYXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/schema_validation.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js":
/*!****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/helper.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isArrayEqual = exports.isTypeOfArray = exports.isConvertible = void 0;\nfunction isConvertible(target) {\n    if (typeof target === \"function\" && target.prototype) {\n        if (target.prototype.toASN && target.prototype.fromASN) {\n            return true;\n        } else {\n            return isConvertible(target.prototype);\n        }\n    } else {\n        return !!(target && typeof target === \"object\" && \"toASN\" in target && \"fromASN\" in target);\n    }\n}\nexports.isConvertible = isConvertible;\nfunction isTypeOfArray(target) {\n    var _a;\n    if (target) {\n        const proto = Object.getPrototypeOf(target);\n        if (((_a = proto === null || proto === void 0 ? void 0 : proto.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === Array) {\n            return true;\n        }\n        return isTypeOfArray(proto);\n    }\n    return false;\n}\nexports.isTypeOfArray = isTypeOfArray;\nfunction isArrayEqual(bytes1, bytes2) {\n    if (!(bytes1 && bytes2)) {\n        return false;\n    }\n    if (bytes1.byteLength !== bytes2.byteLength) {\n        return false;\n    }\n    const b1 = new Uint8Array(bytes1);\n    const b2 = new Uint8Array(bytes2);\n    for(let i = 0; i < bytes1.byteLength; i++){\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isArrayEqual = isArrayEqual;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2hlbHBlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsb0JBQW9CLEdBQUdBLHFCQUFxQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQzVFLFNBQVNJLGNBQWNDLE1BQU07SUFDekIsSUFBSSxPQUFPQSxXQUFXLGNBQWNBLE9BQU9DLFNBQVMsRUFBRTtRQUNsRCxJQUFJRCxPQUFPQyxTQUFTLENBQUNDLEtBQUssSUFBSUYsT0FBT0MsU0FBUyxDQUFDRSxPQUFPLEVBQUU7WUFDcEQsT0FBTztRQUNYLE9BQ0s7WUFDRCxPQUFPSixjQUFjQyxPQUFPQyxTQUFTO1FBQ3pDO0lBQ0osT0FDSztRQUNELE9BQU8sQ0FBQyxDQUFFRCxDQUFBQSxVQUFVLE9BQU9BLFdBQVcsWUFBWSxXQUFXQSxVQUFVLGFBQWFBLE1BQUs7SUFDN0Y7QUFDSjtBQUNBTCxxQkFBcUIsR0FBR0k7QUFDeEIsU0FBU0QsY0FBY0UsTUFBTTtJQUN6QixJQUFJSTtJQUNKLElBQUlKLFFBQVE7UUFDUixNQUFNSyxRQUFRWixPQUFPYSxjQUFjLENBQUNOO1FBQ3BDLElBQUksQ0FBQyxDQUFDSSxLQUFLQyxVQUFVLFFBQVFBLFVBQVUsS0FBSyxJQUFJLEtBQUssSUFBSUEsTUFBTUosU0FBUyxNQUFNLFFBQVFHLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0csV0FBVyxNQUFNQyxPQUFPO1lBQ3RJLE9BQU87UUFDWDtRQUNBLE9BQU9WLGNBQWNPO0lBQ3pCO0lBQ0EsT0FBTztBQUNYO0FBQ0FWLHFCQUFxQixHQUFHRztBQUN4QixTQUFTRCxhQUFhWSxNQUFNLEVBQUVDLE1BQU07SUFDaEMsSUFBSSxDQUFFRCxDQUFBQSxVQUFVQyxNQUFLLEdBQUk7UUFDckIsT0FBTztJQUNYO0lBQ0EsSUFBSUQsT0FBT0UsVUFBVSxLQUFLRCxPQUFPQyxVQUFVLEVBQUU7UUFDekMsT0FBTztJQUNYO0lBQ0EsTUFBTUMsS0FBSyxJQUFJQyxXQUFXSjtJQUMxQixNQUFNSyxLQUFLLElBQUlELFdBQVdIO0lBQzFCLElBQUssSUFBSUssSUFBSSxHQUFHQSxJQUFJTixPQUFPRSxVQUFVLEVBQUVJLElBQUs7UUFDeEMsSUFBSUgsRUFBRSxDQUFDRyxFQUFFLEtBQUtELEVBQUUsQ0FBQ0MsRUFBRSxFQUFFO1lBQ2pCLE9BQU87UUFDWDtJQUNKO0lBQ0EsT0FBTztBQUNYO0FBQ0FwQixvQkFBb0IsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYWtldHBsYWNlLWFkbWluLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvaGVscGVyLmpzP2YxOTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQXJyYXlFcXVhbCA9IGV4cG9ydHMuaXNUeXBlT2ZBcnJheSA9IGV4cG9ydHMuaXNDb252ZXJ0aWJsZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIGlzQ29udmVydGlibGUodGFyZ2V0KSB7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIGlmICh0YXJnZXQucHJvdG90eXBlLnRvQVNOICYmIHRhcmdldC5wcm90b3R5cGUuZnJvbUFTTikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNDb252ZXJ0aWJsZSh0YXJnZXQucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICEhKHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ID09PSBcIm9iamVjdFwiICYmIFwidG9BU05cIiBpbiB0YXJnZXQgJiYgXCJmcm9tQVNOXCIgaW4gdGFyZ2V0KTtcbiAgICB9XG59XG5leHBvcnRzLmlzQ29udmVydGlibGUgPSBpc0NvbnZlcnRpYmxlO1xuZnVuY3Rpb24gaXNUeXBlT2ZBcnJheSh0YXJnZXQpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICAgICAgICBpZiAoKChfYSA9IHByb3RvID09PSBudWxsIHx8IHByb3RvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm90by5wcm90b3R5cGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25zdHJ1Y3RvcikgPT09IEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNUeXBlT2ZBcnJheShwcm90byk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNUeXBlT2ZBcnJheSA9IGlzVHlwZU9mQXJyYXk7XG5mdW5jdGlvbiBpc0FycmF5RXF1YWwoYnl0ZXMxLCBieXRlczIpIHtcbiAgICBpZiAoIShieXRlczEgJiYgYnl0ZXMyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChieXRlczEuYnl0ZUxlbmd0aCAhPT0gYnl0ZXMyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBiMSA9IG5ldyBVaW50OEFycmF5KGJ5dGVzMSk7XG4gICAgY29uc3QgYjIgPSBuZXcgVWludDhBcnJheShieXRlczIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMxLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYjFbaV0gIT09IGIyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzQXJyYXlFcXVhbCA9IGlzQXJyYXlFcXVhbDtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImlzQXJyYXlFcXVhbCIsImlzVHlwZU9mQXJyYXkiLCJpc0NvbnZlcnRpYmxlIiwidGFyZ2V0IiwicHJvdG90eXBlIiwidG9BU04iLCJmcm9tQVNOIiwiX2EiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwiY29uc3RydWN0b3IiLCJBcnJheSIsImJ5dGVzMSIsImJ5dGVzMiIsImJ5dGVMZW5ndGgiLCJiMSIsIlVpbnQ4QXJyYXkiLCJiMiIsImkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js":
/*!****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/helper.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isArrayEqual = exports.isTypeOfArray = exports.isConvertible = void 0;\nfunction isConvertible(target) {\n    if (typeof target === \"function\" && target.prototype) {\n        if (target.prototype.toASN && target.prototype.fromASN) {\n            return true;\n        } else {\n            return isConvertible(target.prototype);\n        }\n    } else {\n        return !!(target && typeof target === \"object\" && \"toASN\" in target && \"fromASN\" in target);\n    }\n}\nexports.isConvertible = isConvertible;\nfunction isTypeOfArray(target) {\n    var _a;\n    if (target) {\n        const proto = Object.getPrototypeOf(target);\n        if (((_a = proto === null || proto === void 0 ? void 0 : proto.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === Array) {\n            return true;\n        }\n        return isTypeOfArray(proto);\n    }\n    return false;\n}\nexports.isTypeOfArray = isTypeOfArray;\nfunction isArrayEqual(bytes1, bytes2) {\n    if (!(bytes1 && bytes2)) {\n        return false;\n    }\n    if (bytes1.byteLength !== bytes2.byteLength) {\n        return false;\n    }\n    const b1 = new Uint8Array(bytes1);\n    const b2 = new Uint8Array(bytes2);\n    for(let i = 0; i < bytes1.byteLength; i++){\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isArrayEqual = isArrayEqual;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9oZWxwZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSxxQkFBcUIsR0FBR0EscUJBQXFCLEdBQUcsS0FBSztBQUM1RSxTQUFTSSxjQUFjQyxNQUFNO0lBQ3pCLElBQUksT0FBT0EsV0FBVyxjQUFjQSxPQUFPQyxTQUFTLEVBQUU7UUFDbEQsSUFBSUQsT0FBT0MsU0FBUyxDQUFDQyxLQUFLLElBQUlGLE9BQU9DLFNBQVMsQ0FBQ0UsT0FBTyxFQUFFO1lBQ3BELE9BQU87UUFDWCxPQUNLO1lBQ0QsT0FBT0osY0FBY0MsT0FBT0MsU0FBUztRQUN6QztJQUNKLE9BQ0s7UUFDRCxPQUFPLENBQUMsQ0FBRUQsQ0FBQUEsVUFBVSxPQUFPQSxXQUFXLFlBQVksV0FBV0EsVUFBVSxhQUFhQSxNQUFLO0lBQzdGO0FBQ0o7QUFDQUwscUJBQXFCLEdBQUdJO0FBQ3hCLFNBQVNELGNBQWNFLE1BQU07SUFDekIsSUFBSUk7SUFDSixJQUFJSixRQUFRO1FBQ1IsTUFBTUssUUFBUVosT0FBT2EsY0FBYyxDQUFDTjtRQUNwQyxJQUFJLENBQUMsQ0FBQ0ksS0FBS0MsVUFBVSxRQUFRQSxVQUFVLEtBQUssSUFBSSxLQUFLLElBQUlBLE1BQU1KLFNBQVMsTUFBTSxRQUFRRyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdHLFdBQVcsTUFBTUMsT0FBTztZQUN0SSxPQUFPO1FBQ1g7UUFDQSxPQUFPVixjQUFjTztJQUN6QjtJQUNBLE9BQU87QUFDWDtBQUNBVixxQkFBcUIsR0FBR0c7QUFDeEIsU0FBU0QsYUFBYVksTUFBTSxFQUFFQyxNQUFNO0lBQ2hDLElBQUksQ0FBRUQsQ0FBQUEsVUFBVUMsTUFBSyxHQUFJO1FBQ3JCLE9BQU87SUFDWDtJQUNBLElBQUlELE9BQU9FLFVBQVUsS0FBS0QsT0FBT0MsVUFBVSxFQUFFO1FBQ3pDLE9BQU87SUFDWDtJQUNBLE1BQU1DLEtBQUssSUFBSUMsV0FBV0o7SUFDMUIsTUFBTUssS0FBSyxJQUFJRCxXQUFXSDtJQUMxQixJQUFLLElBQUlLLElBQUksR0FBR0EsSUFBSU4sT0FBT0UsVUFBVSxFQUFFSSxJQUFLO1FBQ3hDLElBQUlILEVBQUUsQ0FBQ0csRUFBRSxLQUFLRCxFQUFFLENBQUNDLEVBQUUsRUFBRTtZQUNqQixPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUNBcEIsb0JBQW9CLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktbWFrZXRwbGFjZS1hZG1pbi8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2hlbHBlci5qcz9mMTkyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0FycmF5RXF1YWwgPSBleHBvcnRzLmlzVHlwZU9mQXJyYXkgPSBleHBvcnRzLmlzQ29udmVydGlibGUgPSB2b2lkIDA7XG5mdW5jdGlvbiBpc0NvbnZlcnRpYmxlKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcImZ1bmN0aW9uXCIgJiYgdGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZS50b0FTTiAmJiB0YXJnZXQucHJvdG90eXBlLmZyb21BU04pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzQ29udmVydGlibGUodGFyZ2V0LnByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAhISh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gXCJvYmplY3RcIiAmJiBcInRvQVNOXCIgaW4gdGFyZ2V0ICYmIFwiZnJvbUFTTlwiIGluIHRhcmdldCk7XG4gICAgfVxufVxuZXhwb3J0cy5pc0NvbnZlcnRpYmxlID0gaXNDb252ZXJ0aWJsZTtcbmZ1bmN0aW9uIGlzVHlwZU9mQXJyYXkodGFyZ2V0KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgICAgICAgaWYgKCgoX2EgPSBwcm90byA9PT0gbnVsbCB8fCBwcm90byA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvdG8ucHJvdG90eXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uc3RydWN0b3IpID09PSBBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVHlwZU9mQXJyYXkocHJvdG8pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzVHlwZU9mQXJyYXkgPSBpc1R5cGVPZkFycmF5O1xuZnVuY3Rpb24gaXNBcnJheUVxdWFsKGJ5dGVzMSwgYnl0ZXMyKSB7XG4gICAgaWYgKCEoYnl0ZXMxICYmIGJ5dGVzMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYnl0ZXMxLmJ5dGVMZW5ndGggIT09IGJ5dGVzMi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYjEgPSBuZXcgVWludDhBcnJheShieXRlczEpO1xuICAgIGNvbnN0IGIyID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzMS5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGIxW2ldICE9PSBiMltpXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc0FycmF5RXF1YWwgPSBpc0FycmF5RXF1YWw7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpc0FycmF5RXF1YWwiLCJpc1R5cGVPZkFycmF5IiwiaXNDb252ZXJ0aWJsZSIsInRhcmdldCIsInByb3RvdHlwZSIsInRvQVNOIiwiZnJvbUFTTiIsIl9hIiwicHJvdG8iLCJnZXRQcm90b3R5cGVPZiIsImNvbnN0cnVjdG9yIiwiQXJyYXkiLCJieXRlczEiLCJieXRlczIiLCJieXRlTGVuZ3RoIiwiYjEiLCJVaW50OEFycmF5IiwiYjIiLCJpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnSerializer = exports.AsnParser = exports.AsnPropTypes = exports.AsnTypeTypes = exports.AsnSetType = exports.AsnSequenceType = exports.AsnChoiceType = exports.AsnType = exports.AsnProp = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(action-browser)/./node_modules/tslib/tslib.es6.mjs\");\ntslib_1.__exportStar(__webpack_require__(/*! ./converters */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./types/index */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\"), exports);\nvar decorators_1 = __webpack_require__(/*! ./decorators */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/decorators.js\");\nObject.defineProperty(exports, \"AsnProp\", ({\n    enumerable: true,\n    get: function() {\n        return decorators_1.AsnProp;\n    }\n}));\nObject.defineProperty(exports, \"AsnType\", ({\n    enumerable: true,\n    get: function() {\n        return decorators_1.AsnType;\n    }\n}));\nObject.defineProperty(exports, \"AsnChoiceType\", ({\n    enumerable: true,\n    get: function() {\n        return decorators_1.AsnChoiceType;\n    }\n}));\nObject.defineProperty(exports, \"AsnSequenceType\", ({\n    enumerable: true,\n    get: function() {\n        return decorators_1.AsnSequenceType;\n    }\n}));\nObject.defineProperty(exports, \"AsnSetType\", ({\n    enumerable: true,\n    get: function() {\n        return decorators_1.AsnSetType;\n    }\n}));\nvar enums_1 = __webpack_require__(/*! ./enums */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nObject.defineProperty(exports, \"AsnTypeTypes\", ({\n    enumerable: true,\n    get: function() {\n        return enums_1.AsnTypeTypes;\n    }\n}));\nObject.defineProperty(exports, \"AsnPropTypes\", ({\n    enumerable: true,\n    get: function() {\n        return enums_1.AsnPropTypes;\n    }\n}));\nvar parser_1 = __webpack_require__(/*! ./parser */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/parser.js\");\nObject.defineProperty(exports, \"AsnParser\", ({\n    enumerable: true,\n    get: function() {\n        return parser_1.AsnParser;\n    }\n}));\nvar serializer_1 = __webpack_require__(/*! ./serializer */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\");\nObject.defineProperty(exports, \"AsnSerializer\", ({\n    enumerable: true,\n    get: function() {\n        return serializer_1.AsnSerializer;\n    }\n}));\ntslib_1.__exportStar(__webpack_require__(/*! ./errors */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./objects */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/objects.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./convert */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/convert.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBR0EsaUJBQWlCLEdBQUdBLG9CQUFvQixHQUFHQSxvQkFBb0IsR0FBR0Esa0JBQWtCLEdBQUdBLHVCQUF1QixHQUFHQSxxQkFBcUIsR0FBR0EsZUFBZSxHQUFHQSxlQUFlLEdBQUcsS0FBSztBQUMxTSxNQUFNVyxVQUFVQyxtQkFBT0EsQ0FBQyxrRUFBTztBQUMvQkQsUUFBUUUsWUFBWSxDQUFDRCxtQkFBT0EsQ0FBQyxtR0FBYyxHQUFHWjtBQUM5Q1csUUFBUUUsWUFBWSxDQUFDRCxtQkFBT0EsQ0FBQyxxR0FBZSxHQUFHWjtBQUMvQyxJQUFJYyxlQUFlRixtQkFBT0EsQ0FBQyxtR0FBYztBQUN6Q2QsMkNBQTBDO0lBQUVpQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixhQUFhSixPQUFPO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbEhaLDJDQUEwQztJQUFFaUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsYUFBYUwsT0FBTztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2xIWCxpREFBZ0Q7SUFBRWlCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9GLGFBQWFOLGFBQWE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM5SFYsbURBQWtEO0lBQUVpQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixhQUFhUCxlQUFlO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbElULDhDQUE2QztJQUFFaUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsYUFBYVIsVUFBVTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3hILElBQUlXLFVBQVVMLG1CQUFPQSxDQUFDLHlGQUFTO0FBQy9CZCxnREFBK0M7SUFBRWlCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9DLFFBQVFaLFlBQVk7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN2SFAsZ0RBQStDO0lBQUVpQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxRQUFRYixZQUFZO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDdkgsSUFBSWMsV0FBV04sbUJBQU9BLENBQUMsMkZBQVU7QUFDakNkLDZDQUE0QztJQUFFaUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0UsU0FBU2YsU0FBUztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2xILElBQUlnQixlQUFlUCxtQkFBT0EsQ0FBQyxtR0FBYztBQUN6Q2QsaURBQWdEO0lBQUVpQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRyxhQUFhakIsYUFBYTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzlIUyxRQUFRRSxZQUFZLENBQUNELG1CQUFPQSxDQUFDLGlHQUFVLEdBQUdaO0FBQzFDVyxRQUFRRSxZQUFZLENBQUNELG1CQUFPQSxDQUFDLDZGQUFXLEdBQUdaO0FBQzNDVyxRQUFRRSxZQUFZLENBQUNELG1CQUFPQSxDQUFDLDZGQUFXLEdBQUdaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktbWFrZXRwbGFjZS1hZG1pbi8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL2luZGV4LmpzPzcyOTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzblNlcmlhbGl6ZXIgPSBleHBvcnRzLkFzblBhcnNlciA9IGV4cG9ydHMuQXNuUHJvcFR5cGVzID0gZXhwb3J0cy5Bc25UeXBlVHlwZXMgPSBleHBvcnRzLkFzblNldFR5cGUgPSBleHBvcnRzLkFzblNlcXVlbmNlVHlwZSA9IGV4cG9ydHMuQXNuQ2hvaWNlVHlwZSA9IGV4cG9ydHMuQXNuVHlwZSA9IGV4cG9ydHMuQXNuUHJvcCA9IHZvaWQgMDtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb252ZXJ0ZXJzXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3R5cGVzL2luZGV4XCIpLCBleHBvcnRzKTtcbnZhciBkZWNvcmF0b3JzXzEgPSByZXF1aXJlKFwiLi9kZWNvcmF0b3JzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNuUHJvcFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb3JhdG9yc18xLkFzblByb3A7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25UeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvcmF0b3JzXzEuQXNuVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzbkNob2ljZVR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29yYXRvcnNfMS5Bc25DaG9pY2VUeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNuU2VxdWVuY2VUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvcmF0b3JzXzEuQXNuU2VxdWVuY2VUeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNuU2V0VHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb3JhdG9yc18xLkFzblNldFR5cGU7IH0gfSk7XG52YXIgZW51bXNfMSA9IHJlcXVpcmUoXCIuL2VudW1zXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNuVHlwZVR5cGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbnVtc18xLkFzblR5cGVUeXBlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblByb3BUeXBlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW51bXNfMS5Bc25Qcm9wVHlwZXM7IH0gfSk7XG52YXIgcGFyc2VyXzEgPSByZXF1aXJlKFwiLi9wYXJzZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25QYXJzZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhcnNlcl8xLkFzblBhcnNlcjsgfSB9KTtcbnZhciBzZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNuU2VyaWFsaXplclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VyaWFsaXplcl8xLkFzblNlcmlhbGl6ZXI7IH0gfSk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lcnJvcnNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb2JqZWN0c1wiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb252ZXJ0XCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFzblNlcmlhbGl6ZXIiLCJBc25QYXJzZXIiLCJBc25Qcm9wVHlwZXMiLCJBc25UeXBlVHlwZXMiLCJBc25TZXRUeXBlIiwiQXNuU2VxdWVuY2VUeXBlIiwiQXNuQ2hvaWNlVHlwZSIsIkFzblR5cGUiLCJBc25Qcm9wIiwidHNsaWJfMSIsInJlcXVpcmUiLCJfX2V4cG9ydFN0YXIiLCJkZWNvcmF0b3JzXzEiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZW51bXNfMSIsInBhcnNlcl8xIiwic2VyaWFsaXplcl8xIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnSerializer = exports.AsnParser = exports.AsnPropTypes = exports.AsnTypeTypes = exports.AsnSetType = exports.AsnSequenceType = exports.AsnChoiceType = exports.AsnType = exports.AsnProp = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\ntslib_1.__exportStar(__webpack_require__(/*! ./converters */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./types/index */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\"), exports);\nvar decorators_1 = __webpack_require__(/*! ./decorators */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/decorators.js\");\nObject.defineProperty(exports, \"AsnProp\", ({\n    enumerable: true,\n    get: function() {\n        return decorators_1.AsnProp;\n    }\n}));\nObject.defineProperty(exports, \"AsnType\", ({\n    enumerable: true,\n    get: function() {\n        return decorators_1.AsnType;\n    }\n}));\nObject.defineProperty(exports, \"AsnChoiceType\", ({\n    enumerable: true,\n    get: function() {\n        return decorators_1.AsnChoiceType;\n    }\n}));\nObject.defineProperty(exports, \"AsnSequenceType\", ({\n    enumerable: true,\n    get: function() {\n        return decorators_1.AsnSequenceType;\n    }\n}));\nObject.defineProperty(exports, \"AsnSetType\", ({\n    enumerable: true,\n    get: function() {\n        return decorators_1.AsnSetType;\n    }\n}));\nvar enums_1 = __webpack_require__(/*! ./enums */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nObject.defineProperty(exports, \"AsnTypeTypes\", ({\n    enumerable: true,\n    get: function() {\n        return enums_1.AsnTypeTypes;\n    }\n}));\nObject.defineProperty(exports, \"AsnPropTypes\", ({\n    enumerable: true,\n    get: function() {\n        return enums_1.AsnPropTypes;\n    }\n}));\nvar parser_1 = __webpack_require__(/*! ./parser */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/parser.js\");\nObject.defineProperty(exports, \"AsnParser\", ({\n    enumerable: true,\n    get: function() {\n        return parser_1.AsnParser;\n    }\n}));\nvar serializer_1 = __webpack_require__(/*! ./serializer */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\");\nObject.defineProperty(exports, \"AsnSerializer\", ({\n    enumerable: true,\n    get: function() {\n        return serializer_1.AsnSerializer;\n    }\n}));\ntslib_1.__exportStar(__webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./objects */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/objects.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./convert */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/convert.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQscUJBQXFCLEdBQUdBLGlCQUFpQixHQUFHQSxvQkFBb0IsR0FBR0Esb0JBQW9CLEdBQUdBLGtCQUFrQixHQUFHQSx1QkFBdUIsR0FBR0EscUJBQXFCLEdBQUdBLGVBQWUsR0FBR0EsZUFBZSxHQUFHLEtBQUs7QUFDMU0sTUFBTVcsVUFBVUMsbUJBQU9BLENBQUMsdURBQU87QUFDL0JELFFBQVFFLFlBQVksQ0FBQ0QsbUJBQU9BLENBQUMsd0ZBQWMsR0FBR1o7QUFDOUNXLFFBQVFFLFlBQVksQ0FBQ0QsbUJBQU9BLENBQUMsMEZBQWUsR0FBR1o7QUFDL0MsSUFBSWMsZUFBZUYsbUJBQU9BLENBQUMsd0ZBQWM7QUFDekNkLDJDQUEwQztJQUFFaUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsYUFBYUosT0FBTztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2xIWiwyQ0FBMEM7SUFBRWlCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9GLGFBQWFMLE9BQU87SUFBRTtBQUFFLENBQUMsRUFBQztBQUNsSFgsaURBQWdEO0lBQUVpQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPRixhQUFhTixhQUFhO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDOUhWLG1EQUFrRDtJQUFFaUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0YsYUFBYVAsZUFBZTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2xJVCw4Q0FBNkM7SUFBRWlCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9GLGFBQWFSLFVBQVU7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN4SCxJQUFJVyxVQUFVTCxtQkFBT0EsQ0FBQyw4RUFBUztBQUMvQmQsZ0RBQStDO0lBQUVpQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxRQUFRWixZQUFZO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDdkhQLGdEQUErQztJQUFFaUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0MsUUFBUWIsWUFBWTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3ZILElBQUljLFdBQVdOLG1CQUFPQSxDQUFDLGdGQUFVO0FBQ2pDZCw2Q0FBNEM7SUFBRWlCLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9FLFNBQVNmLFNBQVM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNsSCxJQUFJZ0IsZUFBZVAsbUJBQU9BLENBQUMsd0ZBQWM7QUFDekNkLGlEQUFnRDtJQUFFaUIsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0csYUFBYWpCLGFBQWE7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM5SFMsUUFBUUUsWUFBWSxDQUFDRCxtQkFBT0EsQ0FBQyxzRkFBVSxHQUFHWjtBQUMxQ1csUUFBUUUsWUFBWSxDQUFDRCxtQkFBT0EsQ0FBQyxrRkFBVyxHQUFHWjtBQUMzQ1csUUFBUUUsWUFBWSxDQUFDRCxtQkFBT0EsQ0FBQyxrRkFBVyxHQUFHWiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1ha2V0cGxhY2UtYWRtaW4vLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9pbmRleC5qcz83Mjk3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25TZXJpYWxpemVyID0gZXhwb3J0cy5Bc25QYXJzZXIgPSBleHBvcnRzLkFzblByb3BUeXBlcyA9IGV4cG9ydHMuQXNuVHlwZVR5cGVzID0gZXhwb3J0cy5Bc25TZXRUeXBlID0gZXhwb3J0cy5Bc25TZXF1ZW5jZVR5cGUgPSBleHBvcnRzLkFzbkNob2ljZVR5cGUgPSBleHBvcnRzLkFzblR5cGUgPSBleHBvcnRzLkFzblByb3AgPSB2b2lkIDA7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29udmVydGVyc1wiKSwgZXhwb3J0cyk7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlcy9pbmRleFwiKSwgZXhwb3J0cyk7XG52YXIgZGVjb3JhdG9yc18xID0gcmVxdWlyZShcIi4vZGVjb3JhdG9yc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblByb3BcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29yYXRvcnNfMS5Bc25Qcm9wOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNuVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb3JhdG9yc18xLkFzblR5cGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25DaG9pY2VUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvcmF0b3JzXzEuQXNuQ2hvaWNlVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblNlcXVlbmNlVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb3JhdG9yc18xLkFzblNlcXVlbmNlVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblNldFR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29yYXRvcnNfMS5Bc25TZXRUeXBlOyB9IH0pO1xudmFyIGVudW1zXzEgPSByZXF1aXJlKFwiLi9lbnVtc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblR5cGVUeXBlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZW51bXNfMS5Bc25UeXBlVHlwZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc25Qcm9wVHlwZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudW1zXzEuQXNuUHJvcFR5cGVzOyB9IH0pO1xudmFyIHBhcnNlcl8xID0gcmVxdWlyZShcIi4vcGFyc2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXNuUGFyc2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJzZXJfMS5Bc25QYXJzZXI7IH0gfSk7XG52YXIgc2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vc2VyaWFsaXplclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzblNlcmlhbGl6ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcmlhbGl6ZXJfMS5Bc25TZXJpYWxpemVyOyB9IH0pO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXJyb3JzXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29iamVjdHNcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29udmVydFwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBc25TZXJpYWxpemVyIiwiQXNuUGFyc2VyIiwiQXNuUHJvcFR5cGVzIiwiQXNuVHlwZVR5cGVzIiwiQXNuU2V0VHlwZSIsIkFzblNlcXVlbmNlVHlwZSIsIkFzbkNob2ljZVR5cGUiLCJBc25UeXBlIiwiQXNuUHJvcCIsInRzbGliXzEiLCJyZXF1aXJlIiwiX19leHBvcnRTdGFyIiwiZGVjb3JhdG9yc18xIiwiZW51bWVyYWJsZSIsImdldCIsImVudW1zXzEiLCJwYXJzZXJfMSIsInNlcmlhbGl6ZXJfMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/objects.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/objects.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnArray = void 0;\nclass AsnArray extends Array {\n    constructor(items = []){\n        if (typeof items === \"number\") {\n            super(items);\n        } else {\n            super();\n            for (const item of items){\n                this.push(item);\n            }\n        }\n    }\n}\nexports.AsnArray = AsnArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL29iamVjdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHLEtBQUs7QUFDeEIsTUFBTUUsaUJBQWlCQztJQUNuQkMsWUFBWUMsUUFBUSxFQUFFLENBQUU7UUFDcEIsSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDM0IsS0FBSyxDQUFDQTtRQUNWLE9BQ0s7WUFDRCxLQUFLO1lBQ0wsS0FBSyxNQUFNQyxRQUFRRCxNQUFPO2dCQUN0QixJQUFJLENBQUNFLElBQUksQ0FBQ0Q7WUFDZDtRQUNKO0lBQ0o7QUFDSjtBQUNBTixnQkFBZ0IsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYWtldHBsYWNlLWFkbWluLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvb2JqZWN0cy5qcz9lZmU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25BcnJheSA9IHZvaWQgMDtcbmNsYXNzIEFzbkFycmF5IGV4dGVuZHMgQXJyYXkge1xuICAgIGNvbnN0cnVjdG9yKGl0ZW1zID0gW10pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgc3VwZXIoaXRlbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQXNuQXJyYXkgPSBBc25BcnJheTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFzbkFycmF5IiwiQXJyYXkiLCJjb25zdHJ1Y3RvciIsIml0ZW1zIiwiaXRlbSIsInB1c2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/objects.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/objects.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/objects.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnArray = void 0;\nclass AsnArray extends Array {\n    constructor(items = []){\n        if (typeof items === \"number\") {\n            super(items);\n        } else {\n            super();\n            for (const item of items){\n                this.push(item);\n            }\n        }\n    }\n}\nexports.AsnArray = AsnArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9vYmplY3RzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQkFBZ0IsR0FBRyxLQUFLO0FBQ3hCLE1BQU1FLGlCQUFpQkM7SUFDbkJDLFlBQVlDLFFBQVEsRUFBRSxDQUFFO1FBQ3BCLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzNCLEtBQUssQ0FBQ0E7UUFDVixPQUNLO1lBQ0QsS0FBSztZQUNMLEtBQUssTUFBTUMsUUFBUUQsTUFBTztnQkFDdEIsSUFBSSxDQUFDRSxJQUFJLENBQUNEO1lBQ2Q7UUFDSjtJQUNKO0FBQ0o7QUFDQU4sZ0JBQWdCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktbWFrZXRwbGFjZS1hZG1pbi8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL29iamVjdHMuanM/ZWZlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNuQXJyYXkgPSB2b2lkIDA7XG5jbGFzcyBBc25BcnJheSBleHRlbmRzIEFycmF5IHtcbiAgICBjb25zdHJ1Y3RvcihpdGVtcyA9IFtdKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHN1cGVyKGl0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFzbkFycmF5ID0gQXNuQXJyYXk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBc25BcnJheSIsIkFycmF5IiwiY29uc3RydWN0b3IiLCJpdGVtcyIsIml0ZW0iLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/objects.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/parser.js":
/*!****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/parser.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnParser = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(action-browser)/./node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst converters = __webpack_require__(/*! ./converters */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nclass AsnParser {\n    static parse(data, target) {\n        const asn1Parsed = asn1js.fromBER(data);\n        if (asn1Parsed.result.error) {\n            throw new Error(asn1Parsed.result.error);\n        }\n        const res = this.fromASN(asn1Parsed.result, target);\n        return res;\n    }\n    static fromASN(asn1Schema, target) {\n        var _a;\n        try {\n            if ((0, helper_1.isConvertible)(target)) {\n                const value = new target();\n                return value.fromASN(asn1Schema);\n            }\n            const schema = storage_1.schemaStorage.get(target);\n            storage_1.schemaStorage.cache(target);\n            let targetSchema = schema.schema;\n            if (asn1Schema.constructor === asn1js.Constructed && schema.type !== enums_1.AsnTypeTypes.Choice) {\n                targetSchema = new asn1js.Constructed({\n                    idBlock: {\n                        tagClass: 3,\n                        tagNumber: asn1Schema.idBlock.tagNumber\n                    },\n                    value: schema.schema.valueBlock.value\n                });\n                for(const key in schema.items){\n                    delete asn1Schema[key];\n                }\n            }\n            const asn1ComparedSchema = asn1js.compareSchema({}, asn1Schema, targetSchema);\n            if (!asn1ComparedSchema.verified) {\n                throw new errors_1.AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);\n            }\n            const res = new target();\n            if ((0, helper_1.isTypeOfArray)(target)) {\n                if (!(\"value\" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value))) {\n                    throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);\n                }\n                const itemType = schema.itemType;\n                if (typeof itemType === \"number\") {\n                    const converter = converters.defaultConverter(itemType);\n                    if (!converter) {\n                        throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n                    }\n                    return target.from(asn1Schema.valueBlock.value, (element)=>converter.fromASN(element));\n                } else {\n                    return target.from(asn1Schema.valueBlock.value, (element)=>this.fromASN(element, itemType));\n                }\n            }\n            for(const key in schema.items){\n                const asn1SchemaValue = asn1ComparedSchema.result[key];\n                if (!asn1SchemaValue) {\n                    continue;\n                }\n                const schemaItem = schema.items[key];\n                const schemaItemType = schemaItem.type;\n                if (typeof schemaItemType === \"number\" || (0, helper_1.isConvertible)(schemaItemType)) {\n                    const converter = (_a = schemaItem.converter) !== null && _a !== void 0 ? _a : (0, helper_1.isConvertible)(schemaItemType) ? new schemaItemType() : null;\n                    if (!converter) {\n                        throw new Error(\"Converter is empty\");\n                    }\n                    if (schemaItem.repeated) {\n                        if (schemaItem.implicit) {\n                            const Container = schemaItem.repeated === \"sequence\" ? asn1js.Sequence : asn1js.Set;\n                            const newItem = new Container();\n                            newItem.valueBlock = asn1SchemaValue.valueBlock;\n                            const newItemAsn = asn1js.fromBER(newItem.toBER(false));\n                            if (newItemAsn.offset === -1) {\n                                throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);\n                            }\n                            if (!(\"value\" in newItemAsn.result.valueBlock && Array.isArray(newItemAsn.result.valueBlock.value))) {\n                                throw new Error(\"Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.\");\n                            }\n                            const value = newItemAsn.result.valueBlock.value;\n                            res[key] = Array.from(value, (element)=>converter.fromASN(element));\n                        } else {\n                            res[key] = Array.from(asn1SchemaValue, (element)=>converter.fromASN(element));\n                        }\n                    } else {\n                        let value = asn1SchemaValue;\n                        if (schemaItem.implicit) {\n                            let newItem;\n                            if ((0, helper_1.isConvertible)(schemaItemType)) {\n                                newItem = new schemaItemType().toSchema(\"\");\n                            } else {\n                                const Asn1TypeName = enums_1.AsnPropTypes[schemaItemType];\n                                const Asn1Type = asn1js[Asn1TypeName];\n                                if (!Asn1Type) {\n                                    throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);\n                                }\n                                newItem = new Asn1Type();\n                            }\n                            newItem.valueBlock = value.valueBlock;\n                            value = asn1js.fromBER(newItem.toBER(false)).result;\n                        }\n                        res[key] = converter.fromASN(value);\n                    }\n                } else {\n                    if (schemaItem.repeated) {\n                        if (!Array.isArray(asn1SchemaValue)) {\n                            throw new Error(\"Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.\");\n                        }\n                        res[key] = Array.from(asn1SchemaValue, (element)=>this.fromASN(element, schemaItemType));\n                    } else {\n                        res[key] = this.fromASN(asn1SchemaValue, schemaItemType);\n                    }\n                }\n            }\n            return res;\n        } catch (error) {\n            if (error instanceof errors_1.AsnSchemaValidationError) {\n                error.schemas.push(target.name);\n            }\n            throw error;\n        }\n    }\n}\nexports.AsnParser = AsnParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3BhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsaUJBQWlCLEdBQUcsS0FBSztBQUN6QixNQUFNRyxTQUFTQyxtQkFBT0EsQ0FBQyxxRUFBUTtBQUMvQixNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyx5RkFBUztBQUNqQyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyxtR0FBYztBQUN6QyxNQUFNRyxXQUFXSCxtQkFBT0EsQ0FBQyxpR0FBVTtBQUNuQyxNQUFNSSxXQUFXSixtQkFBT0EsQ0FBQywyRkFBVTtBQUNuQyxNQUFNSyxZQUFZTCxtQkFBT0EsQ0FBQyw2RkFBVztBQUNyQyxNQUFNRjtJQUNGLE9BQU9RLE1BQU1DLElBQUksRUFBRUMsTUFBTSxFQUFFO1FBQ3ZCLE1BQU1DLGFBQWFWLE9BQU9XLE9BQU8sQ0FBQ0g7UUFDbEMsSUFBSUUsV0FBV0UsTUFBTSxDQUFDQyxLQUFLLEVBQUU7WUFDekIsTUFBTSxJQUFJQyxNQUFNSixXQUFXRSxNQUFNLENBQUNDLEtBQUs7UUFDM0M7UUFDQSxNQUFNRSxNQUFNLElBQUksQ0FBQ0MsT0FBTyxDQUFDTixXQUFXRSxNQUFNLEVBQUVIO1FBQzVDLE9BQU9NO0lBQ1g7SUFDQSxPQUFPQyxRQUFRQyxVQUFVLEVBQUVSLE1BQU0sRUFBRTtRQUMvQixJQUFJUztRQUNKLElBQUk7WUFDQSxJQUFJLENBQUMsR0FBR2IsU0FBU2MsYUFBYSxFQUFFVixTQUFTO2dCQUNyQyxNQUFNWCxRQUFRLElBQUlXO2dCQUNsQixPQUFPWCxNQUFNa0IsT0FBTyxDQUFDQztZQUN6QjtZQUNBLE1BQU1HLFNBQVNkLFVBQVVlLGFBQWEsQ0FBQ0MsR0FBRyxDQUFDYjtZQUMzQ0gsVUFBVWUsYUFBYSxDQUFDRSxLQUFLLENBQUNkO1lBQzlCLElBQUllLGVBQWVK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RWdELGFBQWEsMEJBQTBCLENBQUM7Z0NBQzNFO2dDQUNBTCxVQUFVLElBQUlPOzRCQUNsQjs0QkFDQVAsUUFBUXhCLFVBQVUsR0FBR25DLE1BQU1tQyxVQUFVOzRCQUNyQ25DLFFBQVFFLE9BQU9XLE9BQU8sQ0FBQzhDLFFBQVFFLEtBQUssQ0FBQyxRQUFRL0MsTUFBTTt3QkFDdkQ7d0JBQ0FHLEdBQUcsQ0FBQ21CLElBQUksR0FBR1csVUFBVTdCLE9BQU8sQ0FBQ2xCO29CQUNqQztnQkFDSixPQUNLO29CQUNELElBQUlvRCxXQUFXRSxRQUFRLEVBQUU7d0JBQ3JCLElBQUksQ0FBQ1YsTUFBTUMsT0FBTyxDQUFDTSxrQkFBa0I7NEJBQ2pDLE1BQU0sSUFBSW5DLE1BQU07d0JBQ3BCO3dCQUNBQyxHQUFHLENBQUNtQixJQUFJLEdBQUdRLE1BQU1LLElBQUksQ0FBQ0UsaUJBQWlCLENBQUNELFVBQVksSUFBSSxDQUFDaEMsT0FBTyxDQUFDZ0MsU0FBU0c7b0JBQzlFLE9BQ0s7d0JBQ0RwQyxHQUFHLENBQUNtQixJQUFJLEdBQUcsSUFBSSxDQUFDbEIsT0FBTyxDQUFDaUMsaUJBQWlCRTtvQkFDN0M7Z0JBQ0o7WUFDSjtZQUNBLE9BQU9wQztRQUNYLEVBQ0EsT0FBT0YsT0FBTztZQUNWLElBQUlBLGlCQUFpQlQsU0FBU21DLHdCQUF3QixFQUFFO2dCQUNwRDFCLE1BQU1vRCxPQUFPLENBQUNDLElBQUksQ0FBQ3pELE9BQU8rQixJQUFJO1lBQ2xDO1lBQ0EsTUFBTTNCO1FBQ1Y7SUFDSjtBQUNKO0FBQ0FoQixpQkFBaUIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYWtldHBsYWNlLWFkbWluLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvcGFyc2VyLmpzP2FjZTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzblBhcnNlciA9IHZvaWQgMDtcbmNvbnN0IGFzbjFqcyA9IHJlcXVpcmUoXCJhc24xanNcIik7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG5jb25zdCBjb252ZXJ0ZXJzID0gcmVxdWlyZShcIi4vY29udmVydGVyc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgaGVscGVyXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJcIik7XG5jb25zdCBzdG9yYWdlXzEgPSByZXF1aXJlKFwiLi9zdG9yYWdlXCIpO1xuY2xhc3MgQXNuUGFyc2VyIHtcbiAgICBzdGF0aWMgcGFyc2UoZGF0YSwgdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IGFzbjFQYXJzZWQgPSBhc24xanMuZnJvbUJFUihkYXRhKTtcbiAgICAgICAgaWYgKGFzbjFQYXJzZWQucmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYXNuMVBhcnNlZC5yZXN1bHQuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuZnJvbUFTTihhc24xUGFyc2VkLnJlc3VsdCwgdGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgc3RhdGljIGZyb21BU04oYXNuMVNjaGVtYSwgdGFyZ2V0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICgoMCwgaGVscGVyXzEuaXNDb252ZXJ0aWJsZSkodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5mcm9tQVNOKGFzbjFTY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5jYWNoZSh0YXJnZXQpO1xuICAgICAgICAgICAgbGV0IHRhcmdldFNjaGVtYSA9IHNjaGVtYS5zY2hlbWE7XG4gICAgICAgICAgICBpZiAoYXNuMVNjaGVtYS5jb25zdHJ1Y3RvciA9PT0gYXNuMWpzLkNvbnN0cnVjdGVkICYmIHNjaGVtYS50eXBlICE9PSBlbnVtc18xLkFzblR5cGVUeXBlcy5DaG9pY2UpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTY2hlbWEgPSBuZXcgYXNuMWpzLkNvbnN0cnVjdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgaWRCbG9jazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnQ2xhc3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXI6IGFzbjFTY2hlbWEuaWRCbG9jay50YWdOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzY2hlbWEuc2NoZW1hLnZhbHVlQmxvY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhc24xU2NoZW1hW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXNuMUNvbXBhcmVkU2NoZW1hID0gYXNuMWpzLmNvbXBhcmVTY2hlbWEoe30sIGFzbjFTY2hlbWEsIHRhcmdldFNjaGVtYSk7XG4gICAgICAgICAgICBpZiAoIWFzbjFDb21wYXJlZFNjaGVtYS52ZXJpZmllZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bc25TY2hlbWFWYWxpZGF0aW9uRXJyb3IoYERhdGEgZG9lcyBub3QgbWF0Y2ggdG8gJHt0YXJnZXQubmFtZX0gQVNOMSBzY2hlbWEuICR7YXNuMUNvbXBhcmVkU2NoZW1hLnJlc3VsdC5lcnJvcn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyB0YXJnZXQoKTtcbiAgICAgICAgICAgIGlmICgoMCwgaGVscGVyXzEuaXNUeXBlT2ZBcnJheSkodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGlmICghKFwidmFsdWVcIiBpbiBhc24xU2NoZW1hLnZhbHVlQmxvY2sgJiYgQXJyYXkuaXNBcnJheShhc24xU2NoZW1hLnZhbHVlQmxvY2sudmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgaXRlbXMgZnJvbSB0aGUgQVNOLjEgcGFyc2VkIHZhbHVlLiBBU04uMSBvYmplY3QgaXMgbm90IGNvbnN0cnVjdGVkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtVHlwZSA9IHNjaGVtYS5pdGVtVHlwZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW1UeXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IGNvbnZlcnRlcnMuZGVmYXVsdENvbnZlcnRlcihpdGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgZGVmYXVsdCBjb252ZXJ0ZXIgZm9yIGFycmF5IGl0ZW0gb2YgJHt0YXJnZXQubmFtZX0gQVNOMSBzY2hlbWFgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmZyb20oYXNuMVNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlLCAoZWxlbWVudCkgPT4gY29udmVydGVyLmZyb21BU04oZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5mcm9tKGFzbjFTY2hlbWEudmFsdWVCbG9jay52YWx1ZSwgKGVsZW1lbnQpID0+IHRoaXMuZnJvbUFTTihlbGVtZW50LCBpdGVtVHlwZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzbjFTY2hlbWFWYWx1ZSA9IGFzbjFDb21wYXJlZFNjaGVtYS5yZXN1bHRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoIWFzbjFTY2hlbWFWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hSXRlbSA9IHNjaGVtYS5pdGVtc1trZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYUl0ZW1UeXBlID0gc2NoZW1hSXRlbS50eXBlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hSXRlbVR5cGUgPT09IFwibnVtYmVyXCIgfHwgKDAsIGhlbHBlcl8xLmlzQ29udmVydGlibGUpKHNjaGVtYUl0ZW1UeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSAoX2EgPSBzY2hlbWFJdGVtLmNvbnZlcnRlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKCgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShzY2hlbWFJdGVtVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IHNjaGVtYUl0ZW1UeXBlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb252ZXJ0ZXIgaXMgZW1wdHlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYUl0ZW0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFJdGVtLmltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgQ29udGFpbmVyID0gc2NoZW1hSXRlbS5yZXBlYXRlZCA9PT0gXCJzZXF1ZW5jZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYXNuMWpzLlNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYXNuMWpzLlNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdJdGVtID0gbmV3IENvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0l0ZW0udmFsdWVCbG9jayA9IGFzbjFTY2hlbWFWYWx1ZS52YWx1ZUJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW1Bc24gPSBhc24xanMuZnJvbUJFUihuZXdJdGVtLnRvQkVSKGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0l0ZW1Bc24ub2Zmc2V0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSB0aGUgY2hpbGQgaXRlbS4gJHtuZXdJdGVtQXNuLnJlc3VsdC5lcnJvcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoXCJ2YWx1ZVwiIGluIG5ld0l0ZW1Bc24ucmVzdWx0LnZhbHVlQmxvY2sgJiYgQXJyYXkuaXNBcnJheShuZXdJdGVtQXNuLnJlc3VsdC52YWx1ZUJsb2NrLnZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBpdGVtcyBmcm9tIHRoZSBBU04uMSBwYXJzZWQgdmFsdWUuIEFTTi4xIG9iamVjdCBpcyBub3QgY29uc3RydWN0ZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5ld0l0ZW1Bc24ucmVzdWx0LnZhbHVlQmxvY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBBcnJheS5mcm9tKHZhbHVlLCAoZWxlbWVudCkgPT4gY29udmVydGVyLmZyb21BU04oZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBBcnJheS5mcm9tKGFzbjFTY2hlbWFWYWx1ZSwgKGVsZW1lbnQpID0+IGNvbnZlcnRlci5mcm9tQVNOKGVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGFzbjFTY2hlbWFWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFJdGVtLmltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0l0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShzY2hlbWFJdGVtVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SXRlbSA9IG5ldyBzY2hlbWFJdGVtVHlwZSgpLnRvU2NoZW1hKFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgQXNuMVR5cGVOYW1lID0gZW51bXNfMS5Bc25Qcm9wVHlwZXNbc2NoZW1hSXRlbVR5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBBc24xVHlwZSA9IGFzbjFqc1tBc24xVHlwZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUFzbjFUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgJyR7QXNuMVR5cGVOYW1lfScgY2xhc3MgZnJvbSBhc24xanMgbW9kdWxlYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SXRlbSA9IG5ldyBBc24xVHlwZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJdGVtLnZhbHVlQmxvY2sgPSB2YWx1ZS52YWx1ZUJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXNuMWpzLmZyb21CRVIobmV3SXRlbS50b0JFUihmYWxzZSkpLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gY29udmVydGVyLmZyb21BU04odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hSXRlbS5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFzbjFTY2hlbWFWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGxpc3Qgb2YgaXRlbXMgZnJvbSB0aGUgQVNOLjEgcGFyc2VkIHZhbHVlLiBBU04uMSB2YWx1ZSBzaG91bGQgYmUgaXRlcmFibGUuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSBBcnJheS5mcm9tKGFzbjFTY2hlbWFWYWx1ZSwgKGVsZW1lbnQpID0+IHRoaXMuZnJvbUFTTihlbGVtZW50LCBzY2hlbWFJdGVtVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSB0aGlzLmZyb21BU04oYXNuMVNjaGVtYVZhbHVlLCBzY2hlbWFJdGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgZXJyb3JzXzEuQXNuU2NoZW1hVmFsaWRhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3Iuc2NoZW1hcy5wdXNoKHRhcmdldC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Bc25QYXJzZXIgPSBBc25QYXJzZXI7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBc25QYXJzZXIiLCJhc24xanMiLCJyZXF1aXJlIiwiZW51bXNfMSIsImNvbnZlcnRlcnMiLCJlcnJvcnNfMSIsImhlbHBlcl8xIiwic3RvcmFnZV8xIiwicGFyc2UiLCJkYXRhIiwidGFyZ2V0IiwiYXNuMVBhcnNlZCIsImZyb21CRVIiLCJyZXN1bHQiLCJlcnJvciIsIkVycm9yIiwicmVzIiwiZnJvbUFTTiIsImFzbjFTY2hlbWEiLCJfYSIsImlzQ29udmVydGlibGUiLCJzY2hlbWEiLCJzY2hlbWFTdG9yYWdlIiwiZ2V0IiwiY2FjaGUiLCJ0YXJnZXRTY2hlbWEiLCJjb25zdHJ1Y3RvciIsIkNvbnN0cnVjdGVkIiwidHlwZSIsIkFzblR5cGVUeXBlcyIsIkNob2ljZSIsImlkQmxvY2siLCJ0YWdDbGFzcyIsInRhZ051bWJlciIsInZhbHVlQmxvY2siLCJrZXkiLCJpdGVtcyIsImFzbjFDb21wYXJlZFNjaGVtYSIsImNvbXBhcmVTY2hlbWEiLCJ2ZXJpZmllZCIsIkFzblNjaGVtYVZhbGlkYXRpb25FcnJvciIsIm5hbWUiLCJpc1R5cGVPZkFycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiaXRlbVR5cGUiLCJjb252ZXJ0ZXIiLCJkZWZhdWx0Q29udmVydGVyIiwiZnJvbSIsImVsZW1lbnQiLCJhc24xU2NoZW1hVmFsdWUiLCJzY2hlbWFJdGVtIiwic2NoZW1hSXRlbVR5cGUiLCJyZXBlYXRlZCIsImltcGxpY2l0IiwiQ29udGFpbmVyIiwiU2VxdWVuY2UiLCJTZXQiLCJuZXdJdGVtIiwibmV3SXRlbUFzbiIsInRvQkVSIiwib2Zmc2V0IiwidG9TY2hlbWEiLCJBc24xVHlwZU5hbWUiLCJBc25Qcm9wVHlwZXMiLCJBc24xVHlwZSIsInNjaGVtYXMiLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/parser.js":
/*!****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/parser.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnParser = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(rsc)/./node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst converters = __webpack_require__(/*! ./converters */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/errors/index.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nclass AsnParser {\n    static parse(data, target) {\n        const asn1Parsed = asn1js.fromBER(data);\n        if (asn1Parsed.result.error) {\n            throw new Error(asn1Parsed.result.error);\n        }\n        const res = this.fromASN(asn1Parsed.result, target);\n        return res;\n    }\n    static fromASN(asn1Schema, target) {\n        var _a;\n        try {\n            if ((0, helper_1.isConvertible)(target)) {\n                const value = new target();\n                return value.fromASN(asn1Schema);\n            }\n            const schema = storage_1.schemaStorage.get(target);\n            storage_1.schemaStorage.cache(target);\n            let targetSchema = schema.schema;\n            if (asn1Schema.constructor === asn1js.Constructed && schema.type !== enums_1.AsnTypeTypes.Choice) {\n                targetSchema = new asn1js.Constructed({\n                    idBlock: {\n                        tagClass: 3,\n                        tagNumber: asn1Schema.idBlock.tagNumber\n                    },\n                    value: schema.schema.valueBlock.value\n                });\n                for(const key in schema.items){\n                    delete asn1Schema[key];\n                }\n            }\n            const asn1ComparedSchema = asn1js.compareSchema({}, asn1Schema, targetSchema);\n            if (!asn1ComparedSchema.verified) {\n                throw new errors_1.AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);\n            }\n            const res = new target();\n            if ((0, helper_1.isTypeOfArray)(target)) {\n                if (!(\"value\" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value))) {\n                    throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);\n                }\n                const itemType = schema.itemType;\n                if (typeof itemType === \"number\") {\n                    const converter = converters.defaultConverter(itemType);\n                    if (!converter) {\n                        throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n                    }\n                    return target.from(asn1Schema.valueBlock.value, (element)=>converter.fromASN(element));\n                } else {\n                    return target.from(asn1Schema.valueBlock.value, (element)=>this.fromASN(element, itemType));\n                }\n            }\n            for(const key in schema.items){\n                const asn1SchemaValue = asn1ComparedSchema.result[key];\n                if (!asn1SchemaValue) {\n                    continue;\n                }\n                const schemaItem = schema.items[key];\n                const schemaItemType = schemaItem.type;\n                if (typeof schemaItemType === \"number\" || (0, helper_1.isConvertible)(schemaItemType)) {\n                    const converter = (_a = schemaItem.converter) !== null && _a !== void 0 ? _a : (0, helper_1.isConvertible)(schemaItemType) ? new schemaItemType() : null;\n                    if (!converter) {\n                        throw new Error(\"Converter is empty\");\n                    }\n                    if (schemaItem.repeated) {\n                        if (schemaItem.implicit) {\n                            const Container = schemaItem.repeated === \"sequence\" ? asn1js.Sequence : asn1js.Set;\n                            const newItem = new Container();\n                            newItem.valueBlock = asn1SchemaValue.valueBlock;\n                            const newItemAsn = asn1js.fromBER(newItem.toBER(false));\n                            if (newItemAsn.offset === -1) {\n                                throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);\n                            }\n                            if (!(\"value\" in newItemAsn.result.valueBlock && Array.isArray(newItemAsn.result.valueBlock.value))) {\n                                throw new Error(\"Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.\");\n                            }\n                            const value = newItemAsn.result.valueBlock.value;\n                            res[key] = Array.from(value, (element)=>converter.fromASN(element));\n                        } else {\n                            res[key] = Array.from(asn1SchemaValue, (element)=>converter.fromASN(element));\n                        }\n                    } else {\n                        let value = asn1SchemaValue;\n                        if (schemaItem.implicit) {\n                            let newItem;\n                            if ((0, helper_1.isConvertible)(schemaItemType)) {\n                                newItem = new schemaItemType().toSchema(\"\");\n                            } else {\n                                const Asn1TypeName = enums_1.AsnPropTypes[schemaItemType];\n                                const Asn1Type = asn1js[Asn1TypeName];\n                                if (!Asn1Type) {\n                                    throw new Error(`Cannot get '${Asn1TypeName}' class from asn1js module`);\n                                }\n                                newItem = new Asn1Type();\n                            }\n                            newItem.valueBlock = value.valueBlock;\n                            value = asn1js.fromBER(newItem.toBER(false)).result;\n                        }\n                        res[key] = converter.fromASN(value);\n                    }\n                } else {\n                    if (schemaItem.repeated) {\n                        if (!Array.isArray(asn1SchemaValue)) {\n                            throw new Error(\"Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.\");\n                        }\n                        res[key] = Array.from(asn1SchemaValue, (element)=>this.fromASN(element, schemaItemType));\n                    } else {\n                        res[key] = this.fromASN(asn1SchemaValue, schemaItemType);\n                    }\n                }\n            }\n            return res;\n        } catch (error) {\n            if (error instanceof errors_1.AsnSchemaValidationError) {\n                error.schemas.push(target.name);\n            }\n            throw error;\n        }\n    }\n}\nexports.AsnParser = AsnParser;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHLEtBQUs7QUFDekIsTUFBTUcsU0FBU0MsbUJBQU9BLENBQUMsMERBQVE7QUFDL0IsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsOEVBQVM7QUFDakMsTUFBTUUsYUFBYUYsbUJBQU9BLENBQUMsd0ZBQWM7QUFDekMsTUFBTUcsV0FBV0gsbUJBQU9BLENBQUMsc0ZBQVU7QUFDbkMsTUFBTUksV0FBV0osbUJBQU9BLENBQUMsZ0ZBQVU7QUFDbkMsTUFBTUssWUFBWUwsbUJBQU9BLENBQUMsa0ZBQVc7QUFDckMsTUFBTUY7SUFDRixPQUFPUSxNQUFNQyxJQUFJLEVBQUVDLE1BQU0sRUFBRTtRQUN2QixNQUFNQyxhQUFhVixPQUFPVyxPQUFPLENBQUNIO1FBQ2xDLElBQUlFLFdBQVdFLE1BQU0sQ0FBQ0MsS0FBSyxFQUFFO1lBQ3pCLE1BQU0sSUFBSUMsTUFBTUosV0FBV0UsTUFBTSxDQUFDQyxLQUFLO1FBQzNDO1FBQ0EsTUFBTUUsTUFBTSxJQUFJLENBQUNDLE9BQU8sQ0FBQ04sV0FBV0UsTUFBTSxFQUFFSDtRQUM1QyxPQUFPTTtJQUNYO0lBQ0EsT0FBT0MsUUFBUUMsVUFBVSxFQUFFUixNQUFNLEVBQUU7UUFDL0IsSUFBSVM7UUFDSixJQUFJO1lBQ0EsSUFBSSxDQUFDLEdBQUdiLFNBQVNjLGFBQWEsRUFBRVYsU0FBUztnQkFDckMsTUFBTVgsUUFBUSxJQUFJVztnQkFDbEIsT0FBT1gsTUFBTWtCLE9BQU8sQ0FBQ0M7WUFDekI7WUFDQSxNQUFNRyxTQUFTZCxVQUFVZSxhQUFhLENBQUNDLEdBQUcsQ0FBQ2I7WUFDM0NILFVBQVVlLGFBQWEsQ0FBQ0UsS0FBSyxDQUFDZDtZQUM5QixJQUFJZSxlQUFlSixPQUFPQSxNQUFN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QUEwQixDQUFDO2dDQUMzRTtnQ0FDQUwsVUFBVSxJQUFJTzs0QkFDbEI7NEJBQ0FQLFFBQVF4QixVQUFVLEdBQUduQyxNQUFNbUMsVUFBVTs0QkFDckNuQyxRQUFRRSxPQUFPVyxPQUFPLENBQUM4QyxRQUFRRSxLQUFLLENBQUMsUUFBUS9DLE1BQU07d0JBQ3ZEO3dCQUNBRyxHQUFHLENBQUNtQixJQUFJLEdBQUdXLFVBQVU3QixPQUFPLENBQUNsQjtvQkFDakM7Z0JBQ0osT0FDSztvQkFDRCxJQUFJb0QsV0FBV0UsUUFBUSxFQUFFO3dCQUNyQixJQUFJLENBQUNWLE1BQU1DLE9BQU8sQ0FBQ00sa0JBQWtCOzRCQUNqQyxNQUFNLElBQUluQyxNQUFNO3dCQUNwQjt3QkFDQUMsR0FBRyxDQUFDbUIsSUFBSSxHQUFHUSxNQUFNSyxJQUFJLENBQUNFLGlCQUFpQixDQUFDRCxVQUFZLElBQUksQ0FBQ2hDLE9BQU8sQ0FBQ2dDLFNBQVNHO29CQUM5RSxPQUNLO3dCQUNEcEMsR0FBRyxDQUFDbUIsSUFBSSxHQUFHLElBQUksQ0FBQ2xCLE9BQU8sQ0FBQ2lDLGlCQUFpQkU7b0JBQzdDO2dCQUNKO1lBQ0o7WUFDQSxPQUFPcEM7UUFDWCxFQUNBLE9BQU9GLE9BQU87WUFDVixJQUFJQSxpQkFBaUJULFNBQVNtQyx3QkFBd0IsRUFBRTtnQkFDcEQxQixNQUFNb0QsT0FBTyxDQUFDQyxJQUFJLENBQUN6RCxPQUFPK0IsSUFBSTtZQUNsQztZQUNBLE1BQU0zQjtRQUNWO0lBQ0o7QUFDSjtBQUNBaEIsaUJBQWlCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktbWFrZXRwbGFjZS1hZG1pbi8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3BhcnNlci5qcz9hY2UxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25QYXJzZXIgPSB2b2lkIDA7XG5jb25zdCBhc24xanMgPSByZXF1aXJlKFwiYXNuMWpzXCIpO1xuY29uc3QgZW51bXNfMSA9IHJlcXVpcmUoXCIuL2VudW1zXCIpO1xuY29uc3QgY29udmVydGVycyA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IGhlbHBlcl8xID0gcmVxdWlyZShcIi4vaGVscGVyXCIpO1xuY29uc3Qgc3RvcmFnZV8xID0gcmVxdWlyZShcIi4vc3RvcmFnZVwiKTtcbmNsYXNzIEFzblBhcnNlciB7XG4gICAgc3RhdGljIHBhcnNlKGRhdGEsIHRhcmdldCkge1xuICAgICAgICBjb25zdCBhc24xUGFyc2VkID0gYXNuMWpzLmZyb21CRVIoZGF0YSk7XG4gICAgICAgIGlmIChhc24xUGFyc2VkLnJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGFzbjFQYXJzZWQucmVzdWx0LmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSB0aGlzLmZyb21BU04oYXNuMVBhcnNlZC5yZXN1bHQsIHRhcmdldCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQVNOKGFzbjFTY2hlbWEsIHRhcmdldCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoKDAsIGhlbHBlcl8xLmlzQ29udmVydGlibGUpKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5ldyB0YXJnZXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuZnJvbUFTTihhc24xU2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuY2FjaGUodGFyZ2V0KTtcbiAgICAgICAgICAgIGxldCB0YXJnZXRTY2hlbWEgPSBzY2hlbWEuc2NoZW1hO1xuICAgICAgICAgICAgaWYgKGFzbjFTY2hlbWEuY29uc3RydWN0b3IgPT09IGFzbjFqcy5Db25zdHJ1Y3RlZCAmJiBzY2hlbWEudHlwZSAhPT0gZW51bXNfMS5Bc25UeXBlVHlwZXMuQ2hvaWNlKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U2NoZW1hID0gbmV3IGFzbjFqcy5Db25zdHJ1Y3RlZCh7XG4gICAgICAgICAgICAgICAgICAgIGlkQmxvY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0NsYXNzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnTnVtYmVyOiBhc24xU2NoZW1hLmlkQmxvY2sudGFnTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc2NoZW1hLnNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXNuMVNjaGVtYVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFzbjFDb21wYXJlZFNjaGVtYSA9IGFzbjFqcy5jb21wYXJlU2NoZW1hKHt9LCBhc24xU2NoZW1hLCB0YXJnZXRTY2hlbWEpO1xuICAgICAgICAgICAgaWYgKCFhc24xQ29tcGFyZWRTY2hlbWEudmVyaWZpZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXNuU2NoZW1hVmFsaWRhdGlvbkVycm9yKGBEYXRhIGRvZXMgbm90IG1hdGNoIHRvICR7dGFyZ2V0Lm5hbWV9IEFTTjEgc2NoZW1hLiAke2FzbjFDb21wYXJlZFNjaGVtYS5yZXN1bHQuZXJyb3J9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgdGFyZ2V0KCk7XG4gICAgICAgICAgICBpZiAoKDAsIGhlbHBlcl8xLmlzVHlwZU9mQXJyYXkpKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShcInZhbHVlXCIgaW4gYXNuMVNjaGVtYS52YWx1ZUJsb2NrICYmIEFycmF5LmlzQXJyYXkoYXNuMVNjaGVtYS52YWx1ZUJsb2NrLnZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2V0IGl0ZW1zIGZyb20gdGhlIEFTTi4xIHBhcnNlZCB2YWx1ZS4gQVNOLjEgb2JqZWN0IGlzIG5vdCBjb25zdHJ1Y3RlZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbVR5cGUgPSBzY2hlbWEuaXRlbVR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtVHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSBjb252ZXJ0ZXJzLmRlZmF1bHRDb252ZXJ0ZXIoaXRlbVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnZlcnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2V0IGRlZmF1bHQgY29udmVydGVyIGZvciBhcnJheSBpdGVtIG9mICR7dGFyZ2V0Lm5hbWV9IEFTTjEgc2NoZW1hYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5mcm9tKGFzbjFTY2hlbWEudmFsdWVCbG9jay52YWx1ZSwgKGVsZW1lbnQpID0+IGNvbnZlcnRlci5mcm9tQVNOKGVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZnJvbShhc24xU2NoZW1hLnZhbHVlQmxvY2sudmFsdWUsIChlbGVtZW50KSA9PiB0aGlzLmZyb21BU04oZWxlbWVudCwgaXRlbVR5cGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhc24xU2NoZW1hVmFsdWUgPSBhc24xQ29tcGFyZWRTY2hlbWEucmVzdWx0W2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCFhc24xU2NoZW1hVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYUl0ZW0gPSBzY2hlbWEuaXRlbXNba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFJdGVtVHlwZSA9IHNjaGVtYUl0ZW0udHlwZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYUl0ZW1UeXBlID09PSBcIm51bWJlclwiIHx8ICgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShzY2hlbWFJdGVtVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udmVydGVyID0gKF9hID0gc2NoZW1hSXRlbS5jb252ZXJ0ZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICgoMCwgaGVscGVyXzEuaXNDb252ZXJ0aWJsZSkoc2NoZW1hSXRlbVR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBzY2hlbWFJdGVtVHlwZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnZlcnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udmVydGVyIGlzIGVtcHR5XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFJdGVtLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hSXRlbS5pbXBsaWNpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IENvbnRhaW5lciA9IHNjaGVtYUl0ZW0ucmVwZWF0ZWQgPT09IFwic2VxdWVuY2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFzbjFqcy5TZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFzbjFqcy5TZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbSA9IG5ldyBDb250YWluZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJdGVtLnZhbHVlQmxvY2sgPSBhc24xU2NoZW1hVmFsdWUudmFsdWVCbG9jaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdJdGVtQXNuID0gYXNuMWpzLmZyb21CRVIobmV3SXRlbS50b0JFUihmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdJdGVtQXNuLm9mZnNldCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgdGhlIGNoaWxkIGl0ZW0uICR7bmV3SXRlbUFzbi5yZXN1bHQuZXJyb3J9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKFwidmFsdWVcIiBpbiBuZXdJdGVtQXNuLnJlc3VsdC52YWx1ZUJsb2NrICYmIEFycmF5LmlzQXJyYXkobmV3SXRlbUFzbi5yZXN1bHQudmFsdWVCbG9jay52YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgaXRlbXMgZnJvbSB0aGUgQVNOLjEgcGFyc2VkIHZhbHVlLiBBU04uMSBvYmplY3QgaXMgbm90IGNvbnN0cnVjdGVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBuZXdJdGVtQXNuLnJlc3VsdC52YWx1ZUJsb2NrLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gQXJyYXkuZnJvbSh2YWx1ZSwgKGVsZW1lbnQpID0+IGNvbnZlcnRlci5mcm9tQVNOKGVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gQXJyYXkuZnJvbShhc24xU2NoZW1hVmFsdWUsIChlbGVtZW50KSA9PiBjb252ZXJ0ZXIuZnJvbUFTTihlbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBhc24xU2NoZW1hVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NoZW1hSXRlbS5pbXBsaWNpdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdJdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgaGVscGVyXzEuaXNDb252ZXJ0aWJsZSkoc2NoZW1hSXRlbVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0l0ZW0gPSBuZXcgc2NoZW1hSXRlbVR5cGUoKS50b1NjaGVtYShcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IEFzbjFUeXBlTmFtZSA9IGVudW1zXzEuQXNuUHJvcFR5cGVzW3NjaGVtYUl0ZW1UeXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgQXNuMVR5cGUgPSBhc24xanNbQXNuMVR5cGVOYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFBc24xVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2V0ICcke0FzbjFUeXBlTmFtZX0nIGNsYXNzIGZyb20gYXNuMWpzIG1vZHVsZWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0l0ZW0gPSBuZXcgQXNuMVR5cGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SXRlbS52YWx1ZUJsb2NrID0gdmFsdWUudmFsdWVCbG9jaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFzbjFqcy5mcm9tQkVSKG5ld0l0ZW0udG9CRVIoZmFsc2UpKS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IGNvbnZlcnRlci5mcm9tQVNOKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYUl0ZW0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhc24xU2NoZW1hVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBsaXN0IG9mIGl0ZW1zIGZyb20gdGhlIEFTTi4xIHBhcnNlZCB2YWx1ZS4gQVNOLjEgdmFsdWUgc2hvdWxkIGJlIGl0ZXJhYmxlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gQXJyYXkuZnJvbShhc24xU2NoZW1hVmFsdWUsIChlbGVtZW50KSA9PiB0aGlzLmZyb21BU04oZWxlbWVudCwgc2NoZW1hSXRlbVR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1trZXldID0gdGhpcy5mcm9tQVNOKGFzbjFTY2hlbWFWYWx1ZSwgc2NoZW1hSXRlbVR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGVycm9yc18xLkFzblNjaGVtYVZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yLnNjaGVtYXMucHVzaCh0YXJnZXQubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQXNuUGFyc2VyID0gQXNuUGFyc2VyO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQXNuUGFyc2VyIiwiYXNuMWpzIiwicmVxdWlyZSIsImVudW1zXzEiLCJjb252ZXJ0ZXJzIiwiZXJyb3JzXzEiLCJoZWxwZXJfMSIsInN0b3JhZ2VfMSIsInBhcnNlIiwiZGF0YSIsInRhcmdldCIsImFzbjFQYXJzZWQiLCJmcm9tQkVSIiwicmVzdWx0IiwiZXJyb3IiLCJFcnJvciIsInJlcyIsImZyb21BU04iLCJhc24xU2NoZW1hIiwiX2EiLCJpc0NvbnZlcnRpYmxlIiwic2NoZW1hIiwic2NoZW1hU3RvcmFnZSIsImdldCIsImNhY2hlIiwidGFyZ2V0U2NoZW1hIiwiY29uc3RydWN0b3IiLCJDb25zdHJ1Y3RlZCIsInR5cGUiLCJBc25UeXBlVHlwZXMiLCJDaG9pY2UiLCJpZEJsb2NrIiwidGFnQ2xhc3MiLCJ0YWdOdW1iZXIiLCJ2YWx1ZUJsb2NrIiwia2V5IiwiaXRlbXMiLCJhc24xQ29tcGFyZWRTY2hlbWEiLCJjb21wYXJlU2NoZW1hIiwidmVyaWZpZWQiLCJBc25TY2hlbWFWYWxpZGF0aW9uRXJyb3IiLCJuYW1lIiwiaXNUeXBlT2ZBcnJheSIsIkFycmF5IiwiaXNBcnJheSIsIml0ZW1UeXBlIiwiY29udmVydGVyIiwiZGVmYXVsdENvbnZlcnRlciIsImZyb20iLCJlbGVtZW50IiwiYXNuMVNjaGVtYVZhbHVlIiwic2NoZW1hSXRlbSIsInNjaGVtYUl0ZW1UeXBlIiwicmVwZWF0ZWQiLCJpbXBsaWNpdCIsIkNvbnRhaW5lciIsIlNlcXVlbmNlIiwiU2V0IiwibmV3SXRlbSIsIm5ld0l0ZW1Bc24iLCJ0b0JFUiIsIm9mZnNldCIsInRvU2NoZW1hIiwiQXNuMVR5cGVOYW1lIiwiQXNuUHJvcFR5cGVzIiwiQXNuMVR5cGUiLCJzY2hlbWFzIiwicHVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/parser.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/schema.js":
/*!****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/schema.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnSchemaStorage = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(action-browser)/./node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nclass AsnSchemaStorage {\n    constructor(){\n        this.items = new WeakMap();\n    }\n    has(target) {\n        return this.items.has(target);\n    }\n    get(target, checkSchema = false) {\n        const schema = this.items.get(target);\n        if (!schema) {\n            throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);\n        }\n        if (checkSchema && !schema.schema) {\n            throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);\n        }\n        return schema;\n    }\n    cache(target) {\n        const schema = this.get(target);\n        if (!schema.schema) {\n            schema.schema = this.create(target, true);\n        }\n    }\n    createDefault(target) {\n        const schema = {\n            type: enums_1.AsnTypeTypes.Sequence,\n            items: {}\n        };\n        const parentSchema = this.findParentSchema(target);\n        if (parentSchema) {\n            Object.assign(schema, parentSchema);\n            schema.items = Object.assign({}, schema.items, parentSchema.items);\n        }\n        return schema;\n    }\n    create(target, useNames) {\n        const schema = this.items.get(target) || this.createDefault(target);\n        const asn1Value = [];\n        for(const key in schema.items){\n            const item = schema.items[key];\n            const name = useNames ? key : \"\";\n            let asn1Item;\n            if (typeof item.type === \"number\") {\n                const Asn1TypeName = enums_1.AsnPropTypes[item.type];\n                const Asn1Type = asn1js[Asn1TypeName];\n                if (!Asn1Type) {\n                    throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);\n                }\n                asn1Item = new Asn1Type({\n                    name\n                });\n            } else if ((0, helper_1.isConvertible)(item.type)) {\n                const instance = new item.type();\n                asn1Item = instance.toSchema(name);\n            } else if (item.optional) {\n                const itemSchema = this.get(item.type);\n                if (itemSchema.type === enums_1.AsnTypeTypes.Choice) {\n                    asn1Item = new asn1js.Any({\n                        name\n                    });\n                } else {\n                    asn1Item = this.create(item.type, false);\n                    asn1Item.name = name;\n                }\n            } else {\n                asn1Item = new asn1js.Any({\n                    name\n                });\n            }\n            const optional = !!item.optional || item.defaultValue !== undefined;\n            if (item.repeated) {\n                asn1Item.name = \"\";\n                const Container = item.repeated === \"set\" ? asn1js.Set : asn1js.Sequence;\n                asn1Item = new Container({\n                    name: \"\",\n                    value: [\n                        new asn1js.Repeated({\n                            name,\n                            value: asn1Item\n                        })\n                    ]\n                });\n            }\n            if (item.context !== null && item.context !== undefined) {\n                if (item.implicit) {\n                    if (typeof item.type === \"number\" || (0, helper_1.isConvertible)(item.type)) {\n                        const Container = item.repeated ? asn1js.Constructed : asn1js.Primitive;\n                        asn1Value.push(new Container({\n                            name,\n                            optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: item.context\n                            }\n                        }));\n                    } else {\n                        this.cache(item.type);\n                        const isRepeated = !!item.repeated;\n                        let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;\n                        value = \"valueBlock\" in value ? value.valueBlock.value : value.value;\n                        asn1Value.push(new asn1js.Constructed({\n                            name: !isRepeated ? name : \"\",\n                            optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: item.context\n                            },\n                            value: value\n                        }));\n                    }\n                } else {\n                    asn1Value.push(new asn1js.Constructed({\n                        optional,\n                        idBlock: {\n                            tagClass: 3,\n                            tagNumber: item.context\n                        },\n                        value: [\n                            asn1Item\n                        ]\n                    }));\n                }\n            } else {\n                asn1Item.optional = optional;\n                asn1Value.push(asn1Item);\n            }\n        }\n        switch(schema.type){\n            case enums_1.AsnTypeTypes.Sequence:\n                return new asn1js.Sequence({\n                    value: asn1Value,\n                    name: \"\"\n                });\n            case enums_1.AsnTypeTypes.Set:\n                return new asn1js.Set({\n                    value: asn1Value,\n                    name: \"\"\n                });\n            case enums_1.AsnTypeTypes.Choice:\n                return new asn1js.Choice({\n                    value: asn1Value,\n                    name: \"\"\n                });\n            default:\n                throw new Error(`Unsupported ASN1 type in use`);\n        }\n    }\n    set(target, schema) {\n        this.items.set(target, schema);\n        return this;\n    }\n    findParentSchema(target) {\n        const parent = Object.getPrototypeOf(target);\n        if (parent) {\n            const schema = this.items.get(parent);\n            return schema || this.findParentSchema(parent);\n        }\n        return null;\n    }\n}\nexports.AsnSchemaStorage = AsnSchemaStorage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3NjaGVtYS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsd0JBQXdCLEdBQUcsS0FBSztBQUNoQyxNQUFNRyxTQUFTQyxtQkFBT0EsQ0FBQyxxRUFBUTtBQUMvQixNQUFNQyxVQUFVRCxtQkFBT0EsQ0FBQyx5RkFBUztBQUNqQyxNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQywyRkFBVTtBQUNuQyxNQUFNRjtJQUNGSyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxLQUFLLEdBQUcsSUFBSUM7SUFDckI7SUFDQUMsSUFBSUMsTUFBTSxFQUFFO1FBQ1IsT0FBTyxJQUFJLENBQUNILEtBQUssQ0FBQ0UsR0FBRyxDQUFDQztJQUMxQjtJQUNBQyxJQUFJRCxNQUFNLEVBQUVFLGNBQWMsS0FBSyxFQUFFO1FBQzdCLE1BQU1DLFNBQVMsSUFBSSxDQUFDTixLQUFLLENBQUNJLEdBQUcsQ0FBQ0Q7UUFDOUIsSUFBSSxDQUFDRyxRQUFRO1lBQ1QsTUFBTSxJQUFJQyxNQUFNLENBQUMsdUJBQXVCLEVBQUVKLE9BQU9LLFNBQVMsQ0FBQ1QsV0FBVyxDQUFDVSxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQ3pGO1FBQ0EsSUFBSUosZUFBZSxDQUFDQyxPQUFPQSxNQUFNLEVBQUU7WUFDL0IsTUFBTSxJQUFJQyxNQUFNLENBQUMsUUFBUSxFQUFFSixPQUFPSyxTQUFTLENBQUNULFdBQVcsQ0FBQ1UsSUFBSSxDQUFDLDhEQUE4RCxDQUFDO1FBQ2hJO1FBQ0EsT0FBT0g7SUFDWDtJQUNBSSxNQUFNUCxNQUFNLEVBQUU7UUFDVixNQUFNRyxTQUFTLElBQUksQ0FBQ0YsR0FBRyxDQUFDRDtRQUN4QixJQUFJLENBQUNHLE9BQU9BLE1BQU0sRUFBRTtZQUNoQkEsT0FBT0EsTUFBTSxHQUFHLElBQUksQ0FBQ0ssTUFBTSxD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QVE7Z0JBQzlCLE9BQU8sSUFBSXBCLE9BQU9vQixRQUFRLENBQUM7b0JBQUV0QixPQUFPMkI7b0JBQVdYLE1BQU07Z0JBQUc7WUFDNUQsS0FBS1osUUFBUWlCLFlBQVksQ0FBQ3dCLEdBQUc7Z0JBQ3pCLE9BQU8sSUFBSTNDLE9BQU8yQyxHQUFHLENBQUM7b0JBQUU3QyxPQUFPMkI7b0JBQVdYLE1BQU07Z0JBQUc7WUFDdkQsS0FBS1osUUFBUWlCLFlBQVksQ0FBQ2tCLE1BQU07Z0JBQzVCLE9BQU8sSUFBSXJDLE9BQU9xQyxNQUFNLENBQUM7b0JBQUV2QyxPQUFPMkI7b0JBQVdYLE1BQU07Z0JBQUc7WUFDMUQ7Z0JBQ0ksTUFBTSxJQUFJRixNQUFNLENBQUMsNEJBQTRCLENBQUM7UUFDdEQ7SUFDSjtJQUNBMkMsSUFBSS9DLE1BQU0sRUFBRUcsTUFBTSxFQUFFO1FBQ2hCLElBQUksQ0FBQ04sS0FBSyxDQUFDa0QsR0FBRyxDQUFDL0MsUUFBUUc7UUFDdkIsT0FBTyxJQUFJO0lBQ2Y7SUFDQVcsaUJBQWlCZCxNQUFNLEVBQUU7UUFDckIsTUFBTWdELFNBQVM3RCxPQUFPOEQsY0FBYyxDQUFDakQ7UUFDckMsSUFBSWdELFFBQVE7WUFDUixNQUFNN0MsU0FBUyxJQUFJLENBQUNOLEtBQUssQ0FBQ0ksR0FBRyxDQUFDK0M7WUFDOUIsT0FBTzdDLFVBQVUsSUFBSSxDQUFDVyxnQkFBZ0IsQ0FBQ2tDO1FBQzNDO1FBQ0EsT0FBTztJQUNYO0FBQ0o7QUFDQTNELHdCQUF3QixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1ha2V0cGxhY2UtYWRtaW4vLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9zY2hlbWEuanM/Y2RhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXNuU2NoZW1hU3RvcmFnZSA9IHZvaWQgMDtcbmNvbnN0IGFzbjFqcyA9IHJlcXVpcmUoXCJhc24xanNcIik7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG5jb25zdCBoZWxwZXJfMSA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcbmNsYXNzIEFzblNjaGVtYVN0b3JhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLml0ZW1zID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG4gICAgaGFzKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5oYXModGFyZ2V0KTtcbiAgICB9XG4gICAgZ2V0KHRhcmdldCwgY2hlY2tTY2hlbWEgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLml0ZW1zLmdldCh0YXJnZXQpO1xuICAgICAgICBpZiAoIXNjaGVtYSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2V0IHNjaGVtYSBmb3IgJyR7dGFyZ2V0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lfScgdGFyZ2V0YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrU2NoZW1hICYmICFzY2hlbWEuc2NoZW1hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNjaGVtYSAnJHt0YXJnZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWV9JyBkb2Vzbid0IGNvbnRhaW4gQVNOLjEgc2NoZW1hLiBDYWxsICdBc25TY2hlbWFTdG9yYWdlLmNhY2hlJy5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICBjYWNoZSh0YXJnZXQpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5nZXQodGFyZ2V0KTtcbiAgICAgICAgaWYgKCFzY2hlbWEuc2NoZW1hKSB7XG4gICAgICAgICAgICBzY2hlbWEuc2NoZW1hID0gdGhpcy5jcmVhdGUodGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVEZWZhdWx0KHRhcmdldCkge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB7XG4gICAgICAgICAgICB0eXBlOiBlbnVtc18xLkFzblR5cGVUeXBlcy5TZXF1ZW5jZSxcbiAgICAgICAgICAgIGl0ZW1zOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGFyZW50U2NoZW1hID0gdGhpcy5maW5kUGFyZW50U2NoZW1hKHRhcmdldCk7XG4gICAgICAgIGlmIChwYXJlbnRTY2hlbWEpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2NoZW1hLCBwYXJlbnRTY2hlbWEpO1xuICAgICAgICAgICAgc2NoZW1hLml0ZW1zID0gT2JqZWN0LmFzc2lnbih7fSwgc2NoZW1hLml0ZW1zLCBwYXJlbnRTY2hlbWEuaXRlbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxuICAgIGNyZWF0ZSh0YXJnZXQsIHVzZU5hbWVzKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuaXRlbXMuZ2V0KHRhcmdldCkgfHwgdGhpcy5jcmVhdGVEZWZhdWx0KHRhcmdldCk7XG4gICAgICAgIGNvbnN0IGFzbjFWYWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBzY2hlbWEuaXRlbXNba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB1c2VOYW1lcyA/IGtleSA6IFwiXCI7XG4gICAgICAgICAgICBsZXQgYXNuMUl0ZW07XG4gICAgICAgICAgICBpZiAodHlwZW9mIChpdGVtLnR5cGUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgQXNuMVR5cGVOYW1lID0gZW51bXNfMS5Bc25Qcm9wVHlwZXNbaXRlbS50eXBlXTtcbiAgICAgICAgICAgICAgICBjb25zdCBBc24xVHlwZSA9IGFzbjFqc1tBc24xVHlwZU5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICghQXNuMVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2V0IEFTTjEgY2xhc3MgYnkgbmFtZSAnJHtBc24xVHlwZU5hbWV9J2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IG5ldyBBc24xVHlwZSh7IG5hbWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoMCwgaGVscGVyXzEuaXNDb252ZXJ0aWJsZSkoaXRlbS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IGl0ZW0udHlwZSgpO1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gaW5zdGFuY2UudG9TY2hlbWEobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbVNjaGVtYSA9IHRoaXMuZ2V0KGl0ZW0udHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1TY2hlbWEudHlwZSA9PT0gZW51bXNfMS5Bc25UeXBlVHlwZXMuQ2hvaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gbmV3IGFzbjFqcy5BbnkoeyBuYW1lIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSB0aGlzLmNyZWF0ZShpdGVtLnR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgYXNuMUl0ZW0ubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSBuZXcgYXNuMWpzLkFueSh7IG5hbWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcHRpb25hbCA9ICEhaXRlbS5vcHRpb25hbCB8fCBpdGVtLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGl0ZW0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICBhc24xSXRlbS5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBDb250YWluZXIgPSBpdGVtLnJlcGVhdGVkID09PSBcInNldFwiXG4gICAgICAgICAgICAgICAgICAgID8gYXNuMWpzLlNldFxuICAgICAgICAgICAgICAgICAgICA6IGFzbjFqcy5TZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IG5ldyBDb250YWluZXIoe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IGFzbjFqcy5SZXBlYXRlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXNuMUl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtLmNvbnRleHQgIT09IG51bGwgJiYgaXRlbS5jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pbXBsaWNpdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0udHlwZSA9PT0gXCJudW1iZXJcIiB8fCAoMCwgaGVscGVyXzEuaXNDb252ZXJ0aWJsZSkoaXRlbS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgQ29udGFpbmVyID0gaXRlbS5yZXBlYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYXNuMWpzLkNvbnN0cnVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhc24xanMuUHJpbWl0aXZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2gobmV3IENvbnRhaW5lcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZEJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0NsYXNzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXI6IGl0ZW0uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZShpdGVtLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNSZXBlYXRlZCA9ICEhaXRlbS5yZXBlYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9ICFpc1JlcGVhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmdldChpdGVtLnR5cGUsIHRydWUpLnNjaGVtYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYXNuMUl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwidmFsdWVCbG9ja1wiIGluIHZhbHVlID8gdmFsdWUudmFsdWVCbG9jay52YWx1ZSA6IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2gobmV3IGFzbjFqcy5Db25zdHJ1Y3RlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogIWlzUmVwZWF0ZWQgPyBuYW1lIDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZEJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0NsYXNzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXI6IGl0ZW0uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2gobmV3IGFzbjFqcy5Db25zdHJ1Y3RlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkQmxvY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdDbGFzczogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXI6IGl0ZW0uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW2FzbjFJdGVtXSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2goYXNuMUl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoc2NoZW1hLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgZW51bXNfMS5Bc25UeXBlVHlwZXMuU2VxdWVuY2U6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhc24xanMuU2VxdWVuY2UoeyB2YWx1ZTogYXNuMVZhbHVlLCBuYW1lOiBcIlwiIH0pO1xuICAgICAgICAgICAgY2FzZSBlbnVtc18xLkFzblR5cGVUeXBlcy5TZXQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBhc24xanMuU2V0KHsgdmFsdWU6IGFzbjFWYWx1ZSwgbmFtZTogXCJcIiB9KTtcbiAgICAgICAgICAgIGNhc2UgZW51bXNfMS5Bc25UeXBlVHlwZXMuQ2hvaWNlOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXNuMWpzLkNob2ljZSh7IHZhbHVlOiBhc24xVmFsdWUsIG5hbWU6IFwiXCIgfSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgQVNOMSB0eXBlIGluIHVzZWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldCh0YXJnZXQsIHNjaGVtYSkge1xuICAgICAgICB0aGlzLml0ZW1zLnNldCh0YXJnZXQsIHNjaGVtYSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5kUGFyZW50U2NoZW1hKHRhcmdldCkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5pdGVtcy5nZXQocGFyZW50KTtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEgfHwgdGhpcy5maW5kUGFyZW50U2NoZW1hKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5Bc25TY2hlbWFTdG9yYWdlID0gQXNuU2NoZW1hU3RvcmFnZTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkFzblNjaGVtYVN0b3JhZ2UiLCJhc24xanMiLCJyZXF1aXJlIiwiZW51bXNfMSIsImhlbHBlcl8xIiwiY29uc3RydWN0b3IiLCJpdGVtcyIsIldlYWtNYXAiLCJoYXMiLCJ0YXJnZXQiLCJnZXQiLCJjaGVja1NjaGVtYSIsInNjaGVtYSIsIkVycm9yIiwicHJvdG90eXBlIiwibmFtZSIsImNhY2hlIiwiY3JlYXRlIiwiY3JlYXRlRGVmYXVsdCIsInR5cGUiLCJBc25UeXBlVHlwZXMiLCJTZXF1ZW5jZSIsInBhcmVudFNjaGVtYSIsImZpbmRQYXJlbnRTY2hlbWEiLCJhc3NpZ24iLCJ1c2VOYW1lcyIsImFzbjFWYWx1ZSIsImtleSIsIml0ZW0iLCJhc24xSXRlbSIsIkFzbjFUeXBlTmFtZSIsIkFzblByb3BUeXBlcyIsIkFzbjFUeXBlIiwiaXNDb252ZXJ0aWJsZSIsImluc3RhbmNlIiwidG9TY2hlbWEiLCJvcHRpb25hbCIsIml0ZW1TY2hlbWEiLCJDaG9pY2UiLCJBbnkiLCJkZWZhdWx0VmFsdWUiLCJ1bmRlZmluZWQiLCJyZXBlYXRlZCIsIkNvbnRhaW5lciIsIlNldCIsIlJlcGVhdGVkIiwiY29udGV4dCIsImltcGxpY2l0IiwiQ29uc3RydWN0ZWQiLCJQcmltaXRpdmUiLCJwdXNoIiwiaWRCbG9jayIsInRhZ0NsYXNzIiwidGFnTnVtYmVyIiwiaXNSZXBlYXRlZCIsInZhbHVlQmxvY2siLCJzZXQiLCJwYXJlbnQiLCJnZXRQcm90b3R5cGVPZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/schema.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/schema.js":
/*!****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/schema.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnSchemaStorage = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(rsc)/./node_modules/asn1js/build/index.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nclass AsnSchemaStorage {\n    constructor(){\n        this.items = new WeakMap();\n    }\n    has(target) {\n        return this.items.has(target);\n    }\n    get(target, checkSchema = false) {\n        const schema = this.items.get(target);\n        if (!schema) {\n            throw new Error(`Cannot get schema for '${target.prototype.constructor.name}' target`);\n        }\n        if (checkSchema && !schema.schema) {\n            throw new Error(`Schema '${target.prototype.constructor.name}' doesn't contain ASN.1 schema. Call 'AsnSchemaStorage.cache'.`);\n        }\n        return schema;\n    }\n    cache(target) {\n        const schema = this.get(target);\n        if (!schema.schema) {\n            schema.schema = this.create(target, true);\n        }\n    }\n    createDefault(target) {\n        const schema = {\n            type: enums_1.AsnTypeTypes.Sequence,\n            items: {}\n        };\n        const parentSchema = this.findParentSchema(target);\n        if (parentSchema) {\n            Object.assign(schema, parentSchema);\n            schema.items = Object.assign({}, schema.items, parentSchema.items);\n        }\n        return schema;\n    }\n    create(target, useNames) {\n        const schema = this.items.get(target) || this.createDefault(target);\n        const asn1Value = [];\n        for(const key in schema.items){\n            const item = schema.items[key];\n            const name = useNames ? key : \"\";\n            let asn1Item;\n            if (typeof item.type === \"number\") {\n                const Asn1TypeName = enums_1.AsnPropTypes[item.type];\n                const Asn1Type = asn1js[Asn1TypeName];\n                if (!Asn1Type) {\n                    throw new Error(`Cannot get ASN1 class by name '${Asn1TypeName}'`);\n                }\n                asn1Item = new Asn1Type({\n                    name\n                });\n            } else if ((0, helper_1.isConvertible)(item.type)) {\n                const instance = new item.type();\n                asn1Item = instance.toSchema(name);\n            } else if (item.optional) {\n                const itemSchema = this.get(item.type);\n                if (itemSchema.type === enums_1.AsnTypeTypes.Choice) {\n                    asn1Item = new asn1js.Any({\n                        name\n                    });\n                } else {\n                    asn1Item = this.create(item.type, false);\n                    asn1Item.name = name;\n                }\n            } else {\n                asn1Item = new asn1js.Any({\n                    name\n                });\n            }\n            const optional = !!item.optional || item.defaultValue !== undefined;\n            if (item.repeated) {\n                asn1Item.name = \"\";\n                const Container = item.repeated === \"set\" ? asn1js.Set : asn1js.Sequence;\n                asn1Item = new Container({\n                    name: \"\",\n                    value: [\n                        new asn1js.Repeated({\n                            name,\n                            value: asn1Item\n                        })\n                    ]\n                });\n            }\n            if (item.context !== null && item.context !== undefined) {\n                if (item.implicit) {\n                    if (typeof item.type === \"number\" || (0, helper_1.isConvertible)(item.type)) {\n                        const Container = item.repeated ? asn1js.Constructed : asn1js.Primitive;\n                        asn1Value.push(new Container({\n                            name,\n                            optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: item.context\n                            }\n                        }));\n                    } else {\n                        this.cache(item.type);\n                        const isRepeated = !!item.repeated;\n                        let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;\n                        value = \"valueBlock\" in value ? value.valueBlock.value : value.value;\n                        asn1Value.push(new asn1js.Constructed({\n                            name: !isRepeated ? name : \"\",\n                            optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: item.context\n                            },\n                            value: value\n                        }));\n                    }\n                } else {\n                    asn1Value.push(new asn1js.Constructed({\n                        optional,\n                        idBlock: {\n                            tagClass: 3,\n                            tagNumber: item.context\n                        },\n                        value: [\n                            asn1Item\n                        ]\n                    }));\n                }\n            } else {\n                asn1Item.optional = optional;\n                asn1Value.push(asn1Item);\n            }\n        }\n        switch(schema.type){\n            case enums_1.AsnTypeTypes.Sequence:\n                return new asn1js.Sequence({\n                    value: asn1Value,\n                    name: \"\"\n                });\n            case enums_1.AsnTypeTypes.Set:\n                return new asn1js.Set({\n                    value: asn1Value,\n                    name: \"\"\n                });\n            case enums_1.AsnTypeTypes.Choice:\n                return new asn1js.Choice({\n                    value: asn1Value,\n                    name: \"\"\n                });\n            default:\n                throw new Error(`Unsupported ASN1 type in use`);\n        }\n    }\n    set(target, schema) {\n        this.items.set(target, schema);\n        return this;\n    }\n    findParentSchema(target) {\n        const parent = Object.getPrototypeOf(target);\n        if (parent) {\n            const schema = this.items.get(parent);\n            return schema || this.findParentSchema(parent);\n        }\n        return null;\n    }\n}\nexports.AsnSchemaStorage = AsnSchemaStorage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9zY2hlbWEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHdCQUF3QixHQUFHLEtBQUs7QUFDaEMsTUFBTUcsU0FBU0MsbUJBQU9BLENBQUMsMERBQVE7QUFDL0IsTUFBTUMsVUFBVUQsbUJBQU9BLENBQUMsOEVBQVM7QUFDakMsTUFBTUUsV0FBV0YsbUJBQU9BLENBQUMsZ0ZBQVU7QUFDbkMsTUFBTUY7SUFDRkssYUFBYztRQUNWLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUlDO0lBQ3JCO0lBQ0FDLElBQUlDLE1BQU0sRUFBRTtRQUNSLE9BQU8sSUFBSSxDQUFDSCxLQUFLLENBQUNFLEdBQUcsQ0FBQ0M7SUFDMUI7SUFDQUMsSUFBSUQsTUFBTSxFQUFFRSxjQUFjLEtBQUssRUFBRTtRQUM3QixNQUFNQyxTQUFTLElBQUksQ0FBQ04sS0FBSyxDQUFDSSxHQUFHLENBQUNEO1FBQzlCLElBQUksQ0FBQ0csUUFBUTtZQUNULE1BQU0sSUFBSUMsTUFBTSxDQUFDLHVCQUF1QixFQUFFSixPQUFPSyxTQUFTLENBQUNULFdBQVcsQ0FBQ1UsSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUN6RjtRQUNBLElBQUlKLGVBQWUsQ0FBQ0MsT0FBT0EsTUFBTSxFQUFFO1lBQy9CLE1BQU0sSUFBSUMsTUFBTSxDQUFDLFFBQVEsRUFBRUosT0FBT0ssU0FBUyxDQUFDVCxXQUFXLENBQUNVLElBQUksQ0FBQyw4REFBOEQsQ0FBQztRQUNoSTtRQUNBLE9BQU9IO0lBQ1g7SUFDQUksTUFBTVAsTUFBTSxFQUFFO1FBQ1YsTUFBTUcsU0FBUyxJQUFJLENBQUNGLEdBQUcsQ0FBQ0Q7UUFDeEIsSUFBSSxDQUFDRyxPQUFPQSxNQUFNLEVBQUU7WUFDaEJBLE9BQU9BLE1BQU0sR0FBRyxJQUFJLENBQUNLLE1BQU0sQ0FBQ1IsUUFBUTtR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QUFPLElBQUlwQixPQUFPb0IsUUFBUSxDQUFDO29CQUFFdEIsT0FBTzJCO29CQUFXWCxNQUFNO2dCQUFHO1lBQzVELEtBQUtaLFFBQVFpQixZQUFZLENBQUN3QixHQUFHO2dCQUN6QixPQUFPLElBQUkzQyxPQUFPMkMsR0FBRyxDQUFDO29CQUFFN0MsT0FBTzJCO29CQUFXWCxNQUFNO2dCQUFHO1lBQ3ZELEtBQUtaLFFBQVFpQixZQUFZLENBQUNrQixNQUFNO2dCQUM1QixPQUFPLElBQUlyQyxPQUFPcUMsTUFBTSxDQUFDO29CQUFFdkMsT0FBTzJCO29CQUFXWCxNQUFNO2dCQUFHO1lBQzFEO2dCQUNJLE1BQU0sSUFBSUYsTUFBTSxDQUFDLDRCQUE0QixDQUFDO1FBQ3REO0lBQ0o7SUFDQTJDLElBQUkvQyxNQUFNLEVBQUVHLE1BQU0sRUFBRTtRQUNoQixJQUFJLENBQUNOLEtBQUssQ0FBQ2tELEdBQUcsQ0FBQy9DLFFBQVFHO1FBQ3ZCLE9BQU8sSUFBSTtJQUNmO0lBQ0FXLGlCQUFpQmQsTUFBTSxFQUFFO1FBQ3JCLE1BQU1nRCxTQUFTN0QsT0FBTzhELGNBQWMsQ0FBQ2pEO1FBQ3JDLElBQUlnRCxRQUFRO1lBQ1IsTUFBTTdDLFNBQVMsSUFBSSxDQUFDTixLQUFLLENBQUNJLEdBQUcsQ0FBQytDO1lBQzlCLE9BQU83QyxVQUFVLElBQUksQ0FBQ1csZ0JBQWdCLENBQUNrQztRQUMzQztRQUNBLE9BQU87SUFDWDtBQUNKO0FBQ0EzRCx3QkFBd0IsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYWtldHBsYWNlLWFkbWluLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvc2NoZW1hLmpzP2NkYWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzblNjaGVtYVN0b3JhZ2UgPSB2b2lkIDA7XG5jb25zdCBhc24xanMgPSByZXF1aXJlKFwiYXNuMWpzXCIpO1xuY29uc3QgZW51bXNfMSA9IHJlcXVpcmUoXCIuL2VudW1zXCIpO1xuY29uc3QgaGVscGVyXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJcIik7XG5jbGFzcyBBc25TY2hlbWFTdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgfVxuICAgIGhhcyh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuaGFzKHRhcmdldCk7XG4gICAgfVxuICAgIGdldCh0YXJnZXQsIGNoZWNrU2NoZW1hID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5pdGVtcy5nZXQodGFyZ2V0KTtcbiAgICAgICAgaWYgKCFzY2hlbWEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGdldCBzY2hlbWEgZm9yICcke3RhcmdldC5wcm90b3R5cGUuY29uc3RydWN0b3IubmFtZX0nIHRhcmdldGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja1NjaGVtYSAmJiAhc2NoZW1hLnNjaGVtYSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTY2hlbWEgJyR7dGFyZ2V0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lfScgZG9lc24ndCBjb250YWluIEFTTi4xIHNjaGVtYS4gQ2FsbCAnQXNuU2NoZW1hU3RvcmFnZS5jYWNoZScuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gICAgY2FjaGUodGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmICghc2NoZW1hLnNjaGVtYSkge1xuICAgICAgICAgICAgc2NoZW1hLnNjaGVtYSA9IHRoaXMuY3JlYXRlKHRhcmdldCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlRGVmYXVsdCh0YXJnZXQpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0ge1xuICAgICAgICAgICAgdHlwZTogZW51bXNfMS5Bc25UeXBlVHlwZXMuU2VxdWVuY2UsXG4gICAgICAgICAgICBpdGVtczoge30sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhcmVudFNjaGVtYSA9IHRoaXMuZmluZFBhcmVudFNjaGVtYSh0YXJnZXQpO1xuICAgICAgICBpZiAocGFyZW50U2NoZW1hKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHNjaGVtYSwgcGFyZW50U2NoZW1hKTtcbiAgICAgICAgICAgIHNjaGVtYS5pdGVtcyA9IE9iamVjdC5hc3NpZ24oe30sIHNjaGVtYS5pdGVtcywgcGFyZW50U2NoZW1hLml0ZW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbiAgICBjcmVhdGUodGFyZ2V0LCB1c2VOYW1lcykge1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLml0ZW1zLmdldCh0YXJnZXQpIHx8IHRoaXMuY3JlYXRlRGVmYXVsdCh0YXJnZXQpO1xuICAgICAgICBjb25zdCBhc24xVmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLml0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gc2NoZW1hLml0ZW1zW2tleV07XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdXNlTmFtZXMgPyBrZXkgOiBcIlwiO1xuICAgICAgICAgICAgbGV0IGFzbjFJdGVtO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoaXRlbS50eXBlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IEFzbjFUeXBlTmFtZSA9IGVudW1zXzEuQXNuUHJvcFR5cGVzW2l0ZW0udHlwZV07XG4gICAgICAgICAgICAgICAgY29uc3QgQXNuMVR5cGUgPSBhc24xanNbQXNuMVR5cGVOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoIUFzbjFUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGdldCBBU04xIGNsYXNzIGJ5IG5hbWUgJyR7QXNuMVR5cGVOYW1lfSdgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSBuZXcgQXNuMVR5cGUoeyBuYW1lIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKDAsIGhlbHBlcl8xLmlzQ29udmVydGlibGUpKGl0ZW0udHlwZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBpdGVtLnR5cGUoKTtcbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IGluc3RhbmNlLnRvU2NoZW1hKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5vcHRpb25hbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1TY2hlbWEgPSB0aGlzLmdldChpdGVtLnR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtU2NoZW1hLnR5cGUgPT09IGVudW1zXzEuQXNuVHlwZVR5cGVzLkNob2ljZSkge1xuICAgICAgICAgICAgICAgICAgICBhc24xSXRlbSA9IG5ldyBhc24xanMuQW55KHsgbmFtZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gdGhpcy5jcmVhdGUoaXRlbS50eXBlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGFzbjFJdGVtLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gbmV3IGFzbjFqcy5BbnkoeyBuYW1lIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3B0aW9uYWwgPSAhIWl0ZW0ub3B0aW9uYWwgfHwgaXRlbS5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChpdGVtLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgYXNuMUl0ZW0ubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgQ29udGFpbmVyID0gaXRlbS5yZXBlYXRlZCA9PT0gXCJzZXRcIlxuICAgICAgICAgICAgICAgICAgICA/IGFzbjFqcy5TZXRcbiAgICAgICAgICAgICAgICAgICAgOiBhc24xanMuU2VxdWVuY2U7XG4gICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSBuZXcgQ29udGFpbmVyKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBhc24xanMuUmVwZWF0ZWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFzbjFJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbS5jb250ZXh0ICE9PSBudWxsICYmIGl0ZW0uY29udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtLnR5cGUgPT09IFwibnVtYmVyXCIgfHwgKDAsIGhlbHBlcl8xLmlzQ29udmVydGlibGUpKGl0ZW0udHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IENvbnRhaW5lciA9IGl0ZW0ucmVwZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFzbjFqcy5Db25zdHJ1Y3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYXNuMWpzLlByaW1pdGl2ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzbjFWYWx1ZS5wdXNoKG5ldyBDb250YWluZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRCbG9jazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdDbGFzczogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnTnVtYmVyOiBpdGVtLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUoaXRlbS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVwZWF0ZWQgPSAhIWl0ZW0ucmVwZWF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSAhaXNSZXBlYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5nZXQoaXRlbS50eXBlLCB0cnVlKS5zY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFzbjFJdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBcInZhbHVlQmxvY2tcIiBpbiB2YWx1ZSA/IHZhbHVlLnZhbHVlQmxvY2sudmFsdWUgOiB2YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzbjFWYWx1ZS5wdXNoKG5ldyBhc24xanMuQ29uc3RydWN0ZWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICFpc1JlcGVhdGVkID8gbmFtZSA6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRCbG9jazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdDbGFzczogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnTnVtYmVyOiBpdGVtLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzbjFWYWx1ZS5wdXNoKG5ldyBhc24xanMuQ29uc3RydWN0ZWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZEJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnQ2xhc3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnTnVtYmVyOiBpdGVtLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFthc24xSXRlbV0sXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc24xSXRlbS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgICAgICAgICAgIGFzbjFWYWx1ZS5wdXNoKGFzbjFJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHNjaGVtYS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIGVudW1zXzEuQXNuVHlwZVR5cGVzLlNlcXVlbmNlOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXNuMWpzLlNlcXVlbmNlKHsgdmFsdWU6IGFzbjFWYWx1ZSwgbmFtZTogXCJcIiB9KTtcbiAgICAgICAgICAgIGNhc2UgZW51bXNfMS5Bc25UeXBlVHlwZXMuU2V0OlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYXNuMWpzLlNldCh7IHZhbHVlOiBhc24xVmFsdWUsIG5hbWU6IFwiXCIgfSk7XG4gICAgICAgICAgICBjYXNlIGVudW1zXzEuQXNuVHlwZVR5cGVzLkNob2ljZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5DaG9pY2UoeyB2YWx1ZTogYXNuMVZhbHVlLCBuYW1lOiBcIlwiIH0pO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIEFTTjEgdHlwZSBpbiB1c2VgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQodGFyZ2V0LCBzY2hlbWEpIHtcbiAgICAgICAgdGhpcy5pdGVtcy5zZXQodGFyZ2V0LCBzY2hlbWEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluZFBhcmVudFNjaGVtYSh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCk7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuaXRlbXMuZ2V0KHBhcmVudCk7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hIHx8IHRoaXMuZmluZFBhcmVudFNjaGVtYShwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNuU2NoZW1hU3RvcmFnZSA9IEFzblNjaGVtYVN0b3JhZ2U7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBc25TY2hlbWFTdG9yYWdlIiwiYXNuMWpzIiwicmVxdWlyZSIsImVudW1zXzEiLCJoZWxwZXJfMSIsImNvbnN0cnVjdG9yIiwiaXRlbXMiLCJXZWFrTWFwIiwiaGFzIiwidGFyZ2V0IiwiZ2V0IiwiY2hlY2tTY2hlbWEiLCJzY2hlbWEiLCJFcnJvciIsInByb3RvdHlwZSIsIm5hbWUiLCJjYWNoZSIsImNyZWF0ZSIsImNyZWF0ZURlZmF1bHQiLCJ0eXBlIiwiQXNuVHlwZVR5cGVzIiwiU2VxdWVuY2UiLCJwYXJlbnRTY2hlbWEiLCJmaW5kUGFyZW50U2NoZW1hIiwiYXNzaWduIiwidXNlTmFtZXMiLCJhc24xVmFsdWUiLCJrZXkiLCJpdGVtIiwiYXNuMUl0ZW0iLCJBc24xVHlwZU5hbWUiLCJBc25Qcm9wVHlwZXMiLCJBc24xVHlwZSIsImlzQ29udmVydGlibGUiLCJpbnN0YW5jZSIsInRvU2NoZW1hIiwib3B0aW9uYWwiLCJpdGVtU2NoZW1hIiwiQ2hvaWNlIiwiQW55IiwiZGVmYXVsdFZhbHVlIiwidW5kZWZpbmVkIiwicmVwZWF0ZWQiLCJDb250YWluZXIiLCJTZXQiLCJSZXBlYXRlZCIsImNvbnRleHQiLCJpbXBsaWNpdCIsIkNvbnN0cnVjdGVkIiwiUHJpbWl0aXZlIiwicHVzaCIsImlkQmxvY2siLCJ0YWdDbGFzcyIsInRhZ051bWJlciIsImlzUmVwZWF0ZWQiLCJ2YWx1ZUJsb2NrIiwic2V0IiwicGFyZW50IiwiZ2V0UHJvdG90eXBlT2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/schema.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js":
/*!********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnSerializer = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(action-browser)/./node_modules/asn1js/build/index.js\");\nconst converters = __webpack_require__(/*! ./converters */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nclass AsnSerializer {\n    static serialize(obj) {\n        if (obj instanceof asn1js.BaseBlock) {\n            return obj.toBER(false);\n        }\n        return this.toASN(obj).toBER(false);\n    }\n    static toASN(obj) {\n        if (obj && typeof obj === \"object\" && (0, helper_1.isConvertible)(obj)) {\n            return obj.toASN();\n        }\n        if (!(obj && typeof obj === \"object\")) {\n            throw new TypeError(\"Parameter 1 should be type of Object.\");\n        }\n        const target = obj.constructor;\n        const schema = storage_1.schemaStorage.get(target);\n        storage_1.schemaStorage.cache(target);\n        let asn1Value = [];\n        if (schema.itemType) {\n            if (!Array.isArray(obj)) {\n                throw new TypeError(\"Parameter 1 should be type of Array.\");\n            }\n            if (typeof schema.itemType === \"number\") {\n                const converter = converters.defaultConverter(schema.itemType);\n                if (!converter) {\n                    throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n                }\n                asn1Value = obj.map((o)=>converter.toASN(o));\n            } else {\n                asn1Value = obj.map((o)=>this.toAsnItem({\n                        type: schema.itemType\n                    }, \"[]\", target, o));\n            }\n        } else {\n            for(const key in schema.items){\n                const schemaItem = schema.items[key];\n                const objProp = obj[key];\n                if (objProp === undefined || schemaItem.defaultValue === objProp || typeof schemaItem.defaultValue === \"object\" && typeof objProp === \"object\" && (0, helper_1.isArrayEqual)(this.serialize(schemaItem.defaultValue), this.serialize(objProp))) {\n                    continue;\n                }\n                const asn1Item = AsnSerializer.toAsnItem(schemaItem, key, target, objProp);\n                if (typeof schemaItem.context === \"number\") {\n                    if (schemaItem.implicit) {\n                        if (!schemaItem.repeated && (typeof schemaItem.type === \"number\" || (0, helper_1.isConvertible)(schemaItem.type))) {\n                            const value = {};\n                            value.valueHex = asn1Item instanceof asn1js.Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();\n                            asn1Value.push(new asn1js.Primitive({\n                                optional: schemaItem.optional,\n                                idBlock: {\n                                    tagClass: 3,\n                                    tagNumber: schemaItem.context\n                                },\n                                ...value\n                            }));\n                        } else {\n                            asn1Value.push(new asn1js.Constructed({\n                                optional: schemaItem.optional,\n                                idBlock: {\n                                    tagClass: 3,\n                                    tagNumber: schemaItem.context\n                                },\n                                value: asn1Item.valueBlock.value\n                            }));\n                        }\n                    } else {\n                        asn1Value.push(new asn1js.Constructed({\n                            optional: schemaItem.optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: schemaItem.context\n                            },\n                            value: [\n                                asn1Item\n                            ]\n                        }));\n                    }\n                } else if (schemaItem.repeated) {\n                    asn1Value = asn1Value.concat(asn1Item);\n                } else {\n                    asn1Value.push(asn1Item);\n                }\n            }\n        }\n        let asnSchema;\n        switch(schema.type){\n            case enums_1.AsnTypeTypes.Sequence:\n                asnSchema = new asn1js.Sequence({\n                    value: asn1Value\n                });\n                break;\n            case enums_1.AsnTypeTypes.Set:\n                asnSchema = new asn1js.Set({\n                    value: asn1Value\n                });\n                break;\n            case enums_1.AsnTypeTypes.Choice:\n                if (!asn1Value[0]) {\n                    throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);\n                }\n                asnSchema = asn1Value[0];\n                break;\n        }\n        return asnSchema;\n    }\n    static toAsnItem(schemaItem, key, target, objProp) {\n        let asn1Item;\n        if (typeof schemaItem.type === \"number\") {\n            const converter = schemaItem.converter;\n            if (!converter) {\n                throw new Error(`Property '${key}' doesn't have converter for type ${enums_1.AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);\n            }\n            if (schemaItem.repeated) {\n                if (!Array.isArray(objProp)) {\n                    throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n                }\n                const items = Array.from(objProp, (element)=>converter.toASN(element));\n                const Container = schemaItem.repeated === \"sequence\" ? asn1js.Sequence : asn1js.Set;\n                asn1Item = new Container({\n                    value: items\n                });\n            } else {\n                asn1Item = converter.toASN(objProp);\n            }\n        } else {\n            if (schemaItem.repeated) {\n                if (!Array.isArray(objProp)) {\n                    throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n                }\n                const items = Array.from(objProp, (element)=>this.toASN(element));\n                const Container = schemaItem.repeated === \"sequence\" ? asn1js.Sequence : asn1js.Set;\n                asn1Item = new Container({\n                    value: items\n                });\n            } else {\n                asn1Item = this.toASN(objProp);\n            }\n        }\n        return asn1Item;\n    }\n}\nexports.AsnSerializer = AsnSerializer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3NlcmlhbGl6ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHLEtBQUs7QUFDN0IsTUFBTUcsU0FBU0MsbUJBQU9BLENBQUMscUVBQVE7QUFDL0IsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUMsbUdBQWM7QUFDekMsTUFBTUUsVUFBVUYsbUJBQU9BLENBQUMseUZBQVM7QUFDakMsTUFBTUcsV0FBV0gsbUJBQU9BLENBQUMsMkZBQVU7QUFDbkMsTUFBTUksWUFBWUosbUJBQU9BLENBQUMsNkZBQVc7QUFDckMsTUFBTUY7SUFDRixPQUFPTyxVQUFVQyxHQUFHLEVBQUU7UUFDbEIsSUFBSUEsZUFBZVAsT0FBT1EsU0FBUyxFQUFFO1lBQ2pDLE9BQU9ELElBQUlFLEtBQUssQ0FBQztRQUNyQjtRQUNBLE9BQU8sSUFBSSxDQUFDQyxLQUFLLENBQUNILEtBQUtFLEtBQUssQ0FBQztJQUNqQztJQUNBLE9BQU9DLE1BQU1ILEdBQUcsRUFBRTtRQUNkLElBQUlBLE9BQU8sT0FBT0EsUUFBUSxZQUFZLENBQUMsR0FBR0gsU0FBU08sYUFBYSxFQUFFSixNQUFNO1lBQ3BFLE9BQU9BLElBQUlHLEtBQUs7UUFDcEI7UUFDQSxJQUFJLENBQUVILENBQUFBLE9BQU8sT0FBT0EsUUFBUSxRQUFPLEdBQUk7WUFDbkMsTUFBTSxJQUFJSyxVQUFVO1FBQ3hCO1FBQ0EsTUFBTUMsU0FBU04sSUFBSU8sV0FBVztRQUM5QixNQUFNQyxTQUFTVixVQUFVVyxhQUFhLENBQUNDLEdBQUcsQ0FBQ0o7UUFDM0NSLFVBQVVXLGFBQWEsQ0FBQ0UsS0FBSyxDQUFDTDtRQUM5QixJQUFJTSxZQUFZLEVBQUU7UUFDbEIsSUFBSUosT0FBT0ssUUFBUSxFQUFFO1lBQ2pCLElBQUksQ0FBQ0MsTUFBTUMs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S0FBSyxhQUNwQ3pDLE9BQU93RCxRQUFRLEdBQ2Z4RCxPQUFPeUQsR0FBRztnQkFDaEJuQixXQUFXLElBQUl3QixVQUFVO29CQUNyQmhFLE9BQU9rQztnQkFDWDtZQUNKLE9BQ0s7Z0JBQ0RNLFdBQVdmLFVBQVViLEtBQUssQ0FBQ3dCO1lBQy9CO1FBQ0osT0FDSztZQUNELElBQUlELFdBQVdRLFFBQVEsRUFBRTtnQkFDckIsSUFBSSxDQUFDcEIsTUFBTUMsT0FBTyxDQUFDWSxVQUFVO29CQUN6QixNQUFNLElBQUl0QixVQUFVO2dCQUN4QjtnQkFDQSxNQUFNb0IsUUFBUVgsTUFBTXVDLElBQUksQ0FBQzFCLFNBQVMsQ0FBQzJCLFVBQVksSUFBSSxDQUFDbkQsS0FBSyxDQUFDbUQ7Z0JBQzFELE1BQU1DLFlBQVk3QixXQUFXUSxRQUFRLEtBQUssYUFDcEN6QyxPQUFPd0QsUUFBUSxHQUNmeEQsT0FBT3lELEdBQUc7Z0JBQ2hCbkIsV0FBVyxJQUFJd0IsVUFBVTtvQkFDckJoRSxPQUFPa0M7Z0JBQ1g7WUFDSixPQUNLO2dCQUNETSxXQUFXLElBQUksQ0FBQzVCLEtBQUssQ0FBQ3dCO1lBQzFCO1FBQ0o7UUFDQSxPQUFPSTtJQUNYO0FBQ0o7QUFDQXpDLHFCQUFxQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1ha2V0cGxhY2UtYWRtaW4vLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9zZXJpYWxpemVyLmpzP2Q0ODIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzblNlcmlhbGl6ZXIgPSB2b2lkIDA7XG5jb25zdCBhc24xanMgPSByZXF1aXJlKFwiYXNuMWpzXCIpO1xuY29uc3QgY29udmVydGVycyA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnNcIik7XG5jb25zdCBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG5jb25zdCBoZWxwZXJfMSA9IHJlcXVpcmUoXCIuL2hlbHBlclwiKTtcbmNvbnN0IHN0b3JhZ2VfMSA9IHJlcXVpcmUoXCIuL3N0b3JhZ2VcIik7XG5jbGFzcyBBc25TZXJpYWxpemVyIHtcbiAgICBzdGF0aWMgc2VyaWFsaXplKG9iaikge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgYXNuMWpzLkJhc2VCbG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIG9iai50b0JFUihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudG9BU04ob2JqKS50b0JFUihmYWxzZSk7XG4gICAgfVxuICAgIHN0YXRpYyB0b0FTTihvYmopIHtcbiAgICAgICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmICgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLnRvQVNOKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEob2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyIDEgc2hvdWxkIGJlIHR5cGUgb2YgT2JqZWN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXQgPSBvYmouY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHN0b3JhZ2VfMS5zY2hlbWFTdG9yYWdlLmdldCh0YXJnZXQpO1xuICAgICAgICBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5jYWNoZSh0YXJnZXQpO1xuICAgICAgICBsZXQgYXNuMVZhbHVlID0gW107XG4gICAgICAgIGlmIChzY2hlbWEuaXRlbVR5cGUpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAxIHNob3VsZCBiZSB0eXBlIG9mIEFycmF5LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLml0ZW1UeXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udmVydGVyID0gY29udmVydGVycy5kZWZhdWx0Q29udmVydGVyKHNjaGVtYS5pdGVtVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZ2V0IGRlZmF1bHQgY29udmVydGVyIGZvciBhcnJheSBpdGVtIG9mICR7dGFyZ2V0Lm5hbWV9IEFTTjEgc2NoZW1hYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzbjFWYWx1ZSA9IG9iai5tYXAoKG8pID0+IGNvbnZlcnRlci50b0FTTihvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc24xVmFsdWUgPSBvYmoubWFwKChvKSA9PiB0aGlzLnRvQXNuSXRlbSh7IHR5cGU6IHNjaGVtYS5pdGVtVHlwZSB9LCBcIltdXCIsIHRhcmdldCwgbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hSXRlbSA9IHNjaGVtYS5pdGVtc1trZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9ialByb3AgPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAob2JqUHJvcCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIHx8IHNjaGVtYUl0ZW0uZGVmYXVsdFZhbHVlID09PSBvYmpQcm9wXG4gICAgICAgICAgICAgICAgICAgIHx8ICh0eXBlb2Ygc2NoZW1hSXRlbS5kZWZhdWx0VmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9ialByb3AgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICgwLCBoZWxwZXJfMS5pc0FycmF5RXF1YWwpKHRoaXMuc2VyaWFsaXplKHNjaGVtYUl0ZW0uZGVmYXVsdFZhbHVlKSwgdGhpcy5zZXJpYWxpemUob2JqUHJvcCkpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYXNuMUl0ZW0gPSBBc25TZXJpYWxpemVyLnRvQXNuSXRlbShzY2hlbWFJdGVtLCBrZXksIHRhcmdldCwgb2JqUHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFJdGVtLmNvbnRleHQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVtYUl0ZW0uaW1wbGljaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2NoZW1hSXRlbS5yZXBlYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmICh0eXBlb2Ygc2NoZW1hSXRlbS50eXBlID09PSBcIm51bWJlclwiIHx8ICgwLCBoZWxwZXJfMS5pc0NvbnZlcnRpYmxlKShzY2hlbWFJdGVtLnR5cGUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUudmFsdWVIZXggPSBhc24xSXRlbSBpbnN0YW5jZW9mIGFzbjFqcy5OdWxsID8gYXNuMUl0ZW0udmFsdWVCZWZvcmVEZWNvZGVWaWV3IDogYXNuMUl0ZW0udmFsdWVCbG9jay50b0JFUigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzbjFWYWx1ZS5wdXNoKG5ldyBhc24xanMuUHJpbWl0aXZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IHNjaGVtYUl0ZW0ub3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkQmxvY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0NsYXNzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnTnVtYmVyOiBzY2hlbWFJdGVtLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzbjFWYWx1ZS5wdXNoKG5ldyBhc24xanMuQ29uc3RydWN0ZWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25hbDogc2NoZW1hSXRlbS5vcHRpb25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRCbG9jazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnQ2xhc3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOdW1iZXI6IHNjaGVtYUl0ZW0uY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFzbjFJdGVtLnZhbHVlQmxvY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2gobmV3IGFzbjFqcy5Db25zdHJ1Y3RlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IHNjaGVtYUl0ZW0ub3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRCbG9jazoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdDbGFzczogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnTnVtYmVyOiBzY2hlbWFJdGVtLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW2FzbjFJdGVtXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWFJdGVtLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzbjFWYWx1ZSA9IGFzbjFWYWx1ZS5jb25jYXQoYXNuMUl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNuMVZhbHVlLnB1c2goYXNuMUl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYXNuU2NoZW1hO1xuICAgICAgICBzd2l0Y2ggKHNjaGVtYS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIGVudW1zXzEuQXNuVHlwZVR5cGVzLlNlcXVlbmNlOlxuICAgICAgICAgICAgICAgIGFzblNjaGVtYSA9IG5ldyBhc24xanMuU2VxdWVuY2UoeyB2YWx1ZTogYXNuMVZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBlbnVtc18xLkFzblR5cGVUeXBlcy5TZXQ6XG4gICAgICAgICAgICAgICAgYXNuU2NoZW1hID0gbmV3IGFzbjFqcy5TZXQoeyB2YWx1ZTogYXNuMVZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBlbnVtc18xLkFzblR5cGVUeXBlcy5DaG9pY2U6XG4gICAgICAgICAgICAgICAgaWYgKCFhc24xVmFsdWVbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTY2hlbWEgJyR7dGFyZ2V0Lm5hbWV9JyBoYXMgd3JvbmcgZGF0YS4gQ2hvaWNlIGNhbm5vdCBiZSBlbXB0eS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNuU2NoZW1hID0gYXNuMVZhbHVlWzBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc25TY2hlbWE7XG4gICAgfVxuICAgIHN0YXRpYyB0b0Fzbkl0ZW0oc2NoZW1hSXRlbSwga2V5LCB0YXJnZXQsIG9ialByb3ApIHtcbiAgICAgICAgbGV0IGFzbjFJdGVtO1xuICAgICAgICBpZiAodHlwZW9mIChzY2hlbWFJdGVtLnR5cGUpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSBzY2hlbWFJdGVtLmNvbnZlcnRlcjtcbiAgICAgICAgICAgIGlmICghY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9wZXJ0eSAnJHtrZXl9JyBkb2Vzbid0IGhhdmUgY29udmVydGVyIGZvciB0eXBlICR7ZW51bXNfMS5Bc25Qcm9wVHlwZXNbc2NoZW1hSXRlbS50eXBlXX0gaW4gc2NoZW1hICcke3RhcmdldC5uYW1lfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWFJdGVtLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9ialByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ29ialByb3AnIHNob3VsZCBiZSB0eXBlIG9mIEFycmF5LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKG9ialByb3AsIChlbGVtZW50KSA9PiBjb252ZXJ0ZXIudG9BU04oZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IENvbnRhaW5lciA9IHNjaGVtYUl0ZW0ucmVwZWF0ZWQgPT09IFwic2VxdWVuY2VcIlxuICAgICAgICAgICAgICAgICAgICA/IGFzbjFqcy5TZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICA6IGFzbjFqcy5TZXQ7XG4gICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSBuZXcgQ29udGFpbmVyKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSBjb252ZXJ0ZXIudG9BU04ob2JqUHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hSXRlbS5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmpQcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICdvYmpQcm9wJyBzaG91bGQgYmUgdHlwZSBvZiBBcnJheS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbShvYmpQcm9wLCAoZWxlbWVudCkgPT4gdGhpcy50b0FTTihlbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgQ29udGFpbmVyID0gc2NoZW1hSXRlbS5yZXBlYXRlZCA9PT0gXCJzZXF1ZW5jZVwiXG4gICAgICAgICAgICAgICAgICAgID8gYXNuMWpzLlNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgIDogYXNuMWpzLlNldDtcbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IG5ldyBDb250YWluZXIoe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc24xSXRlbSA9IHRoaXMudG9BU04ob2JqUHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzbjFJdGVtO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNuU2VyaWFsaXplciA9IEFzblNlcmlhbGl6ZXI7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJBc25TZXJpYWxpemVyIiwiYXNuMWpzIiwicmVxdWlyZSIsImNvbnZlcnRlcnMiLCJlbnVtc18xIiwiaGVscGVyXzEiLCJzdG9yYWdlXzEiLCJzZXJpYWxpemUiLCJvYmoiLCJCYXNlQmxvY2siLCJ0b0JFUiIsInRvQVNOIiwiaXNDb252ZXJ0aWJsZSIsIlR5cGVFcnJvciIsInRhcmdldCIsImNvbnN0cnVjdG9yIiwic2NoZW1hIiwic2NoZW1hU3RvcmFnZSIsImdldCIsImNhY2hlIiwiYXNuMVZhbHVlIiwiaXRlbVR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJjb252ZXJ0ZXIiLCJkZWZhdWx0Q29udmVydGVyIiwiRXJyb3IiLCJuYW1lIiwibWFwIiwibyIsInRvQXNuSXRlbSIsInR5cGUiLCJrZXkiLCJpdGVtcyIsInNjaGVtYUl0ZW0iLCJvYmpQcm9wIiwidW5kZWZpbmVkIiwiZGVmYXVsdFZhbHVlIiwiaXNBcnJheUVxdWFsIiwiYXNuMUl0ZW0iLCJjb250ZXh0IiwiaW1wbGljaXQiLCJyZXBlYXRlZCIsInZhbHVlSGV4IiwiTnVsbCIsInZhbHVlQmVmb3JlRGVjb2RlVmlldyIsInZhbHVlQmxvY2siLCJwdXNoIiwiUHJpbWl0aXZlIiwib3B0aW9uYWwiLCJpZEJsb2NrIiwidGFnQ2xhc3MiLCJ0YWdOdW1iZXIiLCJDb25zdHJ1Y3RlZCIsImNvbmNhdCIsImFzblNjaGVtYSIsIkFzblR5cGVUeXBlcyIsIlNlcXVlbmNlIiwiU2V0IiwiQ2hvaWNlIiwiQXNuUHJvcFR5cGVzIiwiZnJvbSIsImVsZW1lbnQiLCJDb250YWluZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js":
/*!********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.AsnSerializer = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(rsc)/./node_modules/asn1js/build/index.js\");\nconst converters = __webpack_require__(/*! ./converters */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/converters.js\");\nconst enums_1 = __webpack_require__(/*! ./enums */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/enums.js\");\nconst helper_1 = __webpack_require__(/*! ./helper */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/helper.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js\");\nclass AsnSerializer {\n    static serialize(obj) {\n        if (obj instanceof asn1js.BaseBlock) {\n            return obj.toBER(false);\n        }\n        return this.toASN(obj).toBER(false);\n    }\n    static toASN(obj) {\n        if (obj && typeof obj === \"object\" && (0, helper_1.isConvertible)(obj)) {\n            return obj.toASN();\n        }\n        if (!(obj && typeof obj === \"object\")) {\n            throw new TypeError(\"Parameter 1 should be type of Object.\");\n        }\n        const target = obj.constructor;\n        const schema = storage_1.schemaStorage.get(target);\n        storage_1.schemaStorage.cache(target);\n        let asn1Value = [];\n        if (schema.itemType) {\n            if (!Array.isArray(obj)) {\n                throw new TypeError(\"Parameter 1 should be type of Array.\");\n            }\n            if (typeof schema.itemType === \"number\") {\n                const converter = converters.defaultConverter(schema.itemType);\n                if (!converter) {\n                    throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n                }\n                asn1Value = obj.map((o)=>converter.toASN(o));\n            } else {\n                asn1Value = obj.map((o)=>this.toAsnItem({\n                        type: schema.itemType\n                    }, \"[]\", target, o));\n            }\n        } else {\n            for(const key in schema.items){\n                const schemaItem = schema.items[key];\n                const objProp = obj[key];\n                if (objProp === undefined || schemaItem.defaultValue === objProp || typeof schemaItem.defaultValue === \"object\" && typeof objProp === \"object\" && (0, helper_1.isArrayEqual)(this.serialize(schemaItem.defaultValue), this.serialize(objProp))) {\n                    continue;\n                }\n                const asn1Item = AsnSerializer.toAsnItem(schemaItem, key, target, objProp);\n                if (typeof schemaItem.context === \"number\") {\n                    if (schemaItem.implicit) {\n                        if (!schemaItem.repeated && (typeof schemaItem.type === \"number\" || (0, helper_1.isConvertible)(schemaItem.type))) {\n                            const value = {};\n                            value.valueHex = asn1Item instanceof asn1js.Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();\n                            asn1Value.push(new asn1js.Primitive({\n                                optional: schemaItem.optional,\n                                idBlock: {\n                                    tagClass: 3,\n                                    tagNumber: schemaItem.context\n                                },\n                                ...value\n                            }));\n                        } else {\n                            asn1Value.push(new asn1js.Constructed({\n                                optional: schemaItem.optional,\n                                idBlock: {\n                                    tagClass: 3,\n                                    tagNumber: schemaItem.context\n                                },\n                                value: asn1Item.valueBlock.value\n                            }));\n                        }\n                    } else {\n                        asn1Value.push(new asn1js.Constructed({\n                            optional: schemaItem.optional,\n                            idBlock: {\n                                tagClass: 3,\n                                tagNumber: schemaItem.context\n                            },\n                            value: [\n                                asn1Item\n                            ]\n                        }));\n                    }\n                } else if (schemaItem.repeated) {\n                    asn1Value = asn1Value.concat(asn1Item);\n                } else {\n                    asn1Value.push(asn1Item);\n                }\n            }\n        }\n        let asnSchema;\n        switch(schema.type){\n            case enums_1.AsnTypeTypes.Sequence:\n                asnSchema = new asn1js.Sequence({\n                    value: asn1Value\n                });\n                break;\n            case enums_1.AsnTypeTypes.Set:\n                asnSchema = new asn1js.Set({\n                    value: asn1Value\n                });\n                break;\n            case enums_1.AsnTypeTypes.Choice:\n                if (!asn1Value[0]) {\n                    throw new Error(`Schema '${target.name}' has wrong data. Choice cannot be empty.`);\n                }\n                asnSchema = asn1Value[0];\n                break;\n        }\n        return asnSchema;\n    }\n    static toAsnItem(schemaItem, key, target, objProp) {\n        let asn1Item;\n        if (typeof schemaItem.type === \"number\") {\n            const converter = schemaItem.converter;\n            if (!converter) {\n                throw new Error(`Property '${key}' doesn't have converter for type ${enums_1.AsnPropTypes[schemaItem.type]} in schema '${target.name}'`);\n            }\n            if (schemaItem.repeated) {\n                if (!Array.isArray(objProp)) {\n                    throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n                }\n                const items = Array.from(objProp, (element)=>converter.toASN(element));\n                const Container = schemaItem.repeated === \"sequence\" ? asn1js.Sequence : asn1js.Set;\n                asn1Item = new Container({\n                    value: items\n                });\n            } else {\n                asn1Item = converter.toASN(objProp);\n            }\n        } else {\n            if (schemaItem.repeated) {\n                if (!Array.isArray(objProp)) {\n                    throw new TypeError(\"Parameter 'objProp' should be type of Array.\");\n                }\n                const items = Array.from(objProp, (element)=>this.toASN(element));\n                const Container = schemaItem.repeated === \"sequence\" ? asn1js.Sequence : asn1js.Set;\n                asn1Item = new Container({\n                    value: items\n                });\n            } else {\n                asn1Item = this.toASN(objProp);\n            }\n        }\n        return asn1Item;\n    }\n}\nexports.AsnSerializer = AsnSerializer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9zZXJpYWxpemVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBRyxLQUFLO0FBQzdCLE1BQU1HLFNBQVNDLG1CQUFPQSxDQUFDLDBEQUFRO0FBQy9CLE1BQU1DLGFBQWFELG1CQUFPQSxDQUFDLHdGQUFjO0FBQ3pDLE1BQU1FLFVBQVVGLG1CQUFPQSxDQUFDLDhFQUFTO0FBQ2pDLE1BQU1HLFdBQVdILG1CQUFPQSxDQUFDLGdGQUFVO0FBQ25DLE1BQU1JLFlBQVlKLG1CQUFPQSxDQUFDLGtGQUFXO0FBQ3JDLE1BQU1GO0lBQ0YsT0FBT08sVUFBVUMsR0FBRyxFQUFFO1FBQ2xCLElBQUlBLGVBQWVQLE9BQU9RLFNBQVMsRUFBRTtZQUNqQyxPQUFPRCxJQUFJRSxLQUFLLENBQUM7UUFDckI7UUFDQSxPQUFPLElBQUksQ0FBQ0MsS0FBSyxDQUFDSCxLQUFLRSxLQUFLLENBQUM7SUFDakM7SUFDQSxPQUFPQyxNQUFNSCxHQUFHLEVBQUU7UUFDZCxJQUFJQSxPQUFPLE9BQU9BLFFBQVEsWUFBWSxDQUFDLEdBQUdILFNBQVNPLGFBQWEsRUFBRUosTUFBTTtZQUNwRSxPQUFPQSxJQUFJRyxLQUFLO1FBQ3BCO1FBQ0EsSUFBSSxDQUFFSCxDQUFBQSxPQUFPLE9BQU9BLFFBQVEsUUFBTyxHQUFJO1lBQ25DLE1BQU0sSUFBSUssVUFBVTtRQUN4QjtRQUNBLE1BQU1DLFNBQVNOLElBQUlPLFdBQVc7UUFDOUIsTUFBTUMsU0FBU1YsVUFBVVcsYUFBYSxDQUFDQyxHQUFHLENBQUNKO1FBQzNDUixVQUFVVyxhQUFhLENBQUNFLEtBQUssQ0FBQ0w7UUFDOUIsSUFBSU0sWUFBWSxFQUFFO1FBQ2xCLElBQUlKLE9BQU9LLFFBQVEsRUFBRTtZQUNqQixJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ2Ys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QyxPQUFPd0QsUUFBUSxHQUNmeEQsT0FBT3lELEdBQUc7Z0JBQ2hCbkIsV0FBVyxJQUFJd0IsVUFBVTtvQkFDckJoRSxPQUFPa0M7Z0JBQ1g7WUFDSixPQUNLO2dCQUNETSxXQUFXZixVQUFVYixLQUFLLENBQUN3QjtZQUMvQjtRQUNKLE9BQ0s7WUFDRCxJQUFJRCxXQUFXUSxRQUFRLEVBQUU7Z0JBQ3JCLElBQUksQ0FBQ3BCLE1BQU1DLE9BQU8sQ0FBQ1ksVUFBVTtvQkFDekIsTUFBTSxJQUFJdEIsVUFBVTtnQkFDeEI7Z0JBQ0EsTUFBTW9CLFFBQVFYLE1BQU11QyxJQUFJLENBQUMxQixTQUFTLENBQUMyQixVQUFZLElBQUksQ0FBQ25ELEtBQUssQ0FBQ21EO2dCQUMxRCxNQUFNQyxZQUFZN0IsV0FBV1EsUUFBUSxLQUFLLGFBQ3BDekMsT0FBT3dELFFBQVEsR0FDZnhELE9BQU95RCxHQUFHO2dCQUNoQm5CLFdBQVcsSUFBSXdCLFVBQVU7b0JBQ3JCaEUsT0FBT2tDO2dCQUNYO1lBQ0osT0FDSztnQkFDRE0sV0FBVyxJQUFJLENBQUM1QixLQUFLLENBQUN3QjtZQUMxQjtRQUNKO1FBQ0EsT0FBT0k7SUFDWDtBQUNKO0FBQ0F6QyxxQkFBcUIsR0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYWtldHBsYWNlLWFkbWluLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvc2VyaWFsaXplci5qcz9kNDgyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc25TZXJpYWxpemVyID0gdm9pZCAwO1xuY29uc3QgYXNuMWpzID0gcmVxdWlyZShcImFzbjFqc1wiKTtcbmNvbnN0IGNvbnZlcnRlcnMgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzXCIpO1xuY29uc3QgZW51bXNfMSA9IHJlcXVpcmUoXCIuL2VudW1zXCIpO1xuY29uc3QgaGVscGVyXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJcIik7XG5jb25zdCBzdG9yYWdlXzEgPSByZXF1aXJlKFwiLi9zdG9yYWdlXCIpO1xuY2xhc3MgQXNuU2VyaWFsaXplciB7XG4gICAgc3RhdGljIHNlcmlhbGl6ZShvYmopIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIGFzbjFqcy5CYXNlQmxvY2spIHtcbiAgICAgICAgICAgIHJldHVybiBvYmoudG9CRVIoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRvQVNOKG9iaikudG9CRVIoZmFsc2UpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9BU04ob2JqKSB7XG4gICAgICAgIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiAoMCwgaGVscGVyXzEuaXNDb252ZXJ0aWJsZSkob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai50b0FTTigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKG9iaiAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAxIHNob3VsZCBiZSB0eXBlIG9mIE9iamVjdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBzdG9yYWdlXzEuc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0KTtcbiAgICAgICAgc3RvcmFnZV8xLnNjaGVtYVN0b3JhZ2UuY2FjaGUodGFyZ2V0KTtcbiAgICAgICAgbGV0IGFzbjFWYWx1ZSA9IFtdO1xuICAgICAgICBpZiAoc2NoZW1hLml0ZW1UeXBlKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgMSBzaG91bGQgYmUgdHlwZSBvZiBBcnJheS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5pdGVtVHlwZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IGNvbnZlcnRlcnMuZGVmYXVsdENvbnZlcnRlcihzY2hlbWEuaXRlbVR5cGUpO1xuICAgICAgICAgICAgICAgIGlmICghY29udmVydGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGdldCBkZWZhdWx0IGNvbnZlcnRlciBmb3IgYXJyYXkgaXRlbSBvZiAke3RhcmdldC5uYW1lfSBBU04xIHNjaGVtYWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhc24xVmFsdWUgPSBvYmoubWFwKChvKSA9PiBjb252ZXJ0ZXIudG9BU04obykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNuMVZhbHVlID0gb2JqLm1hcCgobykgPT4gdGhpcy50b0Fzbkl0ZW0oeyB0eXBlOiBzY2hlbWEuaXRlbVR5cGUgfSwgXCJbXVwiLCB0YXJnZXQsIG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5pdGVtcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYUl0ZW0gPSBzY2hlbWEuaXRlbXNba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmpQcm9wID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKG9ialByb3AgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB8fCBzY2hlbWFJdGVtLmRlZmF1bHRWYWx1ZSA9PT0gb2JqUHJvcFxuICAgICAgICAgICAgICAgICAgICB8fCAodHlwZW9mIHNjaGVtYUl0ZW0uZGVmYXVsdFZhbHVlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmpQcm9wID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAoMCwgaGVscGVyXzEuaXNBcnJheUVxdWFsKSh0aGlzLnNlcmlhbGl6ZShzY2hlbWFJdGVtLmRlZmF1bHRWYWx1ZSksIHRoaXMuc2VyaWFsaXplKG9ialByb3ApKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGFzbjFJdGVtID0gQXNuU2VyaWFsaXplci50b0Fzbkl0ZW0oc2NoZW1hSXRlbSwga2V5LCB0YXJnZXQsIG9ialByb3ApO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hSXRlbS5jb250ZXh0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY2hlbWFJdGVtLmltcGxpY2l0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNjaGVtYUl0ZW0ucmVwZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAodHlwZW9mIHNjaGVtYUl0ZW0udHlwZSA9PT0gXCJudW1iZXJcIiB8fCAoMCwgaGVscGVyXzEuaXNDb252ZXJ0aWJsZSkoc2NoZW1hSXRlbS50eXBlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnZhbHVlSGV4ID0gYXNuMUl0ZW0gaW5zdGFuY2VvZiBhc24xanMuTnVsbCA/IGFzbjFJdGVtLnZhbHVlQmVmb3JlRGVjb2RlVmlldyA6IGFzbjFJdGVtLnZhbHVlQmxvY2sudG9CRVIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChuZXcgYXNuMWpzLlByaW1pdGl2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBzY2hlbWFJdGVtLm9wdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZEJsb2NrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdDbGFzczogMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ051bWJlcjogc2NoZW1hSXRlbS5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUucHVzaChuZXcgYXNuMWpzLkNvbnN0cnVjdGVkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWw6IHNjaGVtYUl0ZW0ub3B0aW9uYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkQmxvY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ0NsYXNzOiAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnTnVtYmVyOiBzY2hlbWFJdGVtLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBhc24xSXRlbS52YWx1ZUJsb2NrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzbjFWYWx1ZS5wdXNoKG5ldyBhc24xanMuQ29uc3RydWN0ZWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBzY2hlbWFJdGVtLm9wdGlvbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkQmxvY2s6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnQ2xhc3M6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ051bWJlcjogc2NoZW1hSXRlbS5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFthc24xSXRlbV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hSXRlbS5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBhc24xVmFsdWUgPSBhc24xVmFsdWUuY29uY2F0KGFzbjFJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFzbjFWYWx1ZS5wdXNoKGFzbjFJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFzblNjaGVtYTtcbiAgICAgICAgc3dpdGNoIChzY2hlbWEudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBlbnVtc18xLkFzblR5cGVUeXBlcy5TZXF1ZW5jZTpcbiAgICAgICAgICAgICAgICBhc25TY2hlbWEgPSBuZXcgYXNuMWpzLlNlcXVlbmNlKHsgdmFsdWU6IGFzbjFWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZW51bXNfMS5Bc25UeXBlVHlwZXMuU2V0OlxuICAgICAgICAgICAgICAgIGFzblNjaGVtYSA9IG5ldyBhc24xanMuU2V0KHsgdmFsdWU6IGFzbjFWYWx1ZSB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZW51bXNfMS5Bc25UeXBlVHlwZXMuQ2hvaWNlOlxuICAgICAgICAgICAgICAgIGlmICghYXNuMVZhbHVlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2NoZW1hICcke3RhcmdldC5uYW1lfScgaGFzIHdyb25nIGRhdGEuIENob2ljZSBjYW5ub3QgYmUgZW1wdHkuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFzblNjaGVtYSA9IGFzbjFWYWx1ZVswXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXNuU2NoZW1hO1xuICAgIH1cbiAgICBzdGF0aWMgdG9Bc25JdGVtKHNjaGVtYUl0ZW0sIGtleSwgdGFyZ2V0LCBvYmpQcm9wKSB7XG4gICAgICAgIGxldCBhc24xSXRlbTtcbiAgICAgICAgaWYgKHR5cGVvZiAoc2NoZW1hSXRlbS50eXBlKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgY29uc3QgY29udmVydGVyID0gc2NoZW1hSXRlbS5jb252ZXJ0ZXI7XG4gICAgICAgICAgICBpZiAoIWNvbnZlcnRlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvcGVydHkgJyR7a2V5fScgZG9lc24ndCBoYXZlIGNvbnZlcnRlciBmb3IgdHlwZSAke2VudW1zXzEuQXNuUHJvcFR5cGVzW3NjaGVtYUl0ZW0udHlwZV19IGluIHNjaGVtYSAnJHt0YXJnZXQubmFtZX0nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NoZW1hSXRlbS5yZXBlYXRlZCkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmpQcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICdvYmpQcm9wJyBzaG91bGQgYmUgdHlwZSBvZiBBcnJheS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gQXJyYXkuZnJvbShvYmpQcm9wLCAoZWxlbWVudCkgPT4gY29udmVydGVyLnRvQVNOKGVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBDb250YWluZXIgPSBzY2hlbWFJdGVtLnJlcGVhdGVkID09PSBcInNlcXVlbmNlXCJcbiAgICAgICAgICAgICAgICAgICAgPyBhc24xanMuU2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgOiBhc24xanMuU2V0O1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gbmV3IENvbnRhaW5lcih7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzbjFJdGVtID0gY29udmVydGVyLnRvQVNOKG9ialByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNjaGVtYUl0ZW0ucmVwZWF0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqUHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAnb2JqUHJvcCcgc2hvdWxkIGJlIHR5cGUgb2YgQXJyYXkuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IEFycmF5LmZyb20ob2JqUHJvcCwgKGVsZW1lbnQpID0+IHRoaXMudG9BU04oZWxlbWVudCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IENvbnRhaW5lciA9IHNjaGVtYUl0ZW0ucmVwZWF0ZWQgPT09IFwic2VxdWVuY2VcIlxuICAgICAgICAgICAgICAgICAgICA/IGFzbjFqcy5TZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICA6IGFzbjFqcy5TZXQ7XG4gICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSBuZXcgQ29udGFpbmVyKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW1zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNuMUl0ZW0gPSB0aGlzLnRvQVNOKG9ialByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc24xSXRlbTtcbiAgICB9XG59XG5leHBvcnRzLkFzblNlcmlhbGl6ZXIgPSBBc25TZXJpYWxpemVyO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQXNuU2VyaWFsaXplciIsImFzbjFqcyIsInJlcXVpcmUiLCJjb252ZXJ0ZXJzIiwiZW51bXNfMSIsImhlbHBlcl8xIiwic3RvcmFnZV8xIiwic2VyaWFsaXplIiwib2JqIiwiQmFzZUJsb2NrIiwidG9CRVIiLCJ0b0FTTiIsImlzQ29udmVydGlibGUiLCJUeXBlRXJyb3IiLCJ0YXJnZXQiLCJjb25zdHJ1Y3RvciIsInNjaGVtYSIsInNjaGVtYVN0b3JhZ2UiLCJnZXQiLCJjYWNoZSIsImFzbjFWYWx1ZSIsIml0ZW1UeXBlIiwiQXJyYXkiLCJpc0FycmF5IiwiY29udmVydGVyIiwiZGVmYXVsdENvbnZlcnRlciIsIkVycm9yIiwibmFtZSIsIm1hcCIsIm8iLCJ0b0Fzbkl0ZW0iLCJ0eXBlIiwia2V5IiwiaXRlbXMiLCJzY2hlbWFJdGVtIiwib2JqUHJvcCIsInVuZGVmaW5lZCIsImRlZmF1bHRWYWx1ZSIsImlzQXJyYXlFcXVhbCIsImFzbjFJdGVtIiwiY29udGV4dCIsImltcGxpY2l0IiwicmVwZWF0ZWQiLCJ2YWx1ZUhleCIsIk51bGwiLCJ2YWx1ZUJlZm9yZURlY29kZVZpZXciLCJ2YWx1ZUJsb2NrIiwicHVzaCIsIlByaW1pdGl2ZSIsIm9wdGlvbmFsIiwiaWRCbG9jayIsInRhZ0NsYXNzIiwidGFnTnVtYmVyIiwiQ29uc3RydWN0ZWQiLCJjb25jYXQiLCJhc25TY2hlbWEiLCJBc25UeXBlVHlwZXMiLCJTZXF1ZW5jZSIsIlNldCIsIkNob2ljZSIsIkFzblByb3BUeXBlcyIsImZyb20iLCJlbGVtZW50IiwiQ29udGFpbmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/serializer.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/storage.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.schemaStorage = void 0;\nconst schema_1 = __webpack_require__(/*! ./schema */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/schema.js\");\nexports.schemaStorage = new schema_1.AsnSchemaStorage();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3N0b3JhZ2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHLEtBQUs7QUFDN0IsTUFBTUcsV0FBV0MsbUJBQU9BLENBQUMsMkZBQVU7QUFDbkNKLHFCQUFxQixHQUFHLElBQUlHLFNBQVNFLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1ha2V0cGxhY2UtYWRtaW4vLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9zdG9yYWdlLmpzP2RkMTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNjaGVtYVN0b3JhZ2UgPSB2b2lkIDA7XG5jb25zdCBzY2hlbWFfMSA9IHJlcXVpcmUoXCIuL3NjaGVtYVwiKTtcbmV4cG9ydHMuc2NoZW1hU3RvcmFnZSA9IG5ldyBzY2hlbWFfMS5Bc25TY2hlbWFTdG9yYWdlKCk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzY2hlbWFTdG9yYWdlIiwic2NoZW1hXzEiLCJyZXF1aXJlIiwiQXNuU2NoZW1hU3RvcmFnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/storage.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.schemaStorage = void 0;\nconst schema_1 = __webpack_require__(/*! ./schema */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/schema.js\");\nexports.schemaStorage = new schema_1.AsnSchemaStorage();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy9zdG9yYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxxQkFBcUIsR0FBRyxLQUFLO0FBQzdCLE1BQU1HLFdBQVdDLG1CQUFPQSxDQUFDLGdGQUFVO0FBQ25DSixxQkFBcUIsR0FBRyxJQUFJRyxTQUFTRSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYWtldHBsYWNlLWFkbWluLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvc3RvcmFnZS5qcz9kZDEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zY2hlbWFTdG9yYWdlID0gdm9pZCAwO1xuY29uc3Qgc2NoZW1hXzEgPSByZXF1aXJlKFwiLi9zY2hlbWFcIik7XG5leHBvcnRzLnNjaGVtYVN0b3JhZ2UgPSBuZXcgc2NoZW1hXzEuQXNuU2NoZW1hU3RvcmFnZSgpO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2NoZW1hU3RvcmFnZSIsInNjaGVtYV8xIiwicmVxdWlyZSIsIkFzblNjaGVtYVN0b3JhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/storage.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BitString = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(action-browser)/./node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(action-browser)/./node_modules/pvtsutils/build/index.js\");\nclass BitString {\n    constructor(params, unusedBits = 0){\n        this.unusedBits = 0;\n        this.value = new ArrayBuffer(0);\n        if (params) {\n            if (typeof params === \"number\") {\n                this.fromNumber(params);\n            } else if (pvtsutils_1.BufferSourceConverter.isBufferSource(params)) {\n                this.unusedBits = unusedBits;\n                this.value = pvtsutils_1.BufferSourceConverter.toArrayBuffer(params);\n            } else {\n                throw TypeError(\"Unsupported type of 'params' argument for BitString\");\n            }\n        }\n    }\n    fromASN(asn) {\n        if (!(asn instanceof asn1js.BitString)) {\n            throw new TypeError(\"Argument 'asn' is not instance of ASN.1 BitString\");\n        }\n        this.unusedBits = asn.valueBlock.unusedBits;\n        this.value = asn.valueBlock.valueHex;\n        return this;\n    }\n    toASN() {\n        return new asn1js.BitString({\n            unusedBits: this.unusedBits,\n            valueHex: this.value\n        });\n    }\n    toSchema(name) {\n        return new asn1js.BitString({\n            name\n        });\n    }\n    toNumber() {\n        let res = \"\";\n        const uintArray = new Uint8Array(this.value);\n        for (const octet of uintArray){\n            res += octet.toString(2).padStart(8, \"0\");\n        }\n        res = res.split(\"\").reverse().join(\"\");\n        if (this.unusedBits) {\n            res = res.slice(this.unusedBits).padStart(this.unusedBits, \"0\");\n        }\n        return parseInt(res, 2);\n    }\n    fromNumber(value) {\n        let bits = value.toString(2);\n        const octetSize = bits.length + 7 >> 3;\n        this.unusedBits = (octetSize << 3) - bits.length;\n        const octets = new Uint8Array(octetSize);\n        bits = bits.padStart(octetSize << 3, \"0\").split(\"\").reverse().join(\"\");\n        let index = 0;\n        while(index < octetSize){\n            octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);\n            index++;\n        }\n        this.value = octets.buffer;\n    }\n}\nexports.BitString = BitString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3R5cGVzL2JpdF9zdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGlCQUFpQixHQUFHLEtBQUs7QUFDekIsTUFBTUcsU0FBU0MsbUJBQU9BLENBQUMscUVBQVE7QUFDL0IsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsMkVBQVc7QUFDdkMsTUFBTUY7SUFDRkksWUFBWUMsTUFBTSxFQUFFQyxhQUFhLENBQUMsQ0FBRTtRQUNoQyxJQUFJLENBQUNBLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNQLEtBQUssR0FBRyxJQUFJUSxZQUFZO1FBQzdCLElBQUlGLFFBQVE7WUFDUixJQUFJLE9BQU9BLFdBQVcsVUFBVTtnQkFDNUIsSUFBSSxDQUFDRyxVQUFVLENBQUNIO1lBQ3BCLE9BQ0ssSUFBSUYsWUFBWU0scUJBQXFCLENBQUNDLGNBQWMsQ0FBQ0wsU0FBUztnQkFDL0QsSUFBSSxDQUFDQyxVQUFVLEdBQUdBO2dCQUNsQixJQUFJLENBQUNQLEtBQUssR0FBR0ksWUFBWU0scUJBQXFCLENBQUNFLGFBQWEsQ0FBQ047WUFDakUsT0FDSztnQkFDRCxNQUFNTyxVQUFVO1lBQ3BCO1FBQ0o7SUFDSjtJQUNBQyxRQUFRQyxHQUFHLEVBQUU7UUFDVCxJQUFJLENBQUVBLENBQUFBLGVBQWViLE9BQU9ELFNBQVMsR0FBRztZQUNwQyxNQUFNLElBQUlZLFVBQVU7UUFDeEI7UUFDQSxJQUFJLENBQUNOLFVBQVUsR0FBR1EsSUFBSUMsVUFBVSxDQUFDVCxVQUFVO1FBQzNDLElBQUksQ0FBQ1AsS0FBSyxHQUFHZSxJQUFJQyxVQUFVLENBQUNDLFFBQVE7UUFDcEMsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMsUUFBUTtRQUNKLE9BQU8sSUFBSWhCLE9BQU9ELFNBQVMsQ0FBQztZQUFFTSxZQUFZLElBQUksQ0FBQ0EsVUFBVTtZQUFFVSxVQUFVLElBQUksQ0FBQ2pCLEtBQUs7UUFBQztJQUNwRjtJQUNBbUIsU0FBU0MsSUFBSSxFQUFFO1FBQ1gsT0FBTyxJQUFJbEIsT0FBT0QsU0FBUyxDQUFDO1lBQUVtQjtRQUFLO0lBQ3ZDO0lBQ0FDLFdBQVc7UUFDUCxJQUFJQyxNQUFNO1FBQ1YsTUFBTUMsWUFBWSxJQUFJQyxXQUFXLElBQUksQ0FBQ3hCLEtBQUs7UUFDM0MsS0FBSyxNQUFNeUIsU0FBU0YsVUFBVztZQUMzQkQsT0FBT0csTUFBTUMsUUFBUSxDQUFDLEdBQUdDLFFBQVEsQ0FBQyxHQUFHO1FBQ3pDO1FBQ0FMLE1BQU1BLElBQUlNLEtBQUssQ0FBQyxJQUFJQyxPQUFPLEdBQUdDLElBQUksQ0FBQztRQUNuQyxJQUFJLElBQUksQ0FBQ3ZCLFVBQVUsRUFBRTtZQUNqQmUsTUFBTUEsSUFBSVMsS0FBSyxDQUFDLElBQUksQ0FBQ3hCLFVBQVUsRUFBRW9CLFFBQVEsQ0FBQyxJQUFJLENBQUNwQixVQUFVLEVBQUU7UUFDL0Q7UUFDQSxPQUFPeUIsU0FBU1YsS0FBSztJQUN6QjtJQUNBYixXQUFXVCxLQUFLLEVBQUU7UUFDZCxJQUFJaUMsT0FBT2pDLE1BQU0wQixRQUFRLENBQUM7UUFDMUIsTUFBTVEsWUFBWSxLQUFNQyxNQUFNLEdBQUcsS0FBTTtRQUN2QyxJQUFJLENBQUM1QixVQUFVLEdBQUcsQ0FBQzJCLGFBQWEsS0FBS0QsS0FBS0UsTUFBTTtRQUNoRCxNQUFNQyxTQUFTLElBQUlaLFdBQVdVO1FBQzlCRCxPQUFPQSxLQUFLTixRQUFRLENBQUNPLGFBQWEsR0FBRyxLQUFLTixLQUFLLENBQUMsSUFBSUMsT0FBTyxHQUFHQyxJQUFJLENBQUM7UUFDbkUsSUFBSU8sUUFBUTtRQUNaLE1BQU9BLFFBQVFILFVBQVc7WUFDdEJFLE1BQU0sQ0FBQ0MsTUFBTSxHQUFHTCxTQUFTQyxLQUFLRixLQUFLLENBQUNNLFNBQVMsR0FBRyxDQUFDQSxTQUFTLEtBQUssSUFBSTtZQUNuRUE7UUFDSjtRQUNBLElBQUksQ0FBQ3JDLEtBQUssR0FBR29DLE9BQU9FLE1BQU07SUFDOUI7QUFDSjtBQUNBdkMsaUJBQWlCLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktbWFrZXRwbGFjZS1hZG1pbi8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3R5cGVzL2JpdF9zdHJpbmcuanM/MzdkOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQml0U3RyaW5nID0gdm9pZCAwO1xuY29uc3QgYXNuMWpzID0gcmVxdWlyZShcImFzbjFqc1wiKTtcbmNvbnN0IHB2dHN1dGlsc18xID0gcmVxdWlyZShcInB2dHN1dGlsc1wiKTtcbmNsYXNzIEJpdFN0cmluZyB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zLCB1bnVzZWRCaXRzID0gMCkge1xuICAgICAgICB0aGlzLnVudXNlZEJpdHMgPSAwO1xuICAgICAgICB0aGlzLnZhbHVlID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbU51bWJlcihwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHZ0c3V0aWxzXzEuQnVmZmVyU291cmNlQ29udmVydGVyLmlzQnVmZmVyU291cmNlKHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVudXNlZEJpdHMgPSB1bnVzZWRCaXRzO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBwdnRzdXRpbHNfMS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiVW5zdXBwb3J0ZWQgdHlwZSBvZiAncGFyYW1zJyBhcmd1bWVudCBmb3IgQml0U3RyaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21BU04oYXNuKSB7XG4gICAgICAgIGlmICghKGFzbiBpbnN0YW5jZW9mIGFzbjFqcy5CaXRTdHJpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgJ2FzbicgaXMgbm90IGluc3RhbmNlIG9mIEFTTi4xIEJpdFN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVudXNlZEJpdHMgPSBhc24udmFsdWVCbG9jay51bnVzZWRCaXRzO1xuICAgICAgICB0aGlzLnZhbHVlID0gYXNuLnZhbHVlQmxvY2sudmFsdWVIZXg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b0FTTigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhc24xanMuQml0U3RyaW5nKHsgdW51c2VkQml0czogdGhpcy51bnVzZWRCaXRzLCB2YWx1ZUhleDogdGhpcy52YWx1ZSB9KTtcbiAgICB9XG4gICAgdG9TY2hlbWEobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5CaXRTdHJpbmcoeyBuYW1lIH0pO1xuICAgIH1cbiAgICB0b051bWJlcigpIHtcbiAgICAgICAgbGV0IHJlcyA9IFwiXCI7XG4gICAgICAgIGNvbnN0IHVpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRoaXMudmFsdWUpO1xuICAgICAgICBmb3IgKGNvbnN0IG9jdGV0IG9mIHVpbnRBcnJheSkge1xuICAgICAgICAgICAgcmVzICs9IG9jdGV0LnRvU3RyaW5nKDIpLnBhZFN0YXJ0KDgsIFwiMFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSByZXMuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG4gICAgICAgIGlmICh0aGlzLnVudXNlZEJpdHMpIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcy5zbGljZSh0aGlzLnVudXNlZEJpdHMpLnBhZFN0YXJ0KHRoaXMudW51c2VkQml0cywgXCIwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUludChyZXMsIDIpO1xuICAgIH1cbiAgICBmcm9tTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIGxldCBiaXRzID0gdmFsdWUudG9TdHJpbmcoMik7XG4gICAgICAgIGNvbnN0IG9jdGV0U2l6ZSA9IChiaXRzLmxlbmd0aCArIDcpID4+IDM7XG4gICAgICAgIHRoaXMudW51c2VkQml0cyA9IChvY3RldFNpemUgPDwgMykgLSBiaXRzLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgb2N0ZXRzID0gbmV3IFVpbnQ4QXJyYXkob2N0ZXRTaXplKTtcbiAgICAgICAgYml0cyA9IGJpdHMucGFkU3RhcnQob2N0ZXRTaXplIDw8IDMsIFwiMFwiKS5zcGxpdChcIlwiKS5yZXZlcnNlKCkuam9pbihcIlwiKTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgb2N0ZXRTaXplKSB7XG4gICAgICAgICAgICBvY3RldHNbaW5kZXhdID0gcGFyc2VJbnQoYml0cy5zbGljZShpbmRleCA8PCAzLCAoaW5kZXggPDwgMykgKyA4KSwgMik7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSBvY3RldHMuYnVmZmVyO1xuICAgIH1cbn1cbmV4cG9ydHMuQml0U3RyaW5nID0gQml0U3RyaW5nO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQml0U3RyaW5nIiwiYXNuMWpzIiwicmVxdWlyZSIsInB2dHN1dGlsc18xIiwiY29uc3RydWN0b3IiLCJwYXJhbXMiLCJ1bnVzZWRCaXRzIiwiQXJyYXlCdWZmZXIiLCJmcm9tTnVtYmVyIiwiQnVmZmVyU291cmNlQ29udmVydGVyIiwiaXNCdWZmZXJTb3VyY2UiLCJ0b0FycmF5QnVmZmVyIiwiVHlwZUVycm9yIiwiZnJvbUFTTiIsImFzbiIsInZhbHVlQmxvY2siLCJ2YWx1ZUhleCIsInRvQVNOIiwidG9TY2hlbWEiLCJuYW1lIiwidG9OdW1iZXIiLCJyZXMiLCJ1aW50QXJyYXkiLCJVaW50OEFycmF5Iiwib2N0ZXQiLCJ0b1N0cmluZyIsInBhZFN0YXJ0Iiwic3BsaXQiLCJyZXZlcnNlIiwiam9pbiIsInNsaWNlIiwicGFyc2VJbnQiLCJiaXRzIiwib2N0ZXRTaXplIiwibGVuZ3RoIiwib2N0ZXRzIiwiaW5kZXgiLCJidWZmZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BitString = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(rsc)/./node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(rsc)/./node_modules/pvtsutils/build/index.js\");\nclass BitString {\n    constructor(params, unusedBits = 0){\n        this.unusedBits = 0;\n        this.value = new ArrayBuffer(0);\n        if (params) {\n            if (typeof params === \"number\") {\n                this.fromNumber(params);\n            } else if (pvtsutils_1.BufferSourceConverter.isBufferSource(params)) {\n                this.unusedBits = unusedBits;\n                this.value = pvtsutils_1.BufferSourceConverter.toArrayBuffer(params);\n            } else {\n                throw TypeError(\"Unsupported type of 'params' argument for BitString\");\n            }\n        }\n    }\n    fromASN(asn) {\n        if (!(asn instanceof asn1js.BitString)) {\n            throw new TypeError(\"Argument 'asn' is not instance of ASN.1 BitString\");\n        }\n        this.unusedBits = asn.valueBlock.unusedBits;\n        this.value = asn.valueBlock.valueHex;\n        return this;\n    }\n    toASN() {\n        return new asn1js.BitString({\n            unusedBits: this.unusedBits,\n            valueHex: this.value\n        });\n    }\n    toSchema(name) {\n        return new asn1js.BitString({\n            name\n        });\n    }\n    toNumber() {\n        let res = \"\";\n        const uintArray = new Uint8Array(this.value);\n        for (const octet of uintArray){\n            res += octet.toString(2).padStart(8, \"0\");\n        }\n        res = res.split(\"\").reverse().join(\"\");\n        if (this.unusedBits) {\n            res = res.slice(this.unusedBits).padStart(this.unusedBits, \"0\");\n        }\n        return parseInt(res, 2);\n    }\n    fromNumber(value) {\n        let bits = value.toString(2);\n        const octetSize = bits.length + 7 >> 3;\n        this.unusedBits = (octetSize << 3) - bits.length;\n        const octets = new Uint8Array(octetSize);\n        bits = bits.padStart(octetSize << 3, \"0\").split(\"\").reverse().join(\"\");\n        let index = 0;\n        while(index < octetSize){\n            octets[index] = parseInt(bits.slice(index << 3, (index << 3) + 8), 2);\n            index++;\n        }\n        this.value = octets.buffer;\n    }\n}\nexports.BitString = BitString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy90eXBlcy9iaXRfc3RyaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBRyxLQUFLO0FBQ3pCLE1BQU1HLFNBQVNDLG1CQUFPQSxDQUFDLDBEQUFRO0FBQy9CLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLGdFQUFXO0FBQ3ZDLE1BQU1GO0lBQ0ZJLFlBQVlDLE1BQU0sRUFBRUMsYUFBYSxDQUFDLENBQUU7UUFDaEMsSUFBSSxDQUFDQSxVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDUCxLQUFLLEdBQUcsSUFBSVEsWUFBWTtRQUM3QixJQUFJRixRQUFRO1lBQ1IsSUFBSSxPQUFPQSxXQUFXLFVBQVU7Z0JBQzVCLElBQUksQ0FBQ0csVUFBVSxDQUFDSDtZQUNwQixPQUNLLElBQUlGLFlBQVlNLHFCQUFxQixDQUFDQyxjQUFjLENBQUNMLFNBQVM7Z0JBQy9ELElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtnQkFDbEIsSUFBSSxDQUFDUCxLQUFLLEdBQUdJLFlBQVlNLHFCQUFxQixDQUFDRSxhQUFhLENBQUNOO1lBQ2pFLE9BQ0s7Z0JBQ0QsTUFBTU8sVUFBVTtZQUNwQjtRQUNKO0lBQ0o7SUFDQUMsUUFBUUMsR0FBRyxFQUFFO1FBQ1QsSUFBSSxDQUFFQSxDQUFBQSxlQUFlYixPQUFPRCxTQUFTLEdBQUc7WUFDcEMsTUFBTSxJQUFJWSxVQUFVO1FBQ3hCO1FBQ0EsSUFBSSxDQUFDTixVQUFVLEdBQUdRLElBQUlDLFVBQVUsQ0FBQ1QsVUFBVTtRQUMzQyxJQUFJLENBQUNQLEtBQUssR0FBR2UsSUFBSUMsVUFBVSxDQUFDQyxRQUFRO1FBQ3BDLE9BQU8sSUFBSTtJQUNmO0lBQ0FDLFFBQVE7UUFDSixPQUFPLElBQUloQixPQUFPRCxTQUFTLENBQUM7WUFBRU0sWUFBWSxJQUFJLENBQUNBLFVBQVU7WUFBRVUsVUFBVSxJQUFJLENBQUNqQixLQUFLO1FBQUM7SUFDcEY7SUFDQW1CLFNBQVNDLElBQUksRUFBRTtRQUNYLE9BQU8sSUFBSWxCLE9BQU9ELFNBQVMsQ0FBQztZQUFFbUI7UUFBSztJQUN2QztJQUNBQyxXQUFXO1FBQ1AsSUFBSUMsTUFBTTtRQUNWLE1BQU1DLFlBQVksSUFBSUMsV0FBVyxJQUFJLENBQUN4QixLQUFLO1FBQzNDLEtBQUssTUFBTXlCLFNBQVNGLFVBQVc7WUFDM0JELE9BQU9HLE1BQU1DLFFBQVEsQ0FBQyxHQUFHQyxRQUFRLENBQUMsR0FBRztRQUN6QztRQUNBTCxNQUFNQSxJQUFJTSxLQUFLLENBQUMsSUFBSUMsT0FBTyxHQUFHQyxJQUFJLENBQUM7UUFDbkMsSUFBSSxJQUFJLENBQUN2QixVQUFVLEVBQUU7WUFDakJlLE1BQU1BLElBQUlTLEtBQUssQ0FBQyxJQUFJLENBQUN4QixVQUFVLEVBQUVvQixRQUFRLENBQUMsSUFBSSxDQUFDcEIsVUFBVSxFQUFFO1FBQy9EO1FBQ0EsT0FBT3lCLFNBQVNWLEtBQUs7SUFDekI7SUFDQWIsV0FBV1QsS0FBSyxFQUFFO1FBQ2QsSUFBSWlDLE9BQU9qQyxNQUFNMEIsUUFBUSxDQUFDO1FBQzFCLE1BQU1RLFlBQVksS0FBTUMsTUFBTSxHQUFHLEtBQU07UUFDdkMsSUFBSSxDQUFDNUIsVUFBVSxHQUFHLENBQUMyQixhQUFhLEtBQUtELEtBQUtFLE1BQU07UUFDaEQsTUFBTUMsU0FBUyxJQUFJWixXQUFXVTtRQUM5QkQsT0FBT0EsS0FBS04sUUFBUSxDQUFDTyxhQUFhLEdBQUcsS0FBS04sS0FBSyxDQUFDLElBQUlDLE9BQU8sR0FBR0MsSUFBSSxDQUFDO1FBQ25FLElBQUlPLFFBQVE7UUFDWixNQUFPQSxRQUFRSCxVQUFXO1lBQ3RCRSxNQUFNLENBQUNDLE1BQU0sR0FBR0wsU0FBU0MsS0FBS0YsS0FBSyxDQUFDTSxTQUFTLEdBQUcsQ0FBQ0EsU0FBUyxLQUFLLElBQUk7WUFDbkVBO1FBQ0o7UUFDQSxJQUFJLENBQUNyQyxLQUFLLEdBQUdvQyxPQUFPRSxNQUFNO0lBQzlCO0FBQ0o7QUFDQXZDLGlCQUFpQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1ha2V0cGxhY2UtYWRtaW4vLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy90eXBlcy9iaXRfc3RyaW5nLmpzPzM3ZDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJpdFN0cmluZyA9IHZvaWQgMDtcbmNvbnN0IGFzbjFqcyA9IHJlcXVpcmUoXCJhc24xanNcIik7XG5jb25zdCBwdnRzdXRpbHNfMSA9IHJlcXVpcmUoXCJwdnRzdXRpbHNcIik7XG5jbGFzcyBCaXRTdHJpbmcge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcywgdW51c2VkQml0cyA9IDApIHtcbiAgICAgICAgdGhpcy51bnVzZWRCaXRzID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb21OdW1iZXIocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHB2dHN1dGlsc18xLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci5pc0J1ZmZlclNvdXJjZShwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnVzZWRCaXRzID0gdW51c2VkQml0cztcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gcHZ0c3V0aWxzXzEuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIHR5cGUgb2YgJ3BhcmFtcycgYXJndW1lbnQgZm9yIEJpdFN0cmluZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmcm9tQVNOKGFzbikge1xuICAgICAgICBpZiAoIShhc24gaW5zdGFuY2VvZiBhc24xanMuQml0U3RyaW5nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50ICdhc24nIGlzIG5vdCBpbnN0YW5jZSBvZiBBU04uMSBCaXRTdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bnVzZWRCaXRzID0gYXNuLnZhbHVlQmxvY2sudW51c2VkQml0cztcbiAgICAgICAgdGhpcy52YWx1ZSA9IGFzbi52YWx1ZUJsb2NrLnZhbHVlSGV4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9BU04oKSB7XG4gICAgICAgIHJldHVybiBuZXcgYXNuMWpzLkJpdFN0cmluZyh7IHVudXNlZEJpdHM6IHRoaXMudW51c2VkQml0cywgdmFsdWVIZXg6IHRoaXMudmFsdWUgfSk7XG4gICAgfVxuICAgIHRvU2NoZW1hKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBhc24xanMuQml0U3RyaW5nKHsgbmFtZSB9KTtcbiAgICB9XG4gICAgdG9OdW1iZXIoKSB7XG4gICAgICAgIGxldCByZXMgPSBcIlwiO1xuICAgICAgICBjb25zdCB1aW50QXJyYXkgPSBuZXcgVWludDhBcnJheSh0aGlzLnZhbHVlKTtcbiAgICAgICAgZm9yIChjb25zdCBvY3RldCBvZiB1aW50QXJyYXkpIHtcbiAgICAgICAgICAgIHJlcyArPSBvY3RldC50b1N0cmluZygyKS5wYWRTdGFydCg4LCBcIjBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gcmVzLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgICAgICBpZiAodGhpcy51bnVzZWRCaXRzKSB7XG4gICAgICAgICAgICByZXMgPSByZXMuc2xpY2UodGhpcy51bnVzZWRCaXRzKS5wYWRTdGFydCh0aGlzLnVudXNlZEJpdHMsIFwiMFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VJbnQocmVzLCAyKTtcbiAgICB9XG4gICAgZnJvbU51bWJlcih2YWx1ZSkge1xuICAgICAgICBsZXQgYml0cyA9IHZhbHVlLnRvU3RyaW5nKDIpO1xuICAgICAgICBjb25zdCBvY3RldFNpemUgPSAoYml0cy5sZW5ndGggKyA3KSA+PiAzO1xuICAgICAgICB0aGlzLnVudXNlZEJpdHMgPSAob2N0ZXRTaXplIDw8IDMpIC0gYml0cy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG9jdGV0cyA9IG5ldyBVaW50OEFycmF5KG9jdGV0U2l6ZSk7XG4gICAgICAgIGJpdHMgPSBiaXRzLnBhZFN0YXJ0KG9jdGV0U2l6ZSA8PCAzLCBcIjBcIikuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IG9jdGV0U2l6ZSkge1xuICAgICAgICAgICAgb2N0ZXRzW2luZGV4XSA9IHBhcnNlSW50KGJpdHMuc2xpY2UoaW5kZXggPDwgMywgKGluZGV4IDw8IDMpICsgOCksIDIpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gb2N0ZXRzLmJ1ZmZlcjtcbiAgICB9XG59XG5leHBvcnRzLkJpdFN0cmluZyA9IEJpdFN0cmluZztcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJpdFN0cmluZyIsImFzbjFqcyIsInJlcXVpcmUiLCJwdnRzdXRpbHNfMSIsImNvbnN0cnVjdG9yIiwicGFyYW1zIiwidW51c2VkQml0cyIsIkFycmF5QnVmZmVyIiwiZnJvbU51bWJlciIsIkJ1ZmZlclNvdXJjZUNvbnZlcnRlciIsImlzQnVmZmVyU291cmNlIiwidG9BcnJheUJ1ZmZlciIsIlR5cGVFcnJvciIsImZyb21BU04iLCJhc24iLCJ2YWx1ZUJsb2NrIiwidmFsdWVIZXgiLCJ0b0FTTiIsInRvU2NoZW1hIiwibmFtZSIsInRvTnVtYmVyIiwicmVzIiwidWludEFycmF5IiwiVWludDhBcnJheSIsIm9jdGV0IiwidG9TdHJpbmciLCJwYWRTdGFydCIsInNwbGl0IiwicmV2ZXJzZSIsImpvaW4iLCJzbGljZSIsInBhcnNlSW50IiwiYml0cyIsIm9jdGV0U2l6ZSIsImxlbmd0aCIsIm9jdGV0cyIsImluZGV4IiwiYnVmZmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(action-browser)/./node_modules/tslib/tslib.es6.mjs\");\ntslib_1.__exportStar(__webpack_require__(/*! ./bit_string */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./octet_string */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3R5cGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLGtFQUFPO0FBQy9CRCxRQUFRRSxZQUFZLENBQUNELG1CQUFPQSxDQUFDLHlHQUFjLEdBQUdIO0FBQzlDRSxRQUFRRSxZQUFZLENBQUNELG1CQUFPQSxDQUFDLDZHQUFnQixHQUFHSCIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1ha2V0cGxhY2UtYWRtaW4vLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy90eXBlcy9pbmRleC5qcz81YjVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2JpdF9zdHJpbmdcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb2N0ZXRfc3RyaW5nXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRzbGliXzEiLCJyZXF1aXJlIiwiX19leHBvcnRTdGFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\ntslib_1.__exportStar(__webpack_require__(/*! ./bit_string */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/types/bit_string.js\"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./octet_string */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy90eXBlcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RCxNQUFNQyxVQUFVQyxtQkFBT0EsQ0FBQyx1REFBTztBQUMvQkQsUUFBUUUsWUFBWSxDQUFDRCxtQkFBT0EsQ0FBQyw4RkFBYyxHQUFHSDtBQUM5Q0UsUUFBUUUsWUFBWSxDQUFDRCxtQkFBT0EsQ0FBQyxrR0FBZ0IsR0FBR0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYWtldHBsYWNlLWFkbWluLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9hc24xLXNjaGVtYS9idWlsZC9janMvdHlwZXMvaW5kZXguanM/NWI1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9iaXRfc3RyaW5nXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL29jdGV0X3N0cmluZ1wiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0c2xpYl8xIiwicmVxdWlyZSIsIl9fZXhwb3J0U3RhciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/types/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.OctetString = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(action-browser)/./node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(action-browser)/./node_modules/pvtsutils/build/index.js\");\nclass OctetString {\n    constructor(param){\n        if (typeof param === \"number\") {\n            this.buffer = new ArrayBuffer(param);\n        } else {\n            if (pvtsutils_1.BufferSourceConverter.isBufferSource(param)) {\n                this.buffer = pvtsutils_1.BufferSourceConverter.toArrayBuffer(param);\n            } else if (Array.isArray(param)) {\n                this.buffer = new Uint8Array(param);\n            } else {\n                this.buffer = new ArrayBuffer(0);\n            }\n        }\n    }\n    get byteLength() {\n        return this.buffer.byteLength;\n    }\n    get byteOffset() {\n        return 0;\n    }\n    fromASN(asn) {\n        if (!(asn instanceof asn1js.OctetString)) {\n            throw new TypeError(\"Argument 'asn' is not instance of ASN.1 OctetString\");\n        }\n        this.buffer = asn.valueBlock.valueHex;\n        return this;\n    }\n    toASN() {\n        return new asn1js.OctetString({\n            valueHex: this.buffer\n        });\n    }\n    toSchema(name) {\n        return new asn1js.OctetString({\n            name\n        });\n    }\n}\nexports.OctetString = OctetString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3R5cGVzL29jdGV0X3N0cmluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUcsS0FBSztBQUMzQixNQUFNRyxTQUFTQyxtQkFBT0EsQ0FBQyxxRUFBUTtBQUMvQixNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQywyRUFBVztBQUN2QyxNQUFNRjtJQUNGSSxZQUFZQyxLQUFLLENBQUU7UUFDZixJQUFJLE9BQU9BLFVBQVUsVUFBVTtZQUMzQixJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJQyxZQUFZRjtRQUNsQyxPQUNLO1lBQ0QsSUFBSUYsWUFBWUsscUJBQXFCLENBQUNDLGNBQWMsQ0FBQ0osUUFBUTtnQkFDekQsSUFBSSxDQUFDQyxNQUFNLEdBQUdILFlBQVlLLHFCQUFxQixDQUFDRSxhQUFhLENBQUNMO1lBQ2xFLE9BQ0ssSUFBSU0sTUFBTUMsT0FBTyxDQUFDUCxRQUFRO2dCQUMzQixJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJTyxXQUFXUjtZQUNqQyxPQUNLO2dCQUNELElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUlDLFlBQVk7WUFDbEM7UUFDSjtJQUNKO0lBQ0EsSUFBSU8sYUFBYTtRQUNiLE9BQU8sSUFBSSxDQUFDUixNQUFNLENBQUNRLFVBQVU7SUFDakM7SUFDQSxJQUFJQyxhQUFhO1FBQ2IsT0FBTztJQUNYO0lBQ0FDLFFBQVFDLEdBQUcsRUFBRTtRQUNULElBQUksQ0FBRUEsQ0FBQUEsZUFBZWhCLE9BQU9ELFdBQVcsR0FBRztZQUN0QyxNQUFNLElBQUlrQixVQUFVO1FBQ3hCO1FBQ0EsSUFBSSxDQUFDWixNQUFNLEdBQUdXLElBQUlFLFVBQVUsQ0FBQ0MsUUFBUTtRQUNyQyxPQUFPLElBQUk7SUFDZjtJQUNBQyxRQUFRO1FBQ0osT0FBTyxJQUFJcEIsT0FBT0QsV0FBVyxDQUFDO1lBQUVvQixVQUFVLElBQUksQ0FBQ2QsTUFBTTtRQUFDO0lBQzFEO0lBQ0FnQixTQUFTQyxJQUFJLEVBQUU7UUFDWCxPQUFPLElBQUl0QixPQUFPRCxXQUFXLENBQUM7WUFBRXVCO1FBQUs7SUFDekM7QUFDSjtBQUNBekIsbUJBQW1CLEdBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktbWFrZXRwbGFjZS1hZG1pbi8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvYXNuMS1zY2hlbWEvYnVpbGQvY2pzL3R5cGVzL29jdGV0X3N0cmluZy5qcz9hYTA1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PY3RldFN0cmluZyA9IHZvaWQgMDtcbmNvbnN0IGFzbjFqcyA9IHJlcXVpcmUoXCJhc24xanNcIik7XG5jb25zdCBwdnRzdXRpbHNfMSA9IHJlcXVpcmUoXCJwdnRzdXRpbHNcIik7XG5jbGFzcyBPY3RldFN0cmluZyB7XG4gICAgY29uc3RydWN0b3IocGFyYW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIocGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHB2dHN1dGlsc18xLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci5pc0J1ZmZlclNvdXJjZShwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHB2dHN1dGlsc18xLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShwYXJhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYnl0ZUxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGdldCBieXRlT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZnJvbUFTTihhc24pIHtcbiAgICAgICAgaWYgKCEoYXNuIGluc3RhbmNlb2YgYXNuMWpzLk9jdGV0U3RyaW5nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50ICdhc24nIGlzIG5vdCBpbnN0YW5jZSBvZiBBU04uMSBPY3RldFN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IGFzbi52YWx1ZUJsb2NrLnZhbHVlSGV4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9BU04oKSB7XG4gICAgICAgIHJldHVybiBuZXcgYXNuMWpzLk9jdGV0U3RyaW5nKHsgdmFsdWVIZXg6IHRoaXMuYnVmZmVyIH0pO1xuICAgIH1cbiAgICB0b1NjaGVtYShuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgYXNuMWpzLk9jdGV0U3RyaW5nKHsgbmFtZSB9KTtcbiAgICB9XG59XG5leHBvcnRzLk9jdGV0U3RyaW5nID0gT2N0ZXRTdHJpbmc7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJPY3RldFN0cmluZyIsImFzbjFqcyIsInJlcXVpcmUiLCJwdnRzdXRpbHNfMSIsImNvbnN0cnVjdG9yIiwicGFyYW0iLCJidWZmZXIiLCJBcnJheUJ1ZmZlciIsIkJ1ZmZlclNvdXJjZUNvbnZlcnRlciIsImlzQnVmZmVyU291cmNlIiwidG9BcnJheUJ1ZmZlciIsIkFycmF5IiwiaXNBcnJheSIsIlVpbnQ4QXJyYXkiLCJieXRlTGVuZ3RoIiwiYnl0ZU9mZnNldCIsImZyb21BU04iLCJhc24iLCJUeXBlRXJyb3IiLCJ2YWx1ZUJsb2NrIiwidmFsdWVIZXgiLCJ0b0FTTiIsInRvU2NoZW1hIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.OctetString = void 0;\nconst asn1js = __webpack_require__(/*! asn1js */ \"(rsc)/./node_modules/asn1js/build/index.js\");\nconst pvtsutils_1 = __webpack_require__(/*! pvtsutils */ \"(rsc)/./node_modules/pvtsutils/build/index.js\");\nclass OctetString {\n    constructor(param){\n        if (typeof param === \"number\") {\n            this.buffer = new ArrayBuffer(param);\n        } else {\n            if (pvtsutils_1.BufferSourceConverter.isBufferSource(param)) {\n                this.buffer = pvtsutils_1.BufferSourceConverter.toArrayBuffer(param);\n            } else if (Array.isArray(param)) {\n                this.buffer = new Uint8Array(param);\n            } else {\n                this.buffer = new ArrayBuffer(0);\n            }\n        }\n    }\n    get byteLength() {\n        return this.buffer.byteLength;\n    }\n    get byteOffset() {\n        return 0;\n    }\n    fromASN(asn) {\n        if (!(asn instanceof asn1js.OctetString)) {\n            throw new TypeError(\"Argument 'asn' is not instance of ASN.1 OctetString\");\n        }\n        this.buffer = asn.valueBlock.valueHex;\n        return this;\n    }\n    toASN() {\n        return new asn1js.OctetString({\n            valueHex: this.buffer\n        });\n    }\n    toSchema(name) {\n        return new asn1js.OctetString({\n            name\n        });\n    }\n}\nexports.OctetString = OctetString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy90eXBlcy9vY3RldF9zdHJpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1CQUFtQixHQUFHLEtBQUs7QUFDM0IsTUFBTUcsU0FBU0MsbUJBQU9BLENBQUMsMERBQVE7QUFDL0IsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsZ0VBQVc7QUFDdkMsTUFBTUY7SUFDRkksWUFBWUMsS0FBSyxDQUFFO1FBQ2YsSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDM0IsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSUMsWUFBWUY7UUFDbEMsT0FDSztZQUNELElBQUlGLFlBQVlLLHFCQUFxQixDQUFDQyxjQUFjLENBQUNKLFFBQVE7Z0JBQ3pELElBQUksQ0FBQ0MsTUFBTSxHQUFHSCxZQUFZSyxxQkFBcUIsQ0FBQ0UsYUFBYSxDQUFDTDtZQUNsRSxPQUNLLElBQUlNLE1BQU1DLE9BQU8sQ0FBQ1AsUUFBUTtnQkFDM0IsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSU8sV0FBV1I7WUFDakMsT0FDSztnQkFDRCxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJQyxZQUFZO1lBQ2xDO1FBQ0o7SUFDSjtJQUNBLElBQUlPLGFBQWE7UUFDYixPQUFPLElBQUksQ0FBQ1IsTUFBTSxDQUFDUSxVQUFVO0lBQ2pDO0lBQ0EsSUFBSUMsYUFBYTtRQUNiLE9BQU87SUFDWDtJQUNBQyxRQUFRQyxHQUFHLEVBQUU7UUFDVCxJQUFJLENBQUVBLENBQUFBLGVBQWVoQixPQUFPRCxXQUFXLEdBQUc7WUFDdEMsTUFBTSxJQUFJa0IsVUFBVTtRQUN4QjtRQUNBLElBQUksQ0FBQ1osTUFBTSxHQUFHVyxJQUFJRSxVQUFVLENBQUNDLFFBQVE7UUFDckMsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMsUUFBUTtRQUNKLE9BQU8sSUFBSXBCLE9BQU9ELFdBQVcsQ0FBQztZQUFFb0IsVUFBVSxJQUFJLENBQUNkLE1BQU07UUFBQztJQUMxRDtJQUNBZ0IsU0FBU0MsSUFBSSxFQUFFO1FBQ1gsT0FBTyxJQUFJdEIsT0FBT0QsV0FBVyxDQUFDO1lBQUV1QjtRQUFLO0lBQ3pDO0FBQ0o7QUFDQXpCLG1CQUFtQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1ha2V0cGxhY2UtYWRtaW4vLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2FzbjEtc2NoZW1hL2J1aWxkL2Nqcy90eXBlcy9vY3RldF9zdHJpbmcuanM/YWEwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT2N0ZXRTdHJpbmcgPSB2b2lkIDA7XG5jb25zdCBhc24xanMgPSByZXF1aXJlKFwiYXNuMWpzXCIpO1xuY29uc3QgcHZ0c3V0aWxzXzEgPSByZXF1aXJlKFwicHZ0c3V0aWxzXCIpO1xuY2xhc3MgT2N0ZXRTdHJpbmcge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwdnRzdXRpbHNfMS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIuaXNCdWZmZXJTb3VyY2UocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBwdnRzdXRpbHNfMS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihwYXJhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhcmFtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkocGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGJ5dGVMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgYnl0ZU9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZyb21BU04oYXNuKSB7XG4gICAgICAgIGlmICghKGFzbiBpbnN0YW5jZW9mIGFzbjFqcy5PY3RldFN0cmluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCAnYXNuJyBpcyBub3QgaW5zdGFuY2Ugb2YgQVNOLjEgT2N0ZXRTdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXIgPSBhc24udmFsdWVCbG9jay52YWx1ZUhleDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvQVNOKCkge1xuICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5PY3RldFN0cmluZyh7IHZhbHVlSGV4OiB0aGlzLmJ1ZmZlciB9KTtcbiAgICB9XG4gICAgdG9TY2hlbWEobmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IGFzbjFqcy5PY3RldFN0cmluZyh7IG5hbWUgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5PY3RldFN0cmluZyA9IE9jdGV0U3RyaW5nO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiT2N0ZXRTdHJpbmciLCJhc24xanMiLCJyZXF1aXJlIiwicHZ0c3V0aWxzXzEiLCJjb25zdHJ1Y3RvciIsInBhcmFtIiwiYnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJCdWZmZXJTb3VyY2VDb252ZXJ0ZXIiLCJpc0J1ZmZlclNvdXJjZSIsInRvQXJyYXlCdWZmZXIiLCJBcnJheSIsImlzQXJyYXkiLCJVaW50OEFycmF5IiwiYnl0ZUxlbmd0aCIsImJ5dGVPZmZzZXQiLCJmcm9tQVNOIiwiYXNuIiwiVHlwZUVycm9yIiwidmFsdWVCbG9jayIsInZhbHVlSGV4IiwidG9BU04iLCJ0b1NjaGVtYSIsIm5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/types/octet_string.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@peculiar/json-schema/build/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@peculiar/json-schema/build/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Copyright (c) 2020, Peculiar Ventures, All rights reserved.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nclass JsonError extends Error {\n    constructor(message, innerError){\n        super(innerError ? `${message}. See the inner exception for more details.` : message);\n        this.message = message;\n        this.innerError = innerError;\n    }\n}\nclass TransformError extends JsonError {\n    constructor(schema, message, innerError){\n        super(message, innerError);\n        this.schema = schema;\n    }\n}\nclass ParserError extends TransformError {\n    constructor(schema, message, innerError){\n        super(schema, `JSON doesn't match to '${schema.target.name}' schema. ${message}`, innerError);\n    }\n}\nclass ValidationError extends JsonError {\n}\nclass SerializerError extends JsonError {\n    constructor(schemaName, message, innerError){\n        super(`Cannot serialize by '${schemaName}' schema. ${message}`, innerError);\n        this.schemaName = schemaName;\n    }\n}\nclass KeyError extends ParserError {\n    constructor(schema, keys, errors = {}){\n        super(schema, \"Some keys doesn't match to schema\");\n        this.keys = keys;\n        this.errors = errors;\n    }\n}\n(function(JsonPropTypes) {\n    JsonPropTypes[JsonPropTypes[\"Any\"] = 0] = \"Any\";\n    JsonPropTypes[JsonPropTypes[\"Boolean\"] = 1] = \"Boolean\";\n    JsonPropTypes[JsonPropTypes[\"Number\"] = 2] = \"Number\";\n    JsonPropTypes[JsonPropTypes[\"String\"] = 3] = \"String\";\n})(exports.JsonPropTypes || (exports.JsonPropTypes = {}));\nfunction checkType(value, type) {\n    switch(type){\n        case exports.JsonPropTypes.Boolean:\n            return typeof value === \"boolean\";\n        case exports.JsonPropTypes.Number:\n            return typeof value === \"number\";\n        case exports.JsonPropTypes.String:\n            return typeof value === \"string\";\n    }\n    return true;\n}\nfunction throwIfTypeIsWrong(value, type) {\n    if (!checkType(value, type)) {\n        throw new TypeError(`Value must be ${exports.JsonPropTypes[type]}`);\n    }\n}\nfunction isConvertible(target) {\n    if (target && target.prototype) {\n        if (target.prototype.toJSON && target.prototype.fromJSON) {\n            return true;\n        } else {\n            return isConvertible(target.prototype);\n        }\n    } else {\n        return !!(target && target.toJSON && target.fromJSON);\n    }\n}\nclass JsonSchemaStorage {\n    constructor(){\n        this.items = new Map();\n    }\n    has(target) {\n        return this.items.has(target) || !!this.findParentSchema(target);\n    }\n    get(target) {\n        const schema = this.items.get(target) || this.findParentSchema(target);\n        if (!schema) {\n            throw new Error(\"Cannot get schema for current target\");\n        }\n        return schema;\n    }\n    create(target) {\n        const schema = {\n            names: {}\n        };\n        const parentSchema = this.findParentSchema(target);\n        if (parentSchema) {\n            Object.assign(schema, parentSchema);\n            schema.names = {};\n            for(const name in parentSchema.names){\n                schema.names[name] = Object.assign({}, parentSchema.names[name]);\n            }\n        }\n        schema.target = target;\n        return schema;\n    }\n    set(target, schema) {\n        this.items.set(target, schema);\n        return this;\n    }\n    findParentSchema(target) {\n        const parent = target.__proto__;\n        if (parent) {\n            const schema = this.items.get(parent);\n            return schema || this.findParentSchema(parent);\n        }\n        return null;\n    }\n}\nconst DEFAULT_SCHEMA = \"default\";\nconst schemaStorage = new JsonSchemaStorage();\nclass PatternValidation {\n    constructor(pattern){\n        this.pattern = new RegExp(pattern);\n    }\n    validate(value) {\n        const pattern = new RegExp(this.pattern.source, this.pattern.flags);\n        if (typeof value !== \"string\") {\n            throw new ValidationError(\"Incoming value must be string\");\n        }\n        if (!pattern.exec(value)) {\n            throw new ValidationError(`Value doesn't match to pattern '${pattern.toString()}'`);\n        }\n    }\n}\nclass InclusiveValidation {\n    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE){\n        this.min = min;\n        this.max = max;\n    }\n    validate(value) {\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.Number);\n        if (!(this.min <= value && value <= this.max)) {\n            const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\n            const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\n            throw new ValidationError(`Value doesn't match to diapason [${min},${max}]`);\n        }\n    }\n}\nclass ExclusiveValidation {\n    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE){\n        this.min = min;\n        this.max = max;\n    }\n    validate(value) {\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.Number);\n        if (!(this.min < value && value < this.max)) {\n            const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\n            const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\n            throw new ValidationError(`Value doesn't match to diapason (${min},${max})`);\n        }\n    }\n}\nclass LengthValidation {\n    constructor(length, minLength, maxLength){\n        this.length = length;\n        this.minLength = minLength;\n        this.maxLength = maxLength;\n    }\n    validate(value) {\n        if (this.length !== undefined) {\n            if (value.length !== this.length) {\n                throw new ValidationError(`Value length must be exactly ${this.length}.`);\n            }\n            return;\n        }\n        if (this.minLength !== undefined) {\n            if (value.length < this.minLength) {\n                throw new ValidationError(`Value length must be more than ${this.minLength}.`);\n            }\n        }\n        if (this.maxLength !== undefined) {\n            if (value.length > this.maxLength) {\n                throw new ValidationError(`Value length must be less than ${this.maxLength}.`);\n            }\n        }\n    }\n}\nclass EnumerationValidation {\n    constructor(enumeration){\n        this.enumeration = enumeration;\n    }\n    validate(value) {\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.String);\n        if (!this.enumeration.includes(value)) {\n            throw new ValidationError(`Value must be one of ${this.enumeration.map((v)=>`'${v}'`).join(\", \")}`);\n        }\n    }\n}\nclass JsonTransform {\n    static checkValues(data, schemaItem) {\n        const values = Array.isArray(data) ? data : [\n            data\n        ];\n        for (const value of values){\n            for (const validation of schemaItem.validations){\n                if (validation instanceof LengthValidation && schemaItem.repeated) {\n                    validation.validate(data);\n                } else {\n                    validation.validate(value);\n                }\n            }\n        }\n    }\n    static checkTypes(value, schemaItem) {\n        if (schemaItem.repeated && !Array.isArray(value)) {\n            throw new TypeError(\"Value must be Array\");\n        }\n        if (typeof schemaItem.type === \"number\") {\n            const values = Array.isArray(value) ? value : [\n                value\n            ];\n            for (const v of values){\n                throwIfTypeIsWrong(v, schemaItem.type);\n            }\n        }\n    }\n    static getSchemaByName(schema, name = DEFAULT_SCHEMA) {\n        return {\n            ...schema.names[DEFAULT_SCHEMA],\n            ...schema.names[name]\n        };\n    }\n}\nclass JsonSerializer extends JsonTransform {\n    static serialize(obj, options, replacer, space) {\n        const json = this.toJSON(obj, options);\n        return JSON.stringify(json, replacer, space);\n    }\n    static toJSON(obj, options = {}) {\n        let res;\n        let targetSchema = options.targetSchema;\n        const schemaName = options.schemaName || DEFAULT_SCHEMA;\n        if (isConvertible(obj)) {\n            return obj.toJSON();\n        }\n        if (Array.isArray(obj)) {\n            res = [];\n            for (const item of obj){\n                res.push(this.toJSON(item, options));\n            }\n        } else if (typeof obj === \"object\") {\n            if (targetSchema && !schemaStorage.has(targetSchema)) {\n                throw new JsonError(\"Cannot get schema for `targetSchema` param\");\n            }\n            targetSchema = targetSchema || obj.constructor;\n            if (schemaStorage.has(targetSchema)) {\n                const schema = schemaStorage.get(targetSchema);\n                res = {};\n                const namedSchema = this.getSchemaByName(schema, schemaName);\n                for(const key in namedSchema){\n                    try {\n                        const item = namedSchema[key];\n                        const objItem = obj[key];\n                        let value;\n                        if (item.optional && objItem === undefined || item.defaultValue !== undefined && objItem === item.defaultValue) {\n                            continue;\n                        }\n                        if (!item.optional && objItem === undefined) {\n                            throw new SerializerError(targetSchema.name, `Property '${key}' is required.`);\n                        }\n                        if (typeof item.type === \"number\") {\n                            if (item.converter) {\n                                if (item.repeated) {\n                                    value = objItem.map((el)=>item.converter.toJSON(el, obj));\n                                } else {\n                                    value = item.converter.toJSON(objItem, obj);\n                                }\n                            } else {\n                                value = objItem;\n                            }\n                        } else {\n                            if (item.repeated) {\n                                value = objItem.map((el)=>this.toJSON(el, {\n                                        schemaName\n                                    }));\n                            } else {\n                                value = this.toJSON(objItem, {\n                                    schemaName\n                                });\n                            }\n                        }\n                        this.checkTypes(value, item);\n                        this.checkValues(value, item);\n                        res[item.name || key] = value;\n                    } catch (e) {\n                        if (e instanceof SerializerError) {\n                            throw e;\n                        } else {\n                            throw new SerializerError(schema.target.name, `Property '${key}' is wrong. ${e.message}`, e);\n                        }\n                    }\n                }\n            } else {\n                res = {};\n                for(const key in obj){\n                    res[key] = this.toJSON(obj[key], {\n                        schemaName\n                    });\n                }\n            }\n        } else {\n            res = obj;\n        }\n        return res;\n    }\n}\nclass JsonParser extends JsonTransform {\n    static parse(data, options) {\n        const obj = JSON.parse(data);\n        return this.fromJSON(obj, options);\n    }\n    static fromJSON(target, options) {\n        const targetSchema = options.targetSchema;\n        const schemaName = options.schemaName || DEFAULT_SCHEMA;\n        const obj = new targetSchema();\n        if (isConvertible(obj)) {\n            return obj.fromJSON(target);\n        }\n        const schema = schemaStorage.get(targetSchema);\n        const namedSchema = this.getSchemaByName(schema, schemaName);\n        const keyErrors = {};\n        if (options.strictProperty && !Array.isArray(target)) {\n            JsonParser.checkStrictProperty(target, namedSchema, schema);\n        }\n        for(const key in namedSchema){\n            try {\n                const item = namedSchema[key];\n                const name = item.name || key;\n                const value = target[name];\n                if (value === undefined && (item.optional || item.defaultValue !== undefined)) {\n                    continue;\n                }\n                if (!item.optional && value === undefined) {\n                    throw new ParserError(schema, `Property '${name}' is required.`);\n                }\n                this.checkTypes(value, item);\n                this.checkValues(value, item);\n                if (typeof item.type === \"number\") {\n                    if (item.converter) {\n                        if (item.repeated) {\n                            obj[key] = value.map((el)=>item.converter.fromJSON(el, obj));\n                        } else {\n                            obj[key] = item.converter.fromJSON(value, obj);\n                        }\n                    } else {\n                        obj[key] = value;\n                    }\n                } else {\n                    const newOptions = {\n                        ...options,\n                        targetSchema: item.type,\n                        schemaName\n                    };\n                    if (item.repeated) {\n                        obj[key] = value.map((el)=>this.fromJSON(el, newOptions));\n                    } else {\n                        obj[key] = this.fromJSON(value, newOptions);\n                    }\n                }\n            } catch (e) {\n                if (!(e instanceof ParserError)) {\n                    e = new ParserError(schema, `Property '${key}' is wrong. ${e.message}`, e);\n                }\n                if (options.strictAllKeys) {\n                    keyErrors[key] = e;\n                } else {\n                    throw e;\n                }\n            }\n        }\n        const keys = Object.keys(keyErrors);\n        if (keys.length) {\n            throw new KeyError(schema, keys, keyErrors);\n        }\n        return obj;\n    }\n    static checkStrictProperty(target, namedSchema, schema) {\n        const jsonProps = Object.keys(target);\n        const schemaProps = Object.keys(namedSchema);\n        const keys = [];\n        for (const key of jsonProps){\n            if (schemaProps.indexOf(key) === -1) {\n                keys.push(key);\n            }\n        }\n        if (keys.length) {\n            throw new KeyError(schema, keys);\n        }\n    }\n}\nfunction getValidations(item) {\n    const validations = [];\n    if (item.pattern) {\n        validations.push(new PatternValidation(item.pattern));\n    }\n    if (item.type === exports.JsonPropTypes.Number || item.type === exports.JsonPropTypes.Any) {\n        if (item.minInclusive !== undefined || item.maxInclusive !== undefined) {\n            validations.push(new InclusiveValidation(item.minInclusive, item.maxInclusive));\n        }\n        if (item.minExclusive !== undefined || item.maxExclusive !== undefined) {\n            validations.push(new ExclusiveValidation(item.minExclusive, item.maxExclusive));\n        }\n        if (item.enumeration !== undefined) {\n            validations.push(new EnumerationValidation(item.enumeration));\n        }\n    }\n    if (item.type === exports.JsonPropTypes.String || item.repeated || item.type === exports.JsonPropTypes.Any) {\n        if (item.length !== undefined || item.minLength !== undefined || item.maxLength !== undefined) {\n            validations.push(new LengthValidation(item.length, item.minLength, item.maxLength));\n        }\n    }\n    return validations;\n}\nconst JsonProp = (options = {})=>(target, propertyKey)=>{\n        const errorMessage = `Cannot set type for ${propertyKey} property of ${target.constructor.name} schema`;\n        let schema;\n        if (!schemaStorage.has(target.constructor)) {\n            schema = schemaStorage.create(target.constructor);\n            schemaStorage.set(target.constructor, schema);\n        } else {\n            schema = schemaStorage.get(target.constructor);\n            if (schema.target !== target.constructor) {\n                schema = schemaStorage.create(target.constructor);\n                schemaStorage.set(target.constructor, schema);\n            }\n        }\n        const defaultSchema = {\n            type: exports.JsonPropTypes.Any,\n            validations: []\n        };\n        const copyOptions = Object.assign(defaultSchema, options);\n        copyOptions.validations = getValidations(copyOptions);\n        if (typeof copyOptions.type !== \"number\") {\n            if (!schemaStorage.has(copyOptions.type) && !isConvertible(copyOptions.type)) {\n                throw new Error(`${errorMessage}. Assigning type doesn't have schema.`);\n            }\n        }\n        let schemaNames;\n        if (Array.isArray(options.schema)) {\n            schemaNames = options.schema;\n        } else {\n            schemaNames = [\n                options.schema || DEFAULT_SCHEMA\n            ];\n        }\n        for (const schemaName of schemaNames){\n            if (!schema.names[schemaName]) {\n                schema.names[schemaName] = {};\n            }\n            const namedSchema = schema.names[schemaName];\n            namedSchema[propertyKey] = copyOptions;\n        }\n    };\nexports.JsonError = JsonError;\nexports.JsonParser = JsonParser;\nexports.JsonProp = JsonProp;\nexports.JsonSerializer = JsonSerializer;\nexports.KeyError = KeyError;\nexports.ParserError = ParserError;\nexports.SerializerError = SerializerError;\nexports.TransformError = TransformError;\nexports.ValidationError = ValidationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvanNvbi1zY2hlbWEvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUMsR0FFRDtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxNQUFNQyxrQkFBa0JDO0lBQ3BCQyxZQUFZQyxPQUFPLEVBQUVDLFVBQVUsQ0FBRTtRQUM3QixLQUFLLENBQUNBLGFBQ0EsQ0FBQyxFQUFFRCxRQUFRLDJDQUEyQyxDQUFDLEdBQ3ZEQTtRQUNOLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtJQUN0QjtBQUNKO0FBRUEsTUFBTUMsdUJBQXVCTDtJQUN6QkUsWUFBWUksTUFBTSxFQUFFSCxPQUFPLEVBQUVDLFVBQVUsQ0FBRTtRQUNyQyxLQUFLLENBQUNELFNBQVNDO1FBQ2YsSUFBSSxDQUFDRSxNQUFNLEdBQUdBO0lBQ2xCO0FBQ0o7QUFFQSxNQUFNQyxvQkFBb0JGO0lBQ3RCSCxZQUFZSSxNQUFNLEVBQUVILE9BQU8sRUFBRUMsVUFBVSxDQUFFO1FBQ3JDLEtBQUssQ0FBQ0UsUUFBUSxDQUFDLHVCQUF1QixFQUFFQSxPQUFPRSxNQUFNLENBQUNDLElBQUksQ0FBQyxVQUFVLEVBQUVOLFFBQVEsQ0FBQyxFQUFFQztJQUN0RjtBQUNKO0FBRUEsTUFBTU0sd0JBQXdCVjtBQUM5QjtBQUVBLE1BQU1XLHdCQUF3Qlg7SUFDMUJFLFlBQVlVLFVBQVUsRUFBRVQsT0FBTyxFQUFFQyxVQUFVLENBQUU7UUFDekMsS0FBSyxDQUFDLENBQUMscUJBQXFCLEVBQUVRLFdBQVcsVUFBVSxFQUFFVCxRQUFRLENBQUMsRUFBRUM7UUFDaEUsSUFBSSxDQUFDUSxVQUFVLEdBQUdBO0lBQ3RCO0FBQ0o7QUFFQSxNQUFNQyxpQkFBaUJOO0lBQ25CTCxZQUFZSSxNQUFNLEVBQUVRLElBQUksRUFBRUMsU0FBUyxDQUFDLENBQUMsQ0FBRTtRQUNu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YztnQkFBQ3ZDLFFBQVE3RSxNQUFNLElBQUltQzthQUFlO1FBQ3BEO1FBQ0EsS0FBSyxNQUFNN0IsY0FBYzhHLFlBQWE7WUFDbEMsSUFBSSxDQUFDcEgsT0FBTzZCLEtBQUssQ0FBQ3ZCLFdBQVcsRUFBRTtnQkFDM0JOLE9BQU82QixLQUFLLENBQUN2QixXQUFXLEdBQUcsQ0FBQztZQUNoQztZQUNBLE1BQU1pRixjQUFjdkYsT0FBTzZCLEtBQUssQ0FBQ3ZCLFdBQVc7WUFDNUNpRixXQUFXLENBQUN5QixZQUFZLEdBQUdHO1FBQy9CO0lBQ0o7QUFFQTNILGlCQUFpQixHQUFHRTtBQUNwQkYsa0JBQWtCLEdBQUd1RztBQUNyQnZHLGdCQUFnQixHQUFHdUg7QUFDbkJ2SCxzQkFBc0IsR0FBR2tGO0FBQ3pCbEYsZ0JBQWdCLEdBQUdlO0FBQ25CZixtQkFBbUIsR0FBR1M7QUFDdEJULHVCQUF1QixHQUFHYTtBQUMxQmIsc0JBQXNCLEdBQUdPO0FBQ3pCUCx1QkFBdUIsR0FBR1kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYWtldHBsYWNlLWFkbWluLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci9qc29uLXNjaGVtYS9idWlsZC9pbmRleC5qcz85MTc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDIwLCBQZWN1bGlhciBWZW50dXJlcywgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmNsYXNzIEpzb25FcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGlubmVyRXJyb3IpIHtcclxuICAgICAgICBzdXBlcihpbm5lckVycm9yXHJcbiAgICAgICAgICAgID8gYCR7bWVzc2FnZX0uIFNlZSB0aGUgaW5uZXIgZXhjZXB0aW9uIGZvciBtb3JlIGRldGFpbHMuYFxyXG4gICAgICAgICAgICA6IG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgdGhpcy5pbm5lckVycm9yID0gaW5uZXJFcnJvcjtcclxuICAgIH1cclxufVxuXG5jbGFzcyBUcmFuc2Zvcm1FcnJvciBleHRlbmRzIEpzb25FcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIG1lc3NhZ2UsIGlubmVyRXJyb3IpIHtcclxuICAgICAgICBzdXBlcihtZXNzYWdlLCBpbm5lckVycm9yKTtcclxuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBQYXJzZXJFcnJvciBleHRlbmRzIFRyYW5zZm9ybUVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSwgbWVzc2FnZSwgaW5uZXJFcnJvcikge1xyXG4gICAgICAgIHN1cGVyKHNjaGVtYSwgYEpTT04gZG9lc24ndCBtYXRjaCB0byAnJHtzY2hlbWEudGFyZ2V0Lm5hbWV9JyBzY2hlbWEuICR7bWVzc2FnZX1gLCBpbm5lckVycm9yKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBKc29uRXJyb3Ige1xyXG59XG5cbmNsYXNzIFNlcmlhbGl6ZXJFcnJvciBleHRlbmRzIEpzb25FcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWFOYW1lLCBtZXNzYWdlLCBpbm5lckVycm9yKSB7XHJcbiAgICAgICAgc3VwZXIoYENhbm5vdCBzZXJpYWxpemUgYnkgJyR7c2NoZW1hTmFtZX0nIHNjaGVtYS4gJHttZXNzYWdlfWAsIGlubmVyRXJyb3IpO1xyXG4gICAgICAgIHRoaXMuc2NoZW1hTmFtZSA9IHNjaGVtYU5hbWU7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgS2V5RXJyb3IgZXh0ZW5kcyBQYXJzZXJFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIGtleXMsIGVycm9ycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIoc2NoZW1hLCBcIlNvbWUga2V5cyBkb2Vzbid0IG1hdGNoIHRvIHNjaGVtYVwiKTtcclxuICAgICAgICB0aGlzLmtleXMgPSBrZXlzO1xyXG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xyXG4gICAgfVxyXG59XG5cbihmdW5jdGlvbiAoSnNvblByb3BUeXBlcykge1xyXG4gICAgSnNvblByb3BUeXBlc1tKc29uUHJvcFR5cGVzW1wiQW55XCJdID0gMF0gPSBcIkFueVwiO1xyXG4gICAgSnNvblByb3BUeXBlc1tKc29uUHJvcFR5cGVzW1wiQm9vbGVhblwiXSA9IDFdID0gXCJCb29sZWFuXCI7XHJcbiAgICBKc29uUHJvcFR5cGVzW0pzb25Qcm9wVHlwZXNbXCJOdW1iZXJcIl0gPSAyXSA9IFwiTnVtYmVyXCI7XHJcbiAgICBKc29uUHJvcFR5cGVzW0pzb25Qcm9wVHlwZXNbXCJTdHJpbmdcIl0gPSAzXSA9IFwiU3RyaW5nXCI7XHJcbn0pKGV4cG9ydHMuSnNvblByb3BUeXBlcyB8fCAoZXhwb3J0cy5Kc29uUHJvcFR5cGVzID0ge30pKTtcblxuZnVuY3Rpb24gY2hlY2tUeXBlKHZhbHVlLCB0eXBlKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIGV4cG9ydHMuSnNvblByb3BUeXBlcy5Cb29sZWFuOlxyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIjtcclxuICAgICAgICBjYXNlIGV4cG9ydHMuSnNvblByb3BUeXBlcy5OdW1iZXI6XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XHJcbiAgICAgICAgY2FzZSBleHBvcnRzLkpzb25Qcm9wVHlwZXMuU3RyaW5nOlxyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gdGhyb3dJZlR5cGVJc1dyb25nKHZhbHVlLCB0eXBlKSB7XHJcbiAgICBpZiAoIWNoZWNrVHlwZSh2YWx1ZSwgdHlwZSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBWYWx1ZSBtdXN0IGJlICR7ZXhwb3J0cy5Kc29uUHJvcFR5cGVzW3R5cGVdfWApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzQ29udmVydGlibGUodGFyZ2V0KSB7XHJcbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5wcm90b3R5cGUpIHtcclxuICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZS50b0pTT04gJiYgdGFyZ2V0LnByb3RvdHlwZS5mcm9tSlNPTikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0NvbnZlcnRpYmxlKHRhcmdldC5wcm90b3R5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAhISh0YXJnZXQgJiYgdGFyZ2V0LnRvSlNPTiAmJiB0YXJnZXQuZnJvbUpTT04pO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEpzb25TY2hlbWFTdG9yYWdlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuaXRlbXMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBoYXModGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuaGFzKHRhcmdldCkgfHwgISF0aGlzLmZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KTtcclxuICAgIH1cclxuICAgIGdldCh0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLml0ZW1zLmdldCh0YXJnZXQpIHx8IHRoaXMuZmluZFBhcmVudFNjaGVtYSh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghc2NoZW1hKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgc2NoZW1hIGZvciBjdXJyZW50IHRhcmdldFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcclxuICAgIH1cclxuICAgIGNyZWF0ZSh0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCBzY2hlbWEgPSB7IG5hbWVzOiB7fSB9O1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFNjaGVtYSA9IHRoaXMuZmluZFBhcmVudFNjaGVtYSh0YXJnZXQpO1xyXG4gICAgICAgIGlmIChwYXJlbnRTY2hlbWEpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzY2hlbWEsIHBhcmVudFNjaGVtYSk7XHJcbiAgICAgICAgICAgIHNjaGVtYS5uYW1lcyA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gcGFyZW50U2NoZW1hLm5hbWVzKSB7XHJcbiAgICAgICAgICAgICAgICBzY2hlbWEubmFtZXNbbmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRTY2hlbWEubmFtZXNbbmFtZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNjaGVtYS50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcclxuICAgIH1cclxuICAgIHNldCh0YXJnZXQsIHNjaGVtYSkge1xyXG4gICAgICAgIHRoaXMuaXRlbXMuc2V0KHRhcmdldCwgc2NoZW1hKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGFyZ2V0Ll9fcHJvdG9fXztcclxuICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuaXRlbXMuZ2V0KHBhcmVudCk7XHJcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEgfHwgdGhpcy5maW5kUGFyZW50U2NoZW1hKHBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IERFRkFVTFRfU0NIRU1BID0gXCJkZWZhdWx0XCI7XHJcbmNvbnN0IHNjaGVtYVN0b3JhZ2UgPSBuZXcgSnNvblNjaGVtYVN0b3JhZ2UoKTtcblxuY2xhc3MgUGF0dGVyblZhbGlkYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IocGF0dGVybikge1xyXG4gICAgICAgIHRoaXMucGF0dGVybiA9IG5ldyBSZWdFeHAocGF0dGVybik7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKHRoaXMucGF0dGVybi5zb3VyY2UsIHRoaXMucGF0dGVybi5mbGFncyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFwiSW5jb21pbmcgdmFsdWUgbXVzdCBiZSBzdHJpbmdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcGF0dGVybi5leGVjKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBWYWx1ZSBkb2Vzbid0IG1hdGNoIHRvIHBhdHRlcm4gJyR7cGF0dGVybi50b1N0cmluZygpfSdgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgSW5jbHVzaXZlVmFsaWRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihtaW4gPSBOdW1iZXIuTUlOX1ZBTFVFLCBtYXggPSBOdW1iZXIuTUFYX1ZBTFVFKSB7XHJcbiAgICAgICAgdGhpcy5taW4gPSBtaW47XHJcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIHRocm93SWZUeXBlSXNXcm9uZyh2YWx1ZSwgZXhwb3J0cy5Kc29uUHJvcFR5cGVzLk51bWJlcik7XHJcbiAgICAgICAgaWYgKCEodGhpcy5taW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gdGhpcy5tYXgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbiA9IHRoaXMubWluID09PSBOdW1iZXIuTUlOX1ZBTFVFID8gXCJNSU5cIiA6IHRoaXMubWluO1xyXG4gICAgICAgICAgICBjb25zdCBtYXggPSB0aGlzLm1heCA9PT0gTnVtYmVyLk1BWF9WQUxVRSA/IFwiTUFYXCIgOiB0aGlzLm1heDtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVmFsdWUgZG9lc24ndCBtYXRjaCB0byBkaWFwYXNvbiBbJHttaW59LCR7bWF4fV1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRXhjbHVzaXZlVmFsaWRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihtaW4gPSBOdW1iZXIuTUlOX1ZBTFVFLCBtYXggPSBOdW1iZXIuTUFYX1ZBTFVFKSB7XHJcbiAgICAgICAgdGhpcy5taW4gPSBtaW47XHJcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIHRocm93SWZUeXBlSXNXcm9uZyh2YWx1ZSwgZXhwb3J0cy5Kc29uUHJvcFR5cGVzLk51bWJlcik7XHJcbiAgICAgICAgaWYgKCEodGhpcy5taW4gPCB2YWx1ZSAmJiB2YWx1ZSA8IHRoaXMubWF4KSkge1xyXG4gICAgICAgICAgICBjb25zdCBtaW4gPSB0aGlzLm1pbiA9PT0gTnVtYmVyLk1JTl9WQUxVRSA/IFwiTUlOXCIgOiB0aGlzLm1pbjtcclxuICAgICAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5tYXggPT09IE51bWJlci5NQVhfVkFMVUUgPyBcIk1BWFwiIDogdGhpcy5tYXg7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFZhbHVlIGRvZXNuJ3QgbWF0Y2ggdG8gZGlhcGFzb24gKCR7bWlufSwke21heH0pYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIExlbmd0aFZhbGlkYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBtaW5MZW5ndGgsIG1heExlbmd0aCkge1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgICAgIHRoaXMubWluTGVuZ3RoID0gbWluTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMubWF4TGVuZ3RoID0gbWF4TGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSB0aGlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVmFsdWUgbGVuZ3RoIG11c3QgYmUgZXhhY3RseSAke3RoaXMubGVuZ3RofS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPCB0aGlzLm1pbkxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVmFsdWUgbGVuZ3RoIG11c3QgYmUgbW9yZSB0aGFuICR7dGhpcy5taW5MZW5ndGh9LmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1heExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiB0aGlzLm1heExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVmFsdWUgbGVuZ3RoIG11c3QgYmUgbGVzcyB0aGFuICR7dGhpcy5tYXhMZW5ndGh9LmApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEVudW1lcmF0aW9uVmFsaWRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbnVtZXJhdGlvbikge1xyXG4gICAgICAgIHRoaXMuZW51bWVyYXRpb24gPSBlbnVtZXJhdGlvbjtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhyb3dJZlR5cGVJc1dyb25nKHZhbHVlLCBleHBvcnRzLkpzb25Qcm9wVHlwZXMuU3RyaW5nKTtcclxuICAgICAgICBpZiAoIXRoaXMuZW51bWVyYXRpb24uaW5jbHVkZXModmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFZhbHVlIG11c3QgYmUgb25lIG9mICR7dGhpcy5lbnVtZXJhdGlvbi5tYXAoKHYpID0+IGAnJHt2fSdgKS5qb2luKFwiLCBcIil9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEpzb25UcmFuc2Zvcm0ge1xyXG4gICAgc3RhdGljIGNoZWNrVmFsdWVzKGRhdGEsIHNjaGVtYUl0ZW0pIHtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YSA6IFtkYXRhXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbGlkYXRpb24gb2Ygc2NoZW1hSXRlbS52YWxpZGF0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb24gaW5zdGFuY2VvZiBMZW5ndGhWYWxpZGF0aW9uICYmIHNjaGVtYUl0ZW0ucmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uLnZhbGlkYXRlKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbi52YWxpZGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY2hlY2tUeXBlcyh2YWx1ZSwgc2NoZW1hSXRlbSkge1xyXG4gICAgICAgIGlmIChzY2hlbWFJdGVtLnJlcGVhdGVkICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVmFsdWUgbXVzdCBiZSBBcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWFJdGVtLnR5cGUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93SWZUeXBlSXNXcm9uZyh2LCBzY2hlbWFJdGVtLnR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFNjaGVtYUJ5TmFtZShzY2hlbWEsIG5hbWUgPSBERUZBVUxUX1NDSEVNQSkge1xyXG4gICAgICAgIHJldHVybiB7IC4uLnNjaGVtYS5uYW1lc1tERUZBVUxUX1NDSEVNQV0sIC4uLnNjaGVtYS5uYW1lc1tuYW1lXSB9O1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEpzb25TZXJpYWxpemVyIGV4dGVuZHMgSnNvblRyYW5zZm9ybSB7XHJcbiAgICBzdGF0aWMgc2VyaWFsaXplKG9iaiwgb3B0aW9ucywgcmVwbGFjZXIsIHNwYWNlKSB7XHJcbiAgICAgICAgY29uc3QganNvbiA9IHRoaXMudG9KU09OKG9iaiwgb3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGpzb24sIHJlcGxhY2VyLCBzcGFjZSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdG9KU09OKG9iaiwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgbGV0IHJlcztcclxuICAgICAgICBsZXQgdGFyZ2V0U2NoZW1hID0gb3B0aW9ucy50YXJnZXRTY2hlbWE7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hTmFtZSA9IG9wdGlvbnMuc2NoZW1hTmFtZSB8fCBERUZBVUxUX1NDSEVNQTtcclxuICAgICAgICBpZiAoaXNDb252ZXJ0aWJsZShvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmoudG9KU09OKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgICAgICAgICAgcmVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBvYmopIHtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKHRoaXMudG9KU09OKGl0ZW0sIG9wdGlvbnMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXRTY2hlbWEgJiYgIXNjaGVtYVN0b3JhZ2UuaGFzKHRhcmdldFNjaGVtYSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uRXJyb3IoXCJDYW5ub3QgZ2V0IHNjaGVtYSBmb3IgYHRhcmdldFNjaGVtYWAgcGFyYW1cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFyZ2V0U2NoZW1hID0gKHRhcmdldFNjaGVtYSB8fCBvYmouY29uc3RydWN0b3IpO1xyXG4gICAgICAgICAgICBpZiAoc2NoZW1hU3RvcmFnZS5oYXModGFyZ2V0U2NoZW1hKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0U2NoZW1hKTtcclxuICAgICAgICAgICAgICAgIHJlcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZWRTY2hlbWEgPSB0aGlzLmdldFNjaGVtYUJ5TmFtZShzY2hlbWEsIHNjaGVtYU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmFtZWRTY2hlbWEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gbmFtZWRTY2hlbWFba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqSXRlbSA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaXRlbS5vcHRpb25hbCAmJiBvYmpJdGVtID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAoaXRlbS5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBvYmpJdGVtID09PSBpdGVtLmRlZmF1bHRWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbS5vcHRpb25hbCAmJiBvYmpJdGVtID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJpYWxpemVyRXJyb3IodGFyZ2V0U2NoZW1hLm5hbWUsIGBQcm9wZXJ0eSAnJHtrZXl9JyBpcyByZXF1aXJlZC5gKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0udHlwZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29udmVydGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ucmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmpJdGVtLm1hcCgoZWwpID0+IGl0ZW0uY29udmVydGVyLnRvSlNPTihlbCwgb2JqKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0ZW0uY29udmVydGVyLnRvSlNPTihvYmpJdGVtLCBvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqSXRlbTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmpJdGVtLm1hcCgoZWwpID0+IHRoaXMudG9KU09OKGVsLCB7IHNjaGVtYU5hbWUgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnRvSlNPTihvYmpJdGVtLCB7IHNjaGVtYU5hbWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1R5cGVzKHZhbHVlLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1ZhbHVlcyh2YWx1ZSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc1tpdGVtLm5hbWUgfHwga2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFNlcmlhbGl6ZXJFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJpYWxpemVyRXJyb3Ioc2NoZW1hLnRhcmdldC5uYW1lLCBgUHJvcGVydHkgJyR7a2V5fScgaXMgd3JvbmcuICR7ZS5tZXNzYWdlfWAsIGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzID0ge307XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNba2V5XSA9IHRoaXMudG9KU09OKG9ialtrZXldLCB7IHNjaGVtYU5hbWUgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcyA9IG9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxufVxuXG5jbGFzcyBKc29uUGFyc2VyIGV4dGVuZHMgSnNvblRyYW5zZm9ybSB7XHJcbiAgICBzdGF0aWMgcGFyc2UoZGF0YSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUpTT04ob2JqLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tSlNPTih0YXJnZXQsIG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRTY2hlbWEgPSBvcHRpb25zLnRhcmdldFNjaGVtYTtcclxuICAgICAgICBjb25zdCBzY2hlbWFOYW1lID0gb3B0aW9ucy5zY2hlbWFOYW1lIHx8IERFRkFVTFRfU0NIRU1BO1xyXG4gICAgICAgIGNvbnN0IG9iaiA9IG5ldyB0YXJnZXRTY2hlbWEoKTtcclxuICAgICAgICBpZiAoaXNDb252ZXJ0aWJsZShvYmopKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmouZnJvbUpTT04odGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0U2NoZW1hKTtcclxuICAgICAgICBjb25zdCBuYW1lZFNjaGVtYSA9IHRoaXMuZ2V0U2NoZW1hQnlOYW1lKHNjaGVtYSwgc2NoZW1hTmFtZSk7XHJcbiAgICAgICAgY29uc3Qga2V5RXJyb3JzID0ge307XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RyaWN0UHJvcGVydHkgJiYgIUFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICBKc29uUGFyc2VyLmNoZWNrU3RyaWN0UHJvcGVydHkodGFyZ2V0LCBuYW1lZFNjaGVtYSwgc2NoZW1hKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmFtZWRTY2hlbWEpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBuYW1lZFNjaGVtYVtrZXldO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGl0ZW0ubmFtZSB8fCBrZXk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRhcmdldFtuYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIChpdGVtLm9wdGlvbmFsIHx8IGl0ZW0uZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0ub3B0aW9uYWwgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihzY2hlbWEsIGBQcm9wZXJ0eSAnJHtuYW1lfScgaXMgcmVxdWlyZWQuYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrVHlwZXModmFsdWUsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1ZhbHVlcyh2YWx1ZSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChpdGVtLnR5cGUpID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29udmVydGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlLm1hcCgoZWwpID0+IGl0ZW0uY29udmVydGVyLmZyb21KU09OKGVsLCBvYmopKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gaXRlbS5jb252ZXJ0ZXIuZnJvbUpTT04odmFsdWUsIG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U2NoZW1hOiBpdGVtLnR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYU5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5yZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlLm1hcCgoZWwpID0+IHRoaXMuZnJvbUpTT04oZWwsIG5ld09wdGlvbnMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdGhpcy5mcm9tSlNPTih2YWx1ZSwgbmV3T3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgUGFyc2VyRXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZSA9IG5ldyBQYXJzZXJFcnJvcihzY2hlbWEsIGBQcm9wZXJ0eSAnJHtrZXl9JyBpcyB3cm9uZy4gJHtlLm1lc3NhZ2V9YCwgZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdHJpY3RBbGxLZXlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2V5RXJyb3JzW2tleV0gPSBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoa2V5RXJyb3JzKTtcclxuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEtleUVycm9yKHNjaGVtYSwga2V5cywga2V5RXJyb3JzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjaGVja1N0cmljdFByb3BlcnR5KHRhcmdldCwgbmFtZWRTY2hlbWEsIHNjaGVtYSkge1xyXG4gICAgICAgIGNvbnN0IGpzb25Qcm9wcyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hUHJvcHMgPSBPYmplY3Qua2V5cyhuYW1lZFNjaGVtYSk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGpzb25Qcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoc2NoZW1hUHJvcHMuaW5kZXhPZihrZXkpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBLZXlFcnJvcihzY2hlbWEsIGtleXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBnZXRWYWxpZGF0aW9ucyhpdGVtKSB7XHJcbiAgICBjb25zdCB2YWxpZGF0aW9ucyA9IFtdO1xyXG4gICAgaWYgKGl0ZW0ucGF0dGVybikge1xyXG4gICAgICAgIHZhbGlkYXRpb25zLnB1c2gobmV3IFBhdHRlcm5WYWxpZGF0aW9uKGl0ZW0ucGF0dGVybikpO1xyXG4gICAgfVxyXG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gZXhwb3J0cy5Kc29uUHJvcFR5cGVzLk51bWJlciB8fCBpdGVtLnR5cGUgPT09IGV4cG9ydHMuSnNvblByb3BUeXBlcy5BbnkpIHtcclxuICAgICAgICBpZiAoaXRlbS5taW5JbmNsdXNpdmUgIT09IHVuZGVmaW5lZCB8fCBpdGVtLm1heEluY2x1c2l2ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25zLnB1c2gobmV3IEluY2x1c2l2ZVZhbGlkYXRpb24oaXRlbS5taW5JbmNsdXNpdmUsIGl0ZW0ubWF4SW5jbHVzaXZlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpdGVtLm1pbkV4Y2x1c2l2ZSAhPT0gdW5kZWZpbmVkIHx8IGl0ZW0ubWF4RXhjbHVzaXZlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGlvbnMucHVzaChuZXcgRXhjbHVzaXZlVmFsaWRhdGlvbihpdGVtLm1pbkV4Y2x1c2l2ZSwgaXRlbS5tYXhFeGNsdXNpdmUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0uZW51bWVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9ucy5wdXNoKG5ldyBFbnVtZXJhdGlvblZhbGlkYXRpb24oaXRlbS5lbnVtZXJhdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpdGVtLnR5cGUgPT09IGV4cG9ydHMuSnNvblByb3BUeXBlcy5TdHJpbmcgfHwgaXRlbS5yZXBlYXRlZCB8fCBpdGVtLnR5cGUgPT09IGV4cG9ydHMuSnNvblByb3BUeXBlcy5BbnkpIHtcclxuICAgICAgICBpZiAoaXRlbS5sZW5ndGggIT09IHVuZGVmaW5lZCB8fCBpdGVtLm1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkIHx8IGl0ZW0ubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGlvbnMucHVzaChuZXcgTGVuZ3RoVmFsaWRhdGlvbihpdGVtLmxlbmd0aCwgaXRlbS5taW5MZW5ndGgsIGl0ZW0ubWF4TGVuZ3RoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbGlkYXRpb25zO1xyXG59XHJcbmNvbnN0IEpzb25Qcm9wID0gKG9wdGlvbnMgPSB7fSkgPT4gKHRhcmdldCwgcHJvcGVydHlLZXkpID0+IHtcclxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGBDYW5ub3Qgc2V0IHR5cGUgZm9yICR7cHJvcGVydHlLZXl9IHByb3BlcnR5IG9mICR7dGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWV9IHNjaGVtYWA7XHJcbiAgICBsZXQgc2NoZW1hO1xyXG4gICAgaWYgKCFzY2hlbWFTdG9yYWdlLmhhcyh0YXJnZXQuY29uc3RydWN0b3IpKSB7XHJcbiAgICAgICAgc2NoZW1hID0gc2NoZW1hU3RvcmFnZS5jcmVhdGUodGFyZ2V0LmNvbnN0cnVjdG9yKTtcclxuICAgICAgICBzY2hlbWFTdG9yYWdlLnNldCh0YXJnZXQuY29uc3RydWN0b3IsIHNjaGVtYSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzY2hlbWEgPSBzY2hlbWFTdG9yYWdlLmdldCh0YXJnZXQuY29uc3RydWN0b3IpO1xyXG4gICAgICAgIGlmIChzY2hlbWEudGFyZ2V0ICE9PSB0YXJnZXQuY29uc3RydWN0b3IpIHtcclxuICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hU3RvcmFnZS5jcmVhdGUodGFyZ2V0LmNvbnN0cnVjdG9yKTtcclxuICAgICAgICAgICAgc2NoZW1hU3RvcmFnZS5zZXQodGFyZ2V0LmNvbnN0cnVjdG9yLCBzY2hlbWEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGRlZmF1bHRTY2hlbWEgPSB7XHJcbiAgICAgICAgdHlwZTogZXhwb3J0cy5Kc29uUHJvcFR5cGVzLkFueSxcclxuICAgICAgICB2YWxpZGF0aW9uczogW10sXHJcbiAgICB9O1xyXG4gICAgY29uc3QgY29weU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRTY2hlbWEsIG9wdGlvbnMpO1xyXG4gICAgY29weU9wdGlvbnMudmFsaWRhdGlvbnMgPSBnZXRWYWxpZGF0aW9ucyhjb3B5T3B0aW9ucyk7XHJcbiAgICBpZiAodHlwZW9mIGNvcHlPcHRpb25zLnR5cGUgIT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICBpZiAoIXNjaGVtYVN0b3JhZ2UuaGFzKGNvcHlPcHRpb25zLnR5cGUpICYmICFpc0NvbnZlcnRpYmxlKGNvcHlPcHRpb25zLnR5cGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlcnJvck1lc3NhZ2V9LiBBc3NpZ25pbmcgdHlwZSBkb2Vzbid0IGhhdmUgc2NoZW1hLmApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBzY2hlbWFOYW1lcztcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuc2NoZW1hKSkge1xyXG4gICAgICAgIHNjaGVtYU5hbWVzID0gb3B0aW9ucy5zY2hlbWE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzY2hlbWFOYW1lcyA9IFtvcHRpb25zLnNjaGVtYSB8fCBERUZBVUxUX1NDSEVNQV07XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHNjaGVtYU5hbWUgb2Ygc2NoZW1hTmFtZXMpIHtcclxuICAgICAgICBpZiAoIXNjaGVtYS5uYW1lc1tzY2hlbWFOYW1lXSkge1xyXG4gICAgICAgICAgICBzY2hlbWEubmFtZXNbc2NoZW1hTmFtZV0gPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmFtZWRTY2hlbWEgPSBzY2hlbWEubmFtZXNbc2NoZW1hTmFtZV07XHJcbiAgICAgICAgbmFtZWRTY2hlbWFbcHJvcGVydHlLZXldID0gY29weU9wdGlvbnM7XHJcbiAgICB9XHJcbn07XG5cbmV4cG9ydHMuSnNvbkVycm9yID0gSnNvbkVycm9yO1xuZXhwb3J0cy5Kc29uUGFyc2VyID0gSnNvblBhcnNlcjtcbmV4cG9ydHMuSnNvblByb3AgPSBKc29uUHJvcDtcbmV4cG9ydHMuSnNvblNlcmlhbGl6ZXIgPSBKc29uU2VyaWFsaXplcjtcbmV4cG9ydHMuS2V5RXJyb3IgPSBLZXlFcnJvcjtcbmV4cG9ydHMuUGFyc2VyRXJyb3IgPSBQYXJzZXJFcnJvcjtcbmV4cG9ydHMuU2VyaWFsaXplckVycm9yID0gU2VyaWFsaXplckVycm9yO1xuZXhwb3J0cy5UcmFuc2Zvcm1FcnJvciA9IFRyYW5zZm9ybUVycm9yO1xuZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSBWYWxpZGF0aW9uRXJyb3I7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJKc29uRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImlubmVyRXJyb3IiLCJUcmFuc2Zvcm1FcnJvciIsInNjaGVtYSIsIlBhcnNlckVycm9yIiwidGFyZ2V0IiwibmFtZSIsIlZhbGlkYXRpb25FcnJvciIsIlNlcmlhbGl6ZXJFcnJvciIsInNjaGVtYU5hbWUiLCJLZXlFcnJvciIsImtleXMiLCJlcnJvcnMiLCJKc29uUHJvcFR5cGVzIiwiY2hlY2tUeXBlIiwidHlwZSIsIkJvb2xlYW4iLCJOdW1iZXIiLCJTdHJpbmciLCJ0aHJvd0lmVHlwZUlzV3JvbmciLCJUeXBlRXJyb3IiLCJpc0NvbnZlcnRpYmxlIiwicHJvdG90eXBlIiwidG9KU09OIiwiZnJvbUpTT04iLCJKc29uU2NoZW1hU3RvcmFnZSIsIml0ZW1zIiwiTWFwIiwiaGFzIiwiZmluZFBhcmVudFNjaGVtYSIsImdldCIsImNyZWF0ZSIsIm5hbWVzIiwicGFyZW50U2NoZW1hIiwiYXNzaWduIiwic2V0IiwicGFyZW50IiwiX19wcm90b19fIiwiREVGQVVMVF9TQ0hFTUEiLCJzY2hlbWFTdG9yYWdlIiwiUGF0dGVyblZhbGlkYXRpb24iLCJwYXR0ZXJuIiwiUmVnRXhwIiwidmFsaWRhdGUiLCJzb3VyY2UiLCJmbGFncyIsImV4ZWMiLCJ0b1N0cmluZyIsIkluY2x1c2l2ZVZhbGlkYXRpb24iLCJtaW4iLCJNSU5fVkFMVUUiLCJtYXgiLCJNQVhfVkFMVUUiLCJFeGNsdXNpdmVWYWxpZGF0aW9uIiwiTGVuZ3RoVmFsaWRhdGlvbiIsImxlbmd0aCIsIm1pbkxlbmd0aCIsIm1heExlbmd0aCIsInVuZGVmaW5lZCIsIkVudW1lcmF0aW9uVmFsaWRhdGlvbiIsImVudW1lcmF0aW9uIiwiaW5jbHVkZXMiLCJtYXAiLCJ2Iiwiam9pbiIsIkpzb25UcmFuc2Zvcm0iLCJjaGVja1ZhbHVlcyIsImRhdGEiLCJzY2hlbWFJdGVtIiwidmFsdWVzIiwiQXJyYXkiLCJpc0FycmF5IiwidmFsaWRhdGlvbiIsInZhbGlkYXRpb25zIiwicmVwZWF0ZWQiLCJjaGVja1R5cGVzIiwiZ2V0U2NoZW1hQnlOYW1lIiwiSnNvblNlcmlhbGl6ZXIiLCJzZXJpYWxpemUiLCJvYmoiLCJvcHRpb25zIiwicmVwbGFjZXIiLCJzcGFjZSIsImpzb24iLCJKU09OIiwic3RyaW5naWZ5IiwicmVzIiwidGFyZ2V0U2NoZW1hIiwiaXRlbSIsInB1c2giLCJuYW1lZFNjaGVtYSIsImtleSIsIm9iakl0ZW0iLCJvcHRpb25hbCIsImRlZmF1bHRWYWx1ZSIsImNvbnZlcnRlciIsImVsIiwiZSIsIkpzb25QYXJzZXIiLCJwYXJzZSIsImtleUVycm9ycyIsInN0cmljdFByb3BlcnR5IiwiY2hlY2tTdHJpY3RQcm9wZXJ0eSIsIm5ld09wdGlvbnMiLCJzdHJpY3RBbGxLZXlzIiwianNvblByb3BzIiwic2NoZW1hUHJvcHMiLCJpbmRleE9mIiwiZ2V0VmFsaWRhdGlvbnMiLCJBbnkiLCJtaW5JbmNsdXNpdmUiLCJtYXhJbmNsdXNpdmUiLCJtaW5FeGNsdXNpdmUiLCJtYXhFeGNsdXNpdmUiLCJKc29uUHJvcCIsInByb3BlcnR5S2V5IiwiZXJyb3JNZXNzYWdlIiwiZGVmYXVsdFNjaGVtYSIsImNvcHlPcHRpb25zIiwic2NoZW1hTmFtZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/json-schema/build/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/json-schema/build/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@peculiar/json-schema/build/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Copyright (c) 2020, Peculiar Ventures, All rights reserved.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nclass JsonError extends Error {\n    constructor(message, innerError){\n        super(innerError ? `${message}. See the inner exception for more details.` : message);\n        this.message = message;\n        this.innerError = innerError;\n    }\n}\nclass TransformError extends JsonError {\n    constructor(schema, message, innerError){\n        super(message, innerError);\n        this.schema = schema;\n    }\n}\nclass ParserError extends TransformError {\n    constructor(schema, message, innerError){\n        super(schema, `JSON doesn't match to '${schema.target.name}' schema. ${message}`, innerError);\n    }\n}\nclass ValidationError extends JsonError {\n}\nclass SerializerError extends JsonError {\n    constructor(schemaName, message, innerError){\n        super(`Cannot serialize by '${schemaName}' schema. ${message}`, innerError);\n        this.schemaName = schemaName;\n    }\n}\nclass KeyError extends ParserError {\n    constructor(schema, keys, errors = {}){\n        super(schema, \"Some keys doesn't match to schema\");\n        this.keys = keys;\n        this.errors = errors;\n    }\n}\n(function(JsonPropTypes) {\n    JsonPropTypes[JsonPropTypes[\"Any\"] = 0] = \"Any\";\n    JsonPropTypes[JsonPropTypes[\"Boolean\"] = 1] = \"Boolean\";\n    JsonPropTypes[JsonPropTypes[\"Number\"] = 2] = \"Number\";\n    JsonPropTypes[JsonPropTypes[\"String\"] = 3] = \"String\";\n})(exports.JsonPropTypes || (exports.JsonPropTypes = {}));\nfunction checkType(value, type) {\n    switch(type){\n        case exports.JsonPropTypes.Boolean:\n            return typeof value === \"boolean\";\n        case exports.JsonPropTypes.Number:\n            return typeof value === \"number\";\n        case exports.JsonPropTypes.String:\n            return typeof value === \"string\";\n    }\n    return true;\n}\nfunction throwIfTypeIsWrong(value, type) {\n    if (!checkType(value, type)) {\n        throw new TypeError(`Value must be ${exports.JsonPropTypes[type]}`);\n    }\n}\nfunction isConvertible(target) {\n    if (target && target.prototype) {\n        if (target.prototype.toJSON && target.prototype.fromJSON) {\n            return true;\n        } else {\n            return isConvertible(target.prototype);\n        }\n    } else {\n        return !!(target && target.toJSON && target.fromJSON);\n    }\n}\nclass JsonSchemaStorage {\n    constructor(){\n        this.items = new Map();\n    }\n    has(target) {\n        return this.items.has(target) || !!this.findParentSchema(target);\n    }\n    get(target) {\n        const schema = this.items.get(target) || this.findParentSchema(target);\n        if (!schema) {\n            throw new Error(\"Cannot get schema for current target\");\n        }\n        return schema;\n    }\n    create(target) {\n        const schema = {\n            names: {}\n        };\n        const parentSchema = this.findParentSchema(target);\n        if (parentSchema) {\n            Object.assign(schema, parentSchema);\n            schema.names = {};\n            for(const name in parentSchema.names){\n                schema.names[name] = Object.assign({}, parentSchema.names[name]);\n            }\n        }\n        schema.target = target;\n        return schema;\n    }\n    set(target, schema) {\n        this.items.set(target, schema);\n        return this;\n    }\n    findParentSchema(target) {\n        const parent = target.__proto__;\n        if (parent) {\n            const schema = this.items.get(parent);\n            return schema || this.findParentSchema(parent);\n        }\n        return null;\n    }\n}\nconst DEFAULT_SCHEMA = \"default\";\nconst schemaStorage = new JsonSchemaStorage();\nclass PatternValidation {\n    constructor(pattern){\n        this.pattern = new RegExp(pattern);\n    }\n    validate(value) {\n        const pattern = new RegExp(this.pattern.source, this.pattern.flags);\n        if (typeof value !== \"string\") {\n            throw new ValidationError(\"Incoming value must be string\");\n        }\n        if (!pattern.exec(value)) {\n            throw new ValidationError(`Value doesn't match to pattern '${pattern.toString()}'`);\n        }\n    }\n}\nclass InclusiveValidation {\n    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE){\n        this.min = min;\n        this.max = max;\n    }\n    validate(value) {\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.Number);\n        if (!(this.min <= value && value <= this.max)) {\n            const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\n            const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\n            throw new ValidationError(`Value doesn't match to diapason [${min},${max}]`);\n        }\n    }\n}\nclass ExclusiveValidation {\n    constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE){\n        this.min = min;\n        this.max = max;\n    }\n    validate(value) {\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.Number);\n        if (!(this.min < value && value < this.max)) {\n            const min = this.min === Number.MIN_VALUE ? \"MIN\" : this.min;\n            const max = this.max === Number.MAX_VALUE ? \"MAX\" : this.max;\n            throw new ValidationError(`Value doesn't match to diapason (${min},${max})`);\n        }\n    }\n}\nclass LengthValidation {\n    constructor(length, minLength, maxLength){\n        this.length = length;\n        this.minLength = minLength;\n        this.maxLength = maxLength;\n    }\n    validate(value) {\n        if (this.length !== undefined) {\n            if (value.length !== this.length) {\n                throw new ValidationError(`Value length must be exactly ${this.length}.`);\n            }\n            return;\n        }\n        if (this.minLength !== undefined) {\n            if (value.length < this.minLength) {\n                throw new ValidationError(`Value length must be more than ${this.minLength}.`);\n            }\n        }\n        if (this.maxLength !== undefined) {\n            if (value.length > this.maxLength) {\n                throw new ValidationError(`Value length must be less than ${this.maxLength}.`);\n            }\n        }\n    }\n}\nclass EnumerationValidation {\n    constructor(enumeration){\n        this.enumeration = enumeration;\n    }\n    validate(value) {\n        throwIfTypeIsWrong(value, exports.JsonPropTypes.String);\n        if (!this.enumeration.includes(value)) {\n            throw new ValidationError(`Value must be one of ${this.enumeration.map((v)=>`'${v}'`).join(\", \")}`);\n        }\n    }\n}\nclass JsonTransform {\n    static checkValues(data, schemaItem) {\n        const values = Array.isArray(data) ? data : [\n            data\n        ];\n        for (const value of values){\n            for (const validation of schemaItem.validations){\n                if (validation instanceof LengthValidation && schemaItem.repeated) {\n                    validation.validate(data);\n                } else {\n                    validation.validate(value);\n                }\n            }\n        }\n    }\n    static checkTypes(value, schemaItem) {\n        if (schemaItem.repeated && !Array.isArray(value)) {\n            throw new TypeError(\"Value must be Array\");\n        }\n        if (typeof schemaItem.type === \"number\") {\n            const values = Array.isArray(value) ? value : [\n                value\n            ];\n            for (const v of values){\n                throwIfTypeIsWrong(v, schemaItem.type);\n            }\n        }\n    }\n    static getSchemaByName(schema, name = DEFAULT_SCHEMA) {\n        return {\n            ...schema.names[DEFAULT_SCHEMA],\n            ...schema.names[name]\n        };\n    }\n}\nclass JsonSerializer extends JsonTransform {\n    static serialize(obj, options, replacer, space) {\n        const json = this.toJSON(obj, options);\n        return JSON.stringify(json, replacer, space);\n    }\n    static toJSON(obj, options = {}) {\n        let res;\n        let targetSchema = options.targetSchema;\n        const schemaName = options.schemaName || DEFAULT_SCHEMA;\n        if (isConvertible(obj)) {\n            return obj.toJSON();\n        }\n        if (Array.isArray(obj)) {\n            res = [];\n            for (const item of obj){\n                res.push(this.toJSON(item, options));\n            }\n        } else if (typeof obj === \"object\") {\n            if (targetSchema && !schemaStorage.has(targetSchema)) {\n                throw new JsonError(\"Cannot get schema for `targetSchema` param\");\n            }\n            targetSchema = targetSchema || obj.constructor;\n            if (schemaStorage.has(targetSchema)) {\n                const schema = schemaStorage.get(targetSchema);\n                res = {};\n                const namedSchema = this.getSchemaByName(schema, schemaName);\n                for(const key in namedSchema){\n                    try {\n                        const item = namedSchema[key];\n                        const objItem = obj[key];\n                        let value;\n                        if (item.optional && objItem === undefined || item.defaultValue !== undefined && objItem === item.defaultValue) {\n                            continue;\n                        }\n                        if (!item.optional && objItem === undefined) {\n                            throw new SerializerError(targetSchema.name, `Property '${key}' is required.`);\n                        }\n                        if (typeof item.type === \"number\") {\n                            if (item.converter) {\n                                if (item.repeated) {\n                                    value = objItem.map((el)=>item.converter.toJSON(el, obj));\n                                } else {\n                                    value = item.converter.toJSON(objItem, obj);\n                                }\n                            } else {\n                                value = objItem;\n                            }\n                        } else {\n                            if (item.repeated) {\n                                value = objItem.map((el)=>this.toJSON(el, {\n                                        schemaName\n                                    }));\n                            } else {\n                                value = this.toJSON(objItem, {\n                                    schemaName\n                                });\n                            }\n                        }\n                        this.checkTypes(value, item);\n                        this.checkValues(value, item);\n                        res[item.name || key] = value;\n                    } catch (e) {\n                        if (e instanceof SerializerError) {\n                            throw e;\n                        } else {\n                            throw new SerializerError(schema.target.name, `Property '${key}' is wrong. ${e.message}`, e);\n                        }\n                    }\n                }\n            } else {\n                res = {};\n                for(const key in obj){\n                    res[key] = this.toJSON(obj[key], {\n                        schemaName\n                    });\n                }\n            }\n        } else {\n            res = obj;\n        }\n        return res;\n    }\n}\nclass JsonParser extends JsonTransform {\n    static parse(data, options) {\n        const obj = JSON.parse(data);\n        return this.fromJSON(obj, options);\n    }\n    static fromJSON(target, options) {\n        const targetSchema = options.targetSchema;\n        const schemaName = options.schemaName || DEFAULT_SCHEMA;\n        const obj = new targetSchema();\n        if (isConvertible(obj)) {\n            return obj.fromJSON(target);\n        }\n        const schema = schemaStorage.get(targetSchema);\n        const namedSchema = this.getSchemaByName(schema, schemaName);\n        const keyErrors = {};\n        if (options.strictProperty && !Array.isArray(target)) {\n            JsonParser.checkStrictProperty(target, namedSchema, schema);\n        }\n        for(const key in namedSchema){\n            try {\n                const item = namedSchema[key];\n                const name = item.name || key;\n                const value = target[name];\n                if (value === undefined && (item.optional || item.defaultValue !== undefined)) {\n                    continue;\n                }\n                if (!item.optional && value === undefined) {\n                    throw new ParserError(schema, `Property '${name}' is required.`);\n                }\n                this.checkTypes(value, item);\n                this.checkValues(value, item);\n                if (typeof item.type === \"number\") {\n                    if (item.converter) {\n                        if (item.repeated) {\n                            obj[key] = value.map((el)=>item.converter.fromJSON(el, obj));\n                        } else {\n                            obj[key] = item.converter.fromJSON(value, obj);\n                        }\n                    } else {\n                        obj[key] = value;\n                    }\n                } else {\n                    const newOptions = {\n                        ...options,\n                        targetSchema: item.type,\n                        schemaName\n                    };\n                    if (item.repeated) {\n                        obj[key] = value.map((el)=>this.fromJSON(el, newOptions));\n                    } else {\n                        obj[key] = this.fromJSON(value, newOptions);\n                    }\n                }\n            } catch (e) {\n                if (!(e instanceof ParserError)) {\n                    e = new ParserError(schema, `Property '${key}' is wrong. ${e.message}`, e);\n                }\n                if (options.strictAllKeys) {\n                    keyErrors[key] = e;\n                } else {\n                    throw e;\n                }\n            }\n        }\n        const keys = Object.keys(keyErrors);\n        if (keys.length) {\n            throw new KeyError(schema, keys, keyErrors);\n        }\n        return obj;\n    }\n    static checkStrictProperty(target, namedSchema, schema) {\n        const jsonProps = Object.keys(target);\n        const schemaProps = Object.keys(namedSchema);\n        const keys = [];\n        for (const key of jsonProps){\n            if (schemaProps.indexOf(key) === -1) {\n                keys.push(key);\n            }\n        }\n        if (keys.length) {\n            throw new KeyError(schema, keys);\n        }\n    }\n}\nfunction getValidations(item) {\n    const validations = [];\n    if (item.pattern) {\n        validations.push(new PatternValidation(item.pattern));\n    }\n    if (item.type === exports.JsonPropTypes.Number || item.type === exports.JsonPropTypes.Any) {\n        if (item.minInclusive !== undefined || item.maxInclusive !== undefined) {\n            validations.push(new InclusiveValidation(item.minInclusive, item.maxInclusive));\n        }\n        if (item.minExclusive !== undefined || item.maxExclusive !== undefined) {\n            validations.push(new ExclusiveValidation(item.minExclusive, item.maxExclusive));\n        }\n        if (item.enumeration !== undefined) {\n            validations.push(new EnumerationValidation(item.enumeration));\n        }\n    }\n    if (item.type === exports.JsonPropTypes.String || item.repeated || item.type === exports.JsonPropTypes.Any) {\n        if (item.length !== undefined || item.minLength !== undefined || item.maxLength !== undefined) {\n            validations.push(new LengthValidation(item.length, item.minLength, item.maxLength));\n        }\n    }\n    return validations;\n}\nconst JsonProp = (options = {})=>(target, propertyKey)=>{\n        const errorMessage = `Cannot set type for ${propertyKey} property of ${target.constructor.name} schema`;\n        let schema;\n        if (!schemaStorage.has(target.constructor)) {\n            schema = schemaStorage.create(target.constructor);\n            schemaStorage.set(target.constructor, schema);\n        } else {\n            schema = schemaStorage.get(target.constructor);\n            if (schema.target !== target.constructor) {\n                schema = schemaStorage.create(target.constructor);\n                schemaStorage.set(target.constructor, schema);\n            }\n        }\n        const defaultSchema = {\n            type: exports.JsonPropTypes.Any,\n            validations: []\n        };\n        const copyOptions = Object.assign(defaultSchema, options);\n        copyOptions.validations = getValidations(copyOptions);\n        if (typeof copyOptions.type !== \"number\") {\n            if (!schemaStorage.has(copyOptions.type) && !isConvertible(copyOptions.type)) {\n                throw new Error(`${errorMessage}. Assigning type doesn't have schema.`);\n            }\n        }\n        let schemaNames;\n        if (Array.isArray(options.schema)) {\n            schemaNames = options.schema;\n        } else {\n            schemaNames = [\n                options.schema || DEFAULT_SCHEMA\n            ];\n        }\n        for (const schemaName of schemaNames){\n            if (!schema.names[schemaName]) {\n                schema.names[schemaName] = {};\n            }\n            const namedSchema = schema.names[schemaName];\n            namedSchema[propertyKey] = copyOptions;\n        }\n    };\nexports.JsonError = JsonError;\nexports.JsonParser = JsonParser;\nexports.JsonProp = JsonProp;\nexports.JsonSerializer = JsonSerializer;\nexports.KeyError = KeyError;\nexports.ParserError = ParserError;\nexports.SerializerError = SerializerError;\nexports.TransformError = TransformError;\nexports.ValidationError = ValidationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL2pzb24tc2NoZW1hL2J1aWxkL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBRUQ7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFFN0QsTUFBTUMsa0JBQWtCQztJQUNwQkMsWUFBWUMsT0FBTyxFQUFFQyxVQUFVLENBQUU7UUFDN0IsS0FBSyxDQUFDQSxhQUNBLENBQUMsRUFBRUQsUUFBUSwyQ0FBMkMsQ0FBQyxHQUN2REE7UUFDTixJQUFJLENBQUNBLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLFVBQVUsR0FBR0E7SUFDdEI7QUFDSjtBQUVBLE1BQU1DLHVCQUF1Qkw7SUFDekJFLFlBQVlJLE1BQU0sRUFBRUgsT0FBTyxFQUFFQyxVQUFVLENBQUU7UUFDckMsS0FBSyxDQUFDRCxTQUFTQztRQUNmLElBQUksQ0FBQ0UsTUFBTSxHQUFHQTtJQUNsQjtBQUNKO0FBRUEsTUFBTUMsb0JBQW9CRjtJQUN0QkgsWUFBWUksTUFBTSxFQUFFSCxPQUFPLEVBQUVDLFVBQVUsQ0FBRTtRQUNyQyxLQUFLLENBQUNFLFFBQVEsQ0FBQyx1QkFBdUIsRUFBRUEsT0FBT0UsTUFBTSxDQUFDQyxJQUFJLENBQUMsVUFBVSxFQUFFTixRQUFRLENBQUMsRUFBRUM7SUFDdEY7QUFDSjtBQUVBLE1BQU1NLHdCQUF3QlY7QUFDOUI7QUFFQSxNQUFNVyx3QkFBd0JYO0lBQzFCRSxZQUFZVSxVQUFVLEVBQUVULE9BQU8sRUFBRUMsVUFBVSxDQUFFO1FBQ3pDLEtBQUssQ0FBQyxDQUFDLHFCQUFxQixFQUFFUSxXQUFXLFVBQVUsRUFBRVQsUUFBUSxDQUFDLEVBQUVDO1FBQ2hFLElBQUksQ0FBQ1EsVUFBVSxHQUFHQTtJQUN0QjtBQUNKO0FBRUEsTUFBTUMsaUJBQWlCTjtJQUNuQkwsWUFBWUksTUFBTSxFQUFFUSxJQUFJLEVBQUVDLFNBQVMsQ0FBQyxDQUFDLENBQUU7UUFDbkMsS0FBSyxDQUFD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QUFRN0UsTUFBTSxJQUFJbUM7YUFBZTtRQUNwRDtRQUNBLEtBQUssTUFBTTdCLGNBQWM4RyxZQUFhO1lBQ2xDLElBQUksQ0FBQ3BILE9BQU82QixLQUFLLENBQUN2QixXQUFXLEVBQUU7Z0JBQzNCTixPQUFPNkIsS0FBSyxDQUFDdkIsV0FBVyxHQUFHLENBQUM7WUFDaEM7WUFDQSxNQUFNaUYsY0FBY3ZGLE9BQU82QixLQUFLLENBQUN2QixXQUFXO1lBQzVDaUYsV0FBVyxDQUFDeUIsWUFBWSxHQUFHRztRQUMvQjtJQUNKO0FBRUEzSCxpQkFBaUIsR0FBR0U7QUFDcEJGLGtCQUFrQixHQUFHdUc7QUFDckJ2RyxnQkFBZ0IsR0FBR3VIO0FBQ25Cdkgsc0JBQXNCLEdBQUdrRjtBQUN6QmxGLGdCQUFnQixHQUFHZTtBQUNuQmYsbUJBQW1CLEdBQUdTO0FBQ3RCVCx1QkFBdUIsR0FBR2E7QUFDMUJiLHNCQUFzQixHQUFHTztBQUN6QlAsdUJBQXVCLEdBQUdZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktbWFrZXRwbGFjZS1hZG1pbi8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvanNvbi1zY2hlbWEvYnVpbGQvaW5kZXguanM/OTE3OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAyMCwgUGVjdWxpYXIgVmVudHVyZXMsIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5jbGFzcyBKc29uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBpbm5lckVycm9yKSB7XHJcbiAgICAgICAgc3VwZXIoaW5uZXJFcnJvclxyXG4gICAgICAgICAgICA/IGAke21lc3NhZ2V9LiBTZWUgdGhlIGlubmVyIGV4Y2VwdGlvbiBmb3IgbW9yZSBkZXRhaWxzLmBcclxuICAgICAgICAgICAgOiBtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIHRoaXMuaW5uZXJFcnJvciA9IGlubmVyRXJyb3I7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgVHJhbnNmb3JtRXJyb3IgZXh0ZW5kcyBKc29uRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBtZXNzYWdlLCBpbm5lckVycm9yKSB7XHJcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgaW5uZXJFcnJvcik7XHJcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUGFyc2VyRXJyb3IgZXh0ZW5kcyBUcmFuc2Zvcm1FcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIG1lc3NhZ2UsIGlubmVyRXJyb3IpIHtcclxuICAgICAgICBzdXBlcihzY2hlbWEsIGBKU09OIGRvZXNuJ3QgbWF0Y2ggdG8gJyR7c2NoZW1hLnRhcmdldC5uYW1lfScgc2NoZW1hLiAke21lc3NhZ2V9YCwgaW5uZXJFcnJvcik7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgSnNvbkVycm9yIHtcclxufVxuXG5jbGFzcyBTZXJpYWxpemVyRXJyb3IgZXh0ZW5kcyBKc29uRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3Ioc2NoZW1hTmFtZSwgbWVzc2FnZSwgaW5uZXJFcnJvcikge1xyXG4gICAgICAgIHN1cGVyKGBDYW5ub3Qgc2VyaWFsaXplIGJ5ICcke3NjaGVtYU5hbWV9JyBzY2hlbWEuICR7bWVzc2FnZX1gLCBpbm5lckVycm9yKTtcclxuICAgICAgICB0aGlzLnNjaGVtYU5hbWUgPSBzY2hlbWFOYW1lO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEtleUVycm9yIGV4dGVuZHMgUGFyc2VyRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3Ioc2NoZW1hLCBrZXlzLCBlcnJvcnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHNjaGVtYSwgXCJTb21lIGtleXMgZG9lc24ndCBtYXRjaCB0byBzY2hlbWFcIik7XHJcbiAgICAgICAgdGhpcy5rZXlzID0ga2V5cztcclxuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcclxuICAgIH1cclxufVxuXG4oZnVuY3Rpb24gKEpzb25Qcm9wVHlwZXMpIHtcclxuICAgIEpzb25Qcm9wVHlwZXNbSnNvblByb3BUeXBlc1tcIkFueVwiXSA9IDBdID0gXCJBbnlcIjtcclxuICAgIEpzb25Qcm9wVHlwZXNbSnNvblByb3BUeXBlc1tcIkJvb2xlYW5cIl0gPSAxXSA9IFwiQm9vbGVhblwiO1xyXG4gICAgSnNvblByb3BUeXBlc1tKc29uUHJvcFR5cGVzW1wiTnVtYmVyXCJdID0gMl0gPSBcIk51bWJlclwiO1xyXG4gICAgSnNvblByb3BUeXBlc1tKc29uUHJvcFR5cGVzW1wiU3RyaW5nXCJdID0gM10gPSBcIlN0cmluZ1wiO1xyXG59KShleHBvcnRzLkpzb25Qcm9wVHlwZXMgfHwgKGV4cG9ydHMuSnNvblByb3BUeXBlcyA9IHt9KSk7XG5cbmZ1bmN0aW9uIGNoZWNrVHlwZSh2YWx1ZSwgdHlwZSkge1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSBleHBvcnRzLkpzb25Qcm9wVHlwZXMuQm9vbGVhbjpcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCI7XHJcbiAgICAgICAgY2FzZSBleHBvcnRzLkpzb25Qcm9wVHlwZXMuTnVtYmVyOlxyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xyXG4gICAgICAgIGNhc2UgZXhwb3J0cy5Kc29uUHJvcFR5cGVzLlN0cmluZzpcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHRocm93SWZUeXBlSXNXcm9uZyh2YWx1ZSwgdHlwZSkge1xyXG4gICAgaWYgKCFjaGVja1R5cGUodmFsdWUsIHR5cGUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVmFsdWUgbXVzdCBiZSAke2V4cG9ydHMuSnNvblByb3BUeXBlc1t0eXBlXX1gKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0NvbnZlcnRpYmxlKHRhcmdldCkge1xyXG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXQucHJvdG90eXBlKSB7XHJcbiAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUudG9KU09OICYmIHRhcmdldC5wcm90b3R5cGUuZnJvbUpTT04pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaXNDb252ZXJ0aWJsZSh0YXJnZXQucHJvdG90eXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gISEodGFyZ2V0ICYmIHRhcmdldC50b0pTT04gJiYgdGFyZ2V0LmZyb21KU09OKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBKc29uU2NoZW1hU3RvcmFnZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLml0ZW1zID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgaGFzKHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmhhcyh0YXJnZXQpIHx8ICEhdGhpcy5maW5kUGFyZW50U2NoZW1hKHRhcmdldCk7XHJcbiAgICB9XHJcbiAgICBnZXQodGFyZ2V0KSB7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5pdGVtcy5nZXQodGFyZ2V0KSB8fCB0aGlzLmZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIXNjaGVtYSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHNjaGVtYSBmb3IgY3VycmVudCB0YXJnZXRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzY2hlbWE7XHJcbiAgICB9XHJcbiAgICBjcmVhdGUodGFyZ2V0KSB7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hID0geyBuYW1lczoge30gfTtcclxuICAgICAgICBjb25zdCBwYXJlbnRTY2hlbWEgPSB0aGlzLmZpbmRQYXJlbnRTY2hlbWEodGFyZ2V0KTtcclxuICAgICAgICBpZiAocGFyZW50U2NoZW1hKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2NoZW1hLCBwYXJlbnRTY2hlbWEpO1xyXG4gICAgICAgICAgICBzY2hlbWEubmFtZXMgPSB7fTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHBhcmVudFNjaGVtYS5uYW1lcykge1xyXG4gICAgICAgICAgICAgICAgc2NoZW1hLm5hbWVzW25hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50U2NoZW1hLm5hbWVzW25hbWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzY2hlbWEudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHJldHVybiBzY2hlbWE7XHJcbiAgICB9XHJcbiAgICBzZXQodGFyZ2V0LCBzY2hlbWEpIHtcclxuICAgICAgICB0aGlzLml0ZW1zLnNldCh0YXJnZXQsIHNjaGVtYSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBmaW5kUGFyZW50U2NoZW1hKHRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRhcmdldC5fX3Byb3RvX187XHJcbiAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLml0ZW1zLmdldChwYXJlbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hIHx8IHRoaXMuZmluZFBhcmVudFNjaGVtYShwYXJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxuXG5jb25zdCBERUZBVUxUX1NDSEVNQSA9IFwiZGVmYXVsdFwiO1xyXG5jb25zdCBzY2hlbWFTdG9yYWdlID0gbmV3IEpzb25TY2hlbWFTdG9yYWdlKCk7XG5cbmNsYXNzIFBhdHRlcm5WYWxpZGF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhdHRlcm4pIHtcclxuICAgICAgICB0aGlzLnBhdHRlcm4gPSBuZXcgUmVnRXhwKHBhdHRlcm4pO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cCh0aGlzLnBhdHRlcm4uc291cmNlLCB0aGlzLnBhdHRlcm4uZmxhZ3MpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihcIkluY29taW5nIHZhbHVlIG11c3QgYmUgc3RyaW5nXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXBhdHRlcm4uZXhlYyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihgVmFsdWUgZG9lc24ndCBtYXRjaCB0byBwYXR0ZXJuICcke3BhdHRlcm4udG9TdHJpbmcoKX0nYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEluY2x1c2l2ZVZhbGlkYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IobWluID0gTnVtYmVyLk1JTl9WQUxVRSwgbWF4ID0gTnVtYmVyLk1BWF9WQUxVRSkge1xyXG4gICAgICAgIHRoaXMubWluID0gbWluO1xyXG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcclxuICAgICAgICB0aHJvd0lmVHlwZUlzV3JvbmcodmFsdWUsIGV4cG9ydHMuSnNvblByb3BUeXBlcy5OdW1iZXIpO1xyXG4gICAgICAgIGlmICghKHRoaXMubWluIDw9IHZhbHVlICYmIHZhbHVlIDw9IHRoaXMubWF4KSkge1xyXG4gICAgICAgICAgICBjb25zdCBtaW4gPSB0aGlzLm1pbiA9PT0gTnVtYmVyLk1JTl9WQUxVRSA/IFwiTUlOXCIgOiB0aGlzLm1pbjtcclxuICAgICAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5tYXggPT09IE51bWJlci5NQVhfVkFMVUUgPyBcIk1BWFwiIDogdGhpcy5tYXg7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFZhbHVlIGRvZXNuJ3QgbWF0Y2ggdG8gZGlhcGFzb24gWyR7bWlufSwke21heH1dYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEV4Y2x1c2l2ZVZhbGlkYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IobWluID0gTnVtYmVyLk1JTl9WQUxVRSwgbWF4ID0gTnVtYmVyLk1BWF9WQUxVRSkge1xyXG4gICAgICAgIHRoaXMubWluID0gbWluO1xyXG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcclxuICAgICAgICB0aHJvd0lmVHlwZUlzV3JvbmcodmFsdWUsIGV4cG9ydHMuSnNvblByb3BUeXBlcy5OdW1iZXIpO1xyXG4gICAgICAgIGlmICghKHRoaXMubWluIDwgdmFsdWUgJiYgdmFsdWUgPCB0aGlzLm1heCkpIHtcclxuICAgICAgICAgICAgY29uc3QgbWluID0gdGhpcy5taW4gPT09IE51bWJlci5NSU5fVkFMVUUgPyBcIk1JTlwiIDogdGhpcy5taW47XHJcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHRoaXMubWF4ID09PSBOdW1iZXIuTUFYX1ZBTFVFID8gXCJNQVhcIiA6IHRoaXMubWF4O1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBWYWx1ZSBkb2Vzbid0IG1hdGNoIHRvIGRpYXBhc29uICgke21pbn0sJHttYXh9KWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBMZW5ndGhWYWxpZGF0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCwgbWluTGVuZ3RoLCBtYXhMZW5ndGgpIHtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcclxuICAgICAgICB0aGlzLm1pbkxlbmd0aCA9IG1pbkxlbmd0aDtcclxuICAgICAgICB0aGlzLm1heExlbmd0aCA9IG1heExlbmd0aDtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gdGhpcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFZhbHVlIGxlbmd0aCBtdXN0IGJlIGV4YWN0bHkgJHt0aGlzLmxlbmd0aH0uYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5taW5MZW5ndGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoIDwgdGhpcy5taW5MZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFZhbHVlIGxlbmd0aCBtdXN0IGJlIG1vcmUgdGhhbiAke3RoaXMubWluTGVuZ3RofS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5tYXhMZW5ndGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gdGhpcy5tYXhMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFZhbHVlIGxlbmd0aCBtdXN0IGJlIGxlc3MgdGhhbiAke3RoaXMubWF4TGVuZ3RofS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBFbnVtZXJhdGlvblZhbGlkYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoZW51bWVyYXRpb24pIHtcclxuICAgICAgICB0aGlzLmVudW1lcmF0aW9uID0gZW51bWVyYXRpb247XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIHRocm93SWZUeXBlSXNXcm9uZyh2YWx1ZSwgZXhwb3J0cy5Kc29uUHJvcFR5cGVzLlN0cmluZyk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmVudW1lcmF0aW9uLmluY2x1ZGVzKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGBWYWx1ZSBtdXN0IGJlIG9uZSBvZiAke3RoaXMuZW51bWVyYXRpb24ubWFwKCh2KSA9PiBgJyR7dn0nYCkuam9pbihcIiwgXCIpfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBKc29uVHJhbnNmb3JtIHtcclxuICAgIHN0YXRpYyBjaGVja1ZhbHVlcyhkYXRhLCBzY2hlbWFJdGVtKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbZGF0YV07XHJcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWxpZGF0aW9uIG9mIHNjaGVtYUl0ZW0udmFsaWRhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uIGluc3RhbmNlb2YgTGVuZ3RoVmFsaWRhdGlvbiAmJiBzY2hlbWFJdGVtLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbi52YWxpZGF0ZShkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb24udmFsaWRhdGUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGNoZWNrVHlwZXModmFsdWUsIHNjaGVtYUl0ZW0pIHtcclxuICAgICAgICBpZiAoc2NoZW1hSXRlbS5yZXBlYXRlZCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlZhbHVlIG11c3QgYmUgQXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hSXRlbS50eXBlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0lmVHlwZUlzV3Jvbmcodiwgc2NoZW1hSXRlbS50eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRTY2hlbWFCeU5hbWUoc2NoZW1hLCBuYW1lID0gREVGQVVMVF9TQ0hFTUEpIHtcclxuICAgICAgICByZXR1cm4geyAuLi5zY2hlbWEubmFtZXNbREVGQVVMVF9TQ0hFTUFdLCAuLi5zY2hlbWEubmFtZXNbbmFtZV0gfTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBKc29uU2VyaWFsaXplciBleHRlbmRzIEpzb25UcmFuc2Zvcm0ge1xyXG4gICAgc3RhdGljIHNlcmlhbGl6ZShvYmosIG9wdGlvbnMsIHJlcGxhY2VyLCBzcGFjZSkge1xyXG4gICAgICAgIGNvbnN0IGpzb24gPSB0aGlzLnRvSlNPTihvYmosIG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShqc29uLCByZXBsYWNlciwgc3BhY2UpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHRvSlNPTihvYmosIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIGxldCByZXM7XHJcbiAgICAgICAgbGV0IHRhcmdldFNjaGVtYSA9IG9wdGlvbnMudGFyZ2V0U2NoZW1hO1xyXG4gICAgICAgIGNvbnN0IHNjaGVtYU5hbWUgPSBvcHRpb25zLnNjaGVtYU5hbWUgfHwgREVGQVVMVF9TQ0hFTUE7XHJcbiAgICAgICAgaWYgKGlzQ29udmVydGlibGUob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqLnRvSlNPTigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XHJcbiAgICAgICAgICAgIHJlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygb2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXMucHVzaCh0aGlzLnRvSlNPTihpdGVtLCBvcHRpb25zKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0U2NoZW1hICYmICFzY2hlbWFTdG9yYWdlLmhhcyh0YXJnZXRTY2hlbWEpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvbkVycm9yKFwiQ2Fubm90IGdldCBzY2hlbWEgZm9yIGB0YXJnZXRTY2hlbWFgIHBhcmFtXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhcmdldFNjaGVtYSA9ICh0YXJnZXRTY2hlbWEgfHwgb2JqLmNvbnN0cnVjdG9yKTtcclxuICAgICAgICAgICAgaWYgKHNjaGVtYVN0b3JhZ2UuaGFzKHRhcmdldFNjaGVtYSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHNjaGVtYVN0b3JhZ2UuZ2V0KHRhcmdldFNjaGVtYSk7XHJcbiAgICAgICAgICAgICAgICByZXMgPSB7fTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWVkU2NoZW1hID0gdGhpcy5nZXRTY2hlbWFCeU5hbWUoc2NoZW1hLCBzY2hlbWFOYW1lKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5hbWVkU2NoZW1hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IG5hbWVkU2NoZW1hW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iakl0ZW0gPSBvYmpba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGl0ZW0ub3B0aW9uYWwgJiYgb2JqSXRlbSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKGl0ZW0uZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgb2JqSXRlbSA9PT0gaXRlbS5kZWZhdWx0VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0ub3B0aW9uYWwgJiYgb2JqSXRlbSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2VyaWFsaXplckVycm9yKHRhcmdldFNjaGVtYS5uYW1lLCBgUHJvcGVydHkgJyR7a2V5fScgaXMgcmVxdWlyZWQuYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtLnR5cGUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbnZlcnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnJlcGVhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqSXRlbS5tYXAoKGVsKSA9PiBpdGVtLmNvbnZlcnRlci50b0pTT04oZWwsIG9iaikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpdGVtLmNvbnZlcnRlci50b0pTT04ob2JqSXRlbSwgb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iakl0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5yZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqSXRlbS5tYXAoKGVsKSA9PiB0aGlzLnRvSlNPTihlbCwgeyBzY2hlbWFOYW1lIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy50b0pTT04ob2JqSXRlbSwgeyBzY2hlbWFOYW1lIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tUeXBlcyh2YWx1ZSwgaXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tWYWx1ZXModmFsdWUsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNbaXRlbS5uYW1lIHx8IGtleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTZXJpYWxpemVyRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2VyaWFsaXplckVycm9yKHNjaGVtYS50YXJnZXQubmFtZSwgYFByb3BlcnR5ICcke2tleX0nIGlzIHdyb25nLiAke2UubWVzc2FnZX1gLCBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzW2tleV0gPSB0aGlzLnRvSlNPTihvYmpba2V5XSwgeyBzY2hlbWFOYW1lIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXMgPSBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgSnNvblBhcnNlciBleHRlbmRzIEpzb25UcmFuc2Zvcm0ge1xyXG4gICAgc3RhdGljIHBhcnNlKGRhdGEsIG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBvYmogPSBKU09OLnBhcnNlKGRhdGEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZyb21KU09OKG9iaiwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUpTT04odGFyZ2V0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0U2NoZW1hID0gb3B0aW9ucy50YXJnZXRTY2hlbWE7XHJcbiAgICAgICAgY29uc3Qgc2NoZW1hTmFtZSA9IG9wdGlvbnMuc2NoZW1hTmFtZSB8fCBERUZBVUxUX1NDSEVNQTtcclxuICAgICAgICBjb25zdCBvYmogPSBuZXcgdGFyZ2V0U2NoZW1hKCk7XHJcbiAgICAgICAgaWYgKGlzQ29udmVydGlibGUob2JqKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqLmZyb21KU09OKHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHNjaGVtYVN0b3JhZ2UuZ2V0KHRhcmdldFNjaGVtYSk7XHJcbiAgICAgICAgY29uc3QgbmFtZWRTY2hlbWEgPSB0aGlzLmdldFNjaGVtYUJ5TmFtZShzY2hlbWEsIHNjaGVtYU5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGtleUVycm9ycyA9IHt9O1xyXG4gICAgICAgIGlmIChvcHRpb25zLnN0cmljdFByb3BlcnR5ICYmICFBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgSnNvblBhcnNlci5jaGVja1N0cmljdFByb3BlcnR5KHRhcmdldCwgbmFtZWRTY2hlbWEsIHNjaGVtYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG5hbWVkU2NoZW1hKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gbmFtZWRTY2hlbWFba2V5XTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBpdGVtLm5hbWUgfHwga2V5O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0YXJnZXRbbmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAoaXRlbS5vcHRpb25hbCB8fCBpdGVtLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLm9wdGlvbmFsICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3Ioc2NoZW1hLCBgUHJvcGVydHkgJyR7bmFtZX0nIGlzIHJlcXVpcmVkLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1R5cGVzKHZhbHVlLCBpdGVtKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tWYWx1ZXModmFsdWUsIGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoaXRlbS50eXBlKSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbnZlcnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5yZXBlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZS5tYXAoKGVsKSA9PiBpdGVtLmNvbnZlcnRlci5mcm9tSlNPTihlbCwgb2JqKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGl0ZW0uY29udmVydGVyLmZyb21KU09OKHZhbHVlLCBvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFNjaGVtYTogaXRlbS50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2hlbWFOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ucmVwZWF0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZS5tYXAoKGVsKSA9PiB0aGlzLmZyb21KU09OKGVsLCBuZXdPcHRpb25zKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHRoaXMuZnJvbUpTT04odmFsdWUsIG5ld09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFBhcnNlckVycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGUgPSBuZXcgUGFyc2VyRXJyb3Ioc2NoZW1hLCBgUHJvcGVydHkgJyR7a2V5fScgaXMgd3JvbmcuICR7ZS5tZXNzYWdlfWAsIGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RyaWN0QWxsS2V5cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGtleUVycm9yc1trZXldID0gZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGtleUVycm9ycyk7XHJcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBLZXlFcnJvcihzY2hlbWEsIGtleXMsIGtleUVycm9ycyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY2hlY2tTdHJpY3RQcm9wZXJ0eSh0YXJnZXQsIG5hbWVkU2NoZW1hLCBzY2hlbWEpIHtcclxuICAgICAgICBjb25zdCBqc29uUHJvcHMgPSBPYmplY3Qua2V5cyh0YXJnZXQpO1xyXG4gICAgICAgIGNvbnN0IHNjaGVtYVByb3BzID0gT2JqZWN0LmtleXMobmFtZWRTY2hlbWEpO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBqc29uUHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKHNjaGVtYVByb3BzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgS2V5RXJyb3Ioc2NoZW1hLCBrZXlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gZ2V0VmFsaWRhdGlvbnMoaXRlbSkge1xyXG4gICAgY29uc3QgdmFsaWRhdGlvbnMgPSBbXTtcclxuICAgIGlmIChpdGVtLnBhdHRlcm4pIHtcclxuICAgICAgICB2YWxpZGF0aW9ucy5wdXNoKG5ldyBQYXR0ZXJuVmFsaWRhdGlvbihpdGVtLnBhdHRlcm4pKTtcclxuICAgIH1cclxuICAgIGlmIChpdGVtLnR5cGUgPT09IGV4cG9ydHMuSnNvblByb3BUeXBlcy5OdW1iZXIgfHwgaXRlbS50eXBlID09PSBleHBvcnRzLkpzb25Qcm9wVHlwZXMuQW55KSB7XHJcbiAgICAgICAgaWYgKGl0ZW0ubWluSW5jbHVzaXZlICE9PSB1bmRlZmluZWQgfHwgaXRlbS5tYXhJbmNsdXNpdmUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9ucy5wdXNoKG5ldyBJbmNsdXNpdmVWYWxpZGF0aW9uKGl0ZW0ubWluSW5jbHVzaXZlLCBpdGVtLm1heEluY2x1c2l2ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXRlbS5taW5FeGNsdXNpdmUgIT09IHVuZGVmaW5lZCB8fCBpdGVtLm1heEV4Y2x1c2l2ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25zLnB1c2gobmV3IEV4Y2x1c2l2ZVZhbGlkYXRpb24oaXRlbS5taW5FeGNsdXNpdmUsIGl0ZW0ubWF4RXhjbHVzaXZlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpdGVtLmVudW1lcmF0aW9uICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGlvbnMucHVzaChuZXcgRW51bWVyYXRpb25WYWxpZGF0aW9uKGl0ZW0uZW51bWVyYXRpb24pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXRlbS50eXBlID09PSBleHBvcnRzLkpzb25Qcm9wVHlwZXMuU3RyaW5nIHx8IGl0ZW0ucmVwZWF0ZWQgfHwgaXRlbS50eXBlID09PSBleHBvcnRzLkpzb25Qcm9wVHlwZXMuQW55KSB7XHJcbiAgICAgICAgaWYgKGl0ZW0ubGVuZ3RoICE9PSB1bmRlZmluZWQgfHwgaXRlbS5taW5MZW5ndGggIT09IHVuZGVmaW5lZCB8fCBpdGVtLm1heExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25zLnB1c2gobmV3IExlbmd0aFZhbGlkYXRpb24oaXRlbS5sZW5ndGgsIGl0ZW0ubWluTGVuZ3RoLCBpdGVtLm1heExlbmd0aCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2YWxpZGF0aW9ucztcclxufVxyXG5jb25zdCBKc29uUHJvcCA9IChvcHRpb25zID0ge30pID0+ICh0YXJnZXQsIHByb3BlcnR5S2V5KSA9PiB7XHJcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgQ2Fubm90IHNldCB0eXBlIGZvciAke3Byb3BlcnR5S2V5fSBwcm9wZXJ0eSBvZiAke3RhcmdldC5jb25zdHJ1Y3Rvci5uYW1lfSBzY2hlbWFgO1xyXG4gICAgbGV0IHNjaGVtYTtcclxuICAgIGlmICghc2NoZW1hU3RvcmFnZS5oYXModGFyZ2V0LmNvbnN0cnVjdG9yKSkge1xyXG4gICAgICAgIHNjaGVtYSA9IHNjaGVtYVN0b3JhZ2UuY3JlYXRlKHRhcmdldC5jb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgc2NoZW1hU3RvcmFnZS5zZXQodGFyZ2V0LmNvbnN0cnVjdG9yLCBzY2hlbWEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2NoZW1hID0gc2NoZW1hU3RvcmFnZS5nZXQodGFyZ2V0LmNvbnN0cnVjdG9yKTtcclxuICAgICAgICBpZiAoc2NoZW1hLnRhcmdldCAhPT0gdGFyZ2V0LmNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYVN0b3JhZ2UuY3JlYXRlKHRhcmdldC5jb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgICAgIHNjaGVtYVN0b3JhZ2Uuc2V0KHRhcmdldC5jb25zdHJ1Y3Rvciwgc2NoZW1hKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWZhdWx0U2NoZW1hID0ge1xyXG4gICAgICAgIHR5cGU6IGV4cG9ydHMuSnNvblByb3BUeXBlcy5BbnksXHJcbiAgICAgICAgdmFsaWRhdGlvbnM6IFtdLFxyXG4gICAgfTtcclxuICAgIGNvbnN0IGNvcHlPcHRpb25zID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0U2NoZW1hLCBvcHRpb25zKTtcclxuICAgIGNvcHlPcHRpb25zLnZhbGlkYXRpb25zID0gZ2V0VmFsaWRhdGlvbnMoY29weU9wdGlvbnMpO1xyXG4gICAgaWYgKHR5cGVvZiBjb3B5T3B0aW9ucy50eXBlICE9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgaWYgKCFzY2hlbWFTdG9yYWdlLmhhcyhjb3B5T3B0aW9ucy50eXBlKSAmJiAhaXNDb252ZXJ0aWJsZShjb3B5T3B0aW9ucy50eXBlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyb3JNZXNzYWdlfS4gQXNzaWduaW5nIHR5cGUgZG9lc24ndCBoYXZlIHNjaGVtYS5gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsZXQgc2NoZW1hTmFtZXM7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnNjaGVtYSkpIHtcclxuICAgICAgICBzY2hlbWFOYW1lcyA9IG9wdGlvbnMuc2NoZW1hO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2NoZW1hTmFtZXMgPSBbb3B0aW9ucy5zY2hlbWEgfHwgREVGQVVMVF9TQ0hFTUFdO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBzY2hlbWFOYW1lIG9mIHNjaGVtYU5hbWVzKSB7XHJcbiAgICAgICAgaWYgKCFzY2hlbWEubmFtZXNbc2NoZW1hTmFtZV0pIHtcclxuICAgICAgICAgICAgc2NoZW1hLm5hbWVzW3NjaGVtYU5hbWVdID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5hbWVkU2NoZW1hID0gc2NoZW1hLm5hbWVzW3NjaGVtYU5hbWVdO1xyXG4gICAgICAgIG5hbWVkU2NoZW1hW3Byb3BlcnR5S2V5XSA9IGNvcHlPcHRpb25zO1xyXG4gICAgfVxyXG59O1xuXG5leHBvcnRzLkpzb25FcnJvciA9IEpzb25FcnJvcjtcbmV4cG9ydHMuSnNvblBhcnNlciA9IEpzb25QYXJzZXI7XG5leHBvcnRzLkpzb25Qcm9wID0gSnNvblByb3A7XG5leHBvcnRzLkpzb25TZXJpYWxpemVyID0gSnNvblNlcmlhbGl6ZXI7XG5leHBvcnRzLktleUVycm9yID0gS2V5RXJyb3I7XG5leHBvcnRzLlBhcnNlckVycm9yID0gUGFyc2VyRXJyb3I7XG5leHBvcnRzLlNlcmlhbGl6ZXJFcnJvciA9IFNlcmlhbGl6ZXJFcnJvcjtcbmV4cG9ydHMuVHJhbnNmb3JtRXJyb3IgPSBUcmFuc2Zvcm1FcnJvcjtcbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gVmFsaWRhdGlvbkVycm9yO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSnNvbkVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJpbm5lckVycm9yIiwiVHJhbnNmb3JtRXJyb3IiLCJzY2hlbWEiLCJQYXJzZXJFcnJvciIsInRhcmdldCIsIm5hbWUiLCJWYWxpZGF0aW9uRXJyb3IiLCJTZXJpYWxpemVyRXJyb3IiLCJzY2hlbWFOYW1lIiwiS2V5RXJyb3IiLCJrZXlzIiwiZXJyb3JzIiwiSnNvblByb3BUeXBlcyIsImNoZWNrVHlwZSIsInR5cGUiLCJCb29sZWFuIiwiTnVtYmVyIiwiU3RyaW5nIiwidGhyb3dJZlR5cGVJc1dyb25nIiwiVHlwZUVycm9yIiwiaXNDb252ZXJ0aWJsZSIsInByb3RvdHlwZSIsInRvSlNPTiIsImZyb21KU09OIiwiSnNvblNjaGVtYVN0b3JhZ2UiLCJpdGVtcyIsIk1hcCIsImhhcyIsImZpbmRQYXJlbnRTY2hlbWEiLCJnZXQiLCJjcmVhdGUiLCJuYW1lcyIsInBhcmVudFNjaGVtYSIsImFzc2lnbiIsInNldCIsInBhcmVudCIsIl9fcHJvdG9fXyIsIkRFRkFVTFRfU0NIRU1BIiwic2NoZW1hU3RvcmFnZSIsIlBhdHRlcm5WYWxpZGF0aW9uIiwicGF0dGVybiIsIlJlZ0V4cCIsInZhbGlkYXRlIiwic291cmNlIiwiZmxhZ3MiLCJleGVjIiwidG9TdHJpbmciLCJJbmNsdXNpdmVWYWxpZGF0aW9uIiwibWluIiwiTUlOX1ZBTFVFIiwibWF4IiwiTUFYX1ZBTFVFIiwiRXhjbHVzaXZlVmFsaWRhdGlvbiIsIkxlbmd0aFZhbGlkYXRpb24iLCJsZW5ndGgiLCJtaW5MZW5ndGgiLCJtYXhMZW5ndGgiLCJ1bmRlZmluZWQiLCJFbnVtZXJhdGlvblZhbGlkYXRpb24iLCJlbnVtZXJhdGlvbiIsImluY2x1ZGVzIiwibWFwIiwidiIsImpvaW4iLCJKc29uVHJhbnNmb3JtIiwiY2hlY2tWYWx1ZXMiLCJkYXRhIiwic2NoZW1hSXRlbSIsInZhbHVlcyIsIkFycmF5IiwiaXNBcnJheSIsInZhbGlkYXRpb24iLCJ2YWxpZGF0aW9ucyIsInJlcGVhdGVkIiwiY2hlY2tUeXBlcyIsImdldFNjaGVtYUJ5TmFtZSIsIkpzb25TZXJpYWxpemVyIiwic2VyaWFsaXplIiwib2JqIiwib3B0aW9ucyIsInJlcGxhY2VyIiwic3BhY2UiLCJqc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlcyIsInRhcmdldFNjaGVtYSIsIml0ZW0iLCJwdXNoIiwibmFtZWRTY2hlbWEiLCJrZXkiLCJvYmpJdGVtIiwib3B0aW9uYWwiLCJkZWZhdWx0VmFsdWUiLCJjb252ZXJ0ZXIiLCJlbCIsImUiLCJKc29uUGFyc2VyIiwicGFyc2UiLCJrZXlFcnJvcnMiLCJzdHJpY3RQcm9wZXJ0eSIsImNoZWNrU3RyaWN0UHJvcGVydHkiLCJuZXdPcHRpb25zIiwic3RyaWN0QWxsS2V5cyIsImpzb25Qcm9wcyIsInNjaGVtYVByb3BzIiwiaW5kZXhPZiIsImdldFZhbGlkYXRpb25zIiwiQW55IiwibWluSW5jbHVzaXZlIiwibWF4SW5jbHVzaXZlIiwibWluRXhjbHVzaXZlIiwibWF4RXhjbHVzaXZlIiwiSnNvblByb3AiLCJwcm9wZXJ0eUtleSIsImVycm9yTWVzc2FnZSIsImRlZmF1bHRTY2hlbWEiLCJjb3B5T3B0aW9ucyIsInNjaGVtYU5hbWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/json-schema/build/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@peculiar/webcrypto/build/webcrypto.js":
/*!*************************************************************!*\
  !*** ./node_modules/@peculiar/webcrypto/build/webcrypto.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n Copyright (c) Peculiar Ventures, LLC\n*/ \nvar core = __webpack_require__(/*! webcrypto-core */ \"(action-browser)/./node_modules/webcrypto-core/build/webcrypto-core.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar process = __webpack_require__(/*! process */ \"process\");\nvar tslib = __webpack_require__(/*! tslib */ \"(action-browser)/./node_modules/tslib/tslib.es6.mjs\");\nvar jsonSchema = __webpack_require__(/*! @peculiar/json-schema */ \"(action-browser)/./node_modules/@peculiar/json-schema/build/index.js\");\nvar pvtsutils = __webpack_require__(/*! pvtsutils */ \"(action-browser)/./node_modules/pvtsutils/build/index.js\");\nvar asn1Schema = __webpack_require__(/*! @peculiar/asn1-schema */ \"(action-browser)/./node_modules/@peculiar/asn1-schema/build/cjs/index.js\");\nfunction _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\nvar core__namespace = /*#__PURE__*/ _interopNamespaceDefault(core);\nvar crypto__namespace = /*#__PURE__*/ _interopNamespaceDefault(crypto);\nvar process__namespace = /*#__PURE__*/ _interopNamespaceDefault(process);\nconst JsonBase64UrlConverter = {\n    fromJSON: (value)=>Buffer.from(pvtsutils.Convert.FromBase64Url(value)),\n    toJSON: (value)=>pvtsutils.Convert.ToBase64Url(value)\n};\nclass CryptoKey extends core__namespace.CryptoKey {\n    constructor(){\n        super(...arguments);\n        this.data = Buffer.alloc(0);\n        this.algorithm = {\n            name: \"\"\n        };\n        this.extractable = false;\n        this.type = \"secret\";\n        this.usages = [];\n        this.kty = \"oct\";\n        this.alg = \"\";\n    }\n}\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        name: \"ext\",\n        type: jsonSchema.JsonPropTypes.Boolean,\n        optional: true\n    })\n], CryptoKey.prototype, \"extractable\", void 0);\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        name: \"key_ops\",\n        type: jsonSchema.JsonPropTypes.String,\n        repeated: true,\n        optional: true\n    })\n], CryptoKey.prototype, \"usages\", void 0);\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        type: jsonSchema.JsonPropTypes.String\n    })\n], CryptoKey.prototype, \"kty\", void 0);\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        type: jsonSchema.JsonPropTypes.String,\n        optional: true\n    })\n], CryptoKey.prototype, \"alg\", void 0);\nclass SymmetricKey extends CryptoKey {\n    constructor(){\n        super(...arguments);\n        this.kty = \"oct\";\n        this.type = \"secret\";\n    }\n}\nclass AsymmetricKey extends CryptoKey {\n}\nclass AesCryptoKey extends SymmetricKey {\n    get alg() {\n        switch(this.algorithm.name.toUpperCase()){\n            case \"AES-CBC\":\n                return `A${this.algorithm.length}CBC`;\n            case \"AES-CTR\":\n                return `A${this.algorithm.length}CTR`;\n            case \"AES-GCM\":\n                return `A${this.algorithm.length}GCM`;\n            case \"AES-KW\":\n                return `A${this.algorithm.length}KW`;\n            case \"AES-CMAC\":\n                return `A${this.algorithm.length}CMAC`;\n            case \"AES-ECB\":\n                return `A${this.algorithm.length}ECB`;\n            default:\n                throw new core__namespace.AlgorithmError(\"Unsupported algorithm name\");\n        }\n    }\n    set alg(value) {}\n}\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        name: \"k\",\n        converter: JsonBase64UrlConverter\n    })\n], AesCryptoKey.prototype, \"data\", void 0);\nconst keyStorage = new WeakMap();\nfunction getCryptoKey(key) {\n    const res = keyStorage.get(key);\n    if (!res) {\n        throw new core__namespace.OperationError(\"Cannot get CryptoKey from secure storage\");\n    }\n    return res;\n}\nfunction setCryptoKey(value) {\n    const key = core__namespace.CryptoKey.create(value.algorithm, value.type, value.extractable, value.usages);\n    Object.freeze(key);\n    keyStorage.set(key, value);\n    return key;\n}\nclass AesCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const key = new AesCryptoKey();\n        key.algorithm = algorithm;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        key.data = crypto.randomBytes(algorithm.length >> 3);\n        return key;\n    }\n    static async exportKey(format, key) {\n        if (!(key instanceof AesCryptoKey)) {\n            throw new Error(\"key: Is not AesCryptoKey\");\n        }\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(key);\n            case \"raw\":\n                return new Uint8Array(key.data).buffer;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        let key;\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                key = jsonSchema.JsonParser.fromJSON(keyData, {\n                    targetSchema: AesCryptoKey\n                });\n                break;\n            case \"raw\":\n                key = new AesCryptoKey();\n                key.data = Buffer.from(keyData);\n                break;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n        key.algorithm = algorithm;\n        key.algorithm.length = key.data.length << 3;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        switch(key.algorithm.length){\n            case 128:\n            case 192:\n            case 256:\n                break;\n            default:\n                throw new core__namespace.OperationError(\"keyData: Is wrong key length\");\n        }\n        return key;\n    }\n    static async encrypt(algorithm, key, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"AES-CBC\":\n                return this.encryptAesCBC(algorithm, key, Buffer.from(data));\n            case \"AES-CTR\":\n                return this.encryptAesCTR(algorithm, key, Buffer.from(data));\n            case \"AES-GCM\":\n                return this.encryptAesGCM(algorithm, key, Buffer.from(data));\n            case \"AES-KW\":\n                return this.encryptAesKW(algorithm, key, Buffer.from(data));\n            case \"AES-ECB\":\n                return this.encryptAesECB(algorithm, key, Buffer.from(data));\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async decrypt(algorithm, key, data) {\n        if (!(key instanceof AesCryptoKey)) {\n            throw new Error(\"key: Is not AesCryptoKey\");\n        }\n        switch(algorithm.name.toUpperCase()){\n            case \"AES-CBC\":\n                return this.decryptAesCBC(algorithm, key, Buffer.from(data));\n            case \"AES-CTR\":\n                return this.decryptAesCTR(algorithm, key, Buffer.from(data));\n            case \"AES-GCM\":\n                return this.decryptAesGCM(algorithm, key, Buffer.from(data));\n            case \"AES-KW\":\n                return this.decryptAesKW(algorithm, key, Buffer.from(data));\n            case \"AES-ECB\":\n                return this.decryptAesECB(algorithm, key, Buffer.from(data));\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async encryptAesCBC(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesCBC(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesCTR(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ctr`, key.data, Buffer.from(algorithm.counter));\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesCTR(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ctr`, key.data, new Uint8Array(algorithm.counter));\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesGCM(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-gcm`, key.data, Buffer.from(algorithm.iv), {\n            authTagLength: (algorithm.tagLength || 128) >> 3\n        });\n        if (algorithm.additionalData) {\n            cipher.setAAD(Buffer.from(algorithm.additionalData));\n        }\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final(),\n            cipher.getAuthTag()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesGCM(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-gcm`, key.data, new Uint8Array(algorithm.iv));\n        const tagLength = (algorithm.tagLength || 128) >> 3;\n        const enc = data.slice(0, data.length - tagLength);\n        const tag = data.slice(data.length - tagLength);\n        if (algorithm.additionalData) {\n            decipher.setAAD(Buffer.from(algorithm.additionalData));\n        }\n        decipher.setAuthTag(tag);\n        let dec = decipher.update(enc);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesKW(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        return new Uint8Array(enc).buffer;\n    }\n    static async decryptAesKW(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesECB(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesECB(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n}\nAesCrypto.AES_KW_IV = Buffer.from(\"A6A6A6A6A6A6A6A6\", \"hex\");\nclass AesCbcProvider extends core__namespace.AesCbcProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nconst zero = Buffer.from([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n]);\nconst rb = Buffer.from([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    135\n]);\nconst blockSize = 16;\nfunction bitShiftLeft(buffer) {\n    const shifted = Buffer.alloc(buffer.length);\n    const last = buffer.length - 1;\n    for(let index = 0; index < last; index++){\n        shifted[index] = buffer[index] << 1;\n        if (buffer[index + 1] & 0x80) {\n            shifted[index] += 0x01;\n        }\n    }\n    shifted[last] = buffer[last] << 1;\n    return shifted;\n}\nfunction xor(a, b) {\n    const length = Math.min(a.length, b.length);\n    const output = Buffer.alloc(length);\n    for(let index = 0; index < length; index++){\n        output[index] = a[index] ^ b[index];\n    }\n    return output;\n}\nfunction aes(key, message) {\n    const cipher = crypto__namespace.createCipheriv(`aes${key.length << 3}`, key, zero);\n    const result = cipher.update(message);\n    cipher.final();\n    return result;\n}\nfunction getMessageBlock(message, blockIndex) {\n    const block = Buffer.alloc(blockSize);\n    const start = blockIndex * blockSize;\n    const end = start + blockSize;\n    message.copy(block, 0, start, end);\n    return block;\n}\nfunction getPaddedMessageBlock(message, blockIndex) {\n    const block = Buffer.alloc(blockSize);\n    const start = blockIndex * blockSize;\n    const end = message.length;\n    block.fill(0);\n    message.copy(block, 0, start, end);\n    block[end - start] = 0x80;\n    return block;\n}\nfunction generateSubkeys(key) {\n    const l = aes(key, zero);\n    let subkey1 = bitShiftLeft(l);\n    if (l[0] & 0x80) {\n        subkey1 = xor(subkey1, rb);\n    }\n    let subkey2 = bitShiftLeft(subkey1);\n    if (subkey1[0] & 0x80) {\n        subkey2 = xor(subkey2, rb);\n    }\n    return {\n        subkey1,\n        subkey2\n    };\n}\nfunction aesCmac(key, message) {\n    const subkeys = generateSubkeys(key);\n    let blockCount = Math.ceil(message.length / blockSize);\n    let lastBlockCompleteFlag;\n    let lastBlock;\n    if (blockCount === 0) {\n        blockCount = 1;\n        lastBlockCompleteFlag = false;\n    } else {\n        lastBlockCompleteFlag = message.length % blockSize === 0;\n    }\n    const lastBlockIndex = blockCount - 1;\n    if (lastBlockCompleteFlag) {\n        lastBlock = xor(getMessageBlock(message, lastBlockIndex), subkeys.subkey1);\n    } else {\n        lastBlock = xor(getPaddedMessageBlock(message, lastBlockIndex), subkeys.subkey2);\n    }\n    let x = zero;\n    let y;\n    for(let index = 0; index < lastBlockIndex; index++){\n        y = xor(x, getMessageBlock(message, index));\n        x = aes(key, y);\n    }\n    y = xor(lastBlock, x);\n    return aes(key, y);\n}\nclass AesCmacProvider extends core__namespace.AesCmacProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onSign(algorithm, key, data) {\n        const result = aesCmac(getCryptoKey(key).data, Buffer.from(data));\n        return new Uint8Array(result).buffer;\n    }\n    async onVerify(algorithm, key, signature, data) {\n        const signature2 = await this.sign(algorithm, key, data);\n        return Buffer.from(signature).compare(Buffer.from(signature2)) === 0;\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nclass AesCtrProvider extends core__namespace.AesCtrProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nclass AesGcmProvider extends core__namespace.AesGcmProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nclass AesKwProvider extends core__namespace.AesKwProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nclass AesEcbProvider extends core__namespace.AesEcbProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nclass DesCryptoKey extends SymmetricKey {\n    get alg() {\n        switch(this.algorithm.name.toUpperCase()){\n            case \"DES-CBC\":\n                return `DES-CBC`;\n            case \"DES-EDE3-CBC\":\n                return `3DES-CBC`;\n            default:\n                throw new core__namespace.AlgorithmError(\"Unsupported algorithm name\");\n        }\n    }\n    set alg(value) {}\n}\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        name: \"k\",\n        converter: JsonBase64UrlConverter\n    })\n], DesCryptoKey.prototype, \"data\", void 0);\nclass DesCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const key = new DesCryptoKey();\n        key.algorithm = algorithm;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        key.data = crypto.randomBytes(algorithm.length >> 3);\n        return key;\n    }\n    static async exportKey(format, key) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(key);\n            case \"raw\":\n                return new Uint8Array(key.data).buffer;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        let key;\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                key = jsonSchema.JsonParser.fromJSON(keyData, {\n                    targetSchema: DesCryptoKey\n                });\n                break;\n            case \"raw\":\n                key = new DesCryptoKey();\n                key.data = Buffer.from(keyData);\n                break;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n        key.algorithm = algorithm;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static async encrypt(algorithm, key, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"DES-CBC\":\n                return this.encryptDesCBC(algorithm, key, Buffer.from(data));\n            case \"DES-EDE3-CBC\":\n                return this.encryptDesEDE3CBC(algorithm, key, Buffer.from(data));\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async decrypt(algorithm, key, data) {\n        if (!(key instanceof DesCryptoKey)) {\n            throw new Error(\"key: Is not DesCryptoKey\");\n        }\n        switch(algorithm.name.toUpperCase()){\n            case \"DES-CBC\":\n                return this.decryptDesCBC(algorithm, key, Buffer.from(data));\n            case \"DES-EDE3-CBC\":\n                return this.decryptDesEDE3CBC(algorithm, key, Buffer.from(data));\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async encryptDesCBC(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptDesCBC(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptDesEDE3CBC(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`des-ede3-cbc`, key.data, Buffer.from(algorithm.iv));\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptDesEDE3CBC(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`des-ede3-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n}\nclass DesCbcProvider extends core__namespace.DesProvider {\n    constructor(){\n        super(...arguments);\n        this.keySizeBits = 64;\n        this.ivSize = 8;\n        this.name = \"DES-CBC\";\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.generateKey({\n            name: this.name,\n            length: this.keySizeBits\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return DesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.importKey(format, keyData, {\n            name: this.name,\n            length: this.keySizeBits\n        }, extractable, keyUsages);\n        if (key.data.length !== this.keySizeBits >> 3) {\n            throw new core__namespace.OperationError(\"keyData: Wrong key size\");\n        }\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\n        }\n    }\n}\nclass DesEde3CbcProvider extends core__namespace.DesProvider {\n    constructor(){\n        super(...arguments);\n        this.keySizeBits = 192;\n        this.ivSize = 8;\n        this.name = \"DES-EDE3-CBC\";\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.generateKey({\n            name: this.name,\n            length: this.keySizeBits\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return DesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.importKey(format, keyData, {\n            name: this.name,\n            length: this.keySizeBits\n        }, extractable, keyUsages);\n        if (key.data.length !== this.keySizeBits >> 3) {\n            throw new core__namespace.OperationError(\"keyData: Wrong key size\");\n        }\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\n        }\n    }\n}\nfunction getJwkAlgorithm(algorithm) {\n    switch(algorithm.name.toUpperCase()){\n        case \"RSA-OAEP\":\n            {\n                const mdSize = /(\\d+)$/.exec(algorithm.hash.name)[1];\n                return `RSA-OAEP${mdSize !== \"1\" ? `-${mdSize}` : \"\"}`;\n            }\n        case \"RSASSA-PKCS1-V1_5\":\n            return `RS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\n        case \"RSA-PSS\":\n            return `PS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\n        case \"RSA-PKCS1\":\n            return `RS1`;\n        default:\n            throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n    }\n}\nclass RsaPrivateKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"private\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"RSA\",\n            alg: getJwkAlgorithm(this.algorithm),\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        const key = jsonSchema.JsonParser.fromJSON(json, {\n            targetSchema: core__namespace.asn1.RsaPrivateKey\n        });\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.privateKeyAlgorithm.parameters = null;\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n    }\n}\nclass RsaPublicKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"public\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\n        return asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"RSA\",\n            alg: getJwkAlgorithm(this.algorithm),\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        const key = jsonSchema.JsonParser.fromJSON(json, {\n            targetSchema: core__namespace.asn1.RsaPublicKey\n        });\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.publicKeyAlgorithm.parameters = null;\n        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(key);\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n    }\n}\nclass RsaCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const privateKey = new RsaPrivateKey();\n        privateKey.algorithm = algorithm;\n        privateKey.extractable = extractable;\n        privateKey.usages = keyUsages.filter((usage)=>this.privateKeyUsages.indexOf(usage) !== -1);\n        const publicKey = new RsaPublicKey();\n        publicKey.algorithm = algorithm;\n        publicKey.extractable = true;\n        publicKey.usages = keyUsages.filter((usage)=>this.publicKeyUsages.indexOf(usage) !== -1);\n        const publicExponent = Buffer.concat([\n            Buffer.alloc(4 - algorithm.publicExponent.byteLength, 0),\n            Buffer.from(algorithm.publicExponent)\n        ]).readInt32BE(0);\n        const keys = crypto.generateKeyPairSync(\"rsa\", {\n            modulusLength: algorithm.modulusLength,\n            publicExponent,\n            publicKeyEncoding: {\n                format: \"der\",\n                type: \"spki\"\n            },\n            privateKeyEncoding: {\n                format: \"der\",\n                type: \"pkcs8\"\n            }\n        });\n        privateKey.data = keys.privateKey;\n        publicKey.data = keys.publicKey;\n        const res = {\n            privateKey,\n            publicKey\n        };\n        return res;\n    }\n    static async exportKey(format, key) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(key);\n            case \"pkcs8\":\n            case \"spki\":\n                return new Uint8Array(key.data).buffer;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                {\n                    const jwk = keyData;\n                    if (jwk.d) {\n                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {\n                            targetSchema: core__namespace.asn1.RsaPrivateKey\n                        });\n                        return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                    } else {\n                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {\n                            targetSchema: core__namespace.asn1.RsaPublicKey\n                        });\n                        return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                    }\n                }\n            case \"spki\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\n                    const asnKey = asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            case \"pkcs8\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\n                    const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\n        }\n    }\n    static async sign(algorithm, key, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"RSA-PSS\":\n            case \"RSASSA-PKCS1-V1_5\":\n                return this.signRsa(algorithm, key, data);\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async verify(algorithm, key, signature, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"RSA-PSS\":\n            case \"RSASSA-PKCS1-V1_5\":\n                return this.verifySSA(algorithm, key, data, signature);\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async encrypt(algorithm, key, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"RSA-OAEP\":\n                return this.encryptOAEP(algorithm, key, data);\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async decrypt(algorithm, key, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"RSA-OAEP\":\n                return this.decryptOAEP(algorithm, key, data);\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.privateKeyAlgorithm.parameters = null;\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);\n        const key = new RsaPrivateKey();\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static importPublicKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.publicKeyAlgorithm.parameters = null;\n        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(asnKey);\n        const key = new RsaPublicKey();\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static getCryptoAlgorithm(alg) {\n        switch(alg.hash.name.toUpperCase()){\n            case \"SHA-1\":\n                return \"RSA-SHA1\";\n            case \"SHA-256\":\n                return \"RSA-SHA256\";\n            case \"SHA-384\":\n                return \"RSA-SHA384\";\n            case \"SHA-512\":\n                return \"RSA-SHA512\";\n            case \"SHA3-256\":\n                return \"RSA-SHA3-256\";\n            case \"SHA3-384\":\n                return \"RSA-SHA3-384\";\n            case \"SHA3-512\":\n                return \"RSA-SHA3-512\";\n            default:\n                throw new core__namespace.OperationError(\"algorithm.hash: Is not recognized\");\n        }\n    }\n    static signRsa(algorithm, key, data) {\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\n        const signer = crypto.createSign(cryptoAlg);\n        signer.update(Buffer.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\n            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;\n            options.saltLength = algorithm.saltLength;\n        }\n        const signature = signer.sign(options);\n        return new Uint8Array(signature).buffer;\n    }\n    static verifySSA(algorithm, key, data, signature) {\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\n        const signer = crypto.createVerify(cryptoAlg);\n        signer.update(Buffer.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\n            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;\n            options.saltLength = algorithm.saltLength;\n        }\n        const ok = signer.verify(options, signature);\n        return ok;\n    }\n    static encryptOAEP(algorithm, key, data) {\n        const options = {\n            key: `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`,\n            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING\n        };\n        if (algorithm.label) ;\n        return new Uint8Array(crypto.publicEncrypt(options, data)).buffer;\n    }\n    static decryptOAEP(algorithm, key, data) {\n        const options = {\n            key: `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`,\n            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING\n        };\n        if (algorithm.label) ;\n        return new Uint8Array(crypto.privateDecrypt(options, data)).buffer;\n    }\n}\nRsaCrypto.publicKeyUsages = [\n    \"verify\",\n    \"encrypt\",\n    \"wrapKey\"\n];\nRsaCrypto.privateKeyUsages = [\n    \"sign\",\n    \"decrypt\",\n    \"unwrapKey\"\n];\nclass RsaSsaProvider extends core__namespace.RsaSsaProvider {\n    constructor(){\n        super(...arguments);\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\",\n            \"shake128\",\n            \"shake256\",\n            \"SHA3-256\",\n            \"SHA3-384\",\n            \"SHA3-512\"\n        ];\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n}\nclass RsaPssProvider extends core__namespace.RsaPssProvider {\n    constructor(){\n        super(...arguments);\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\",\n            \"shake128\",\n            \"shake256\",\n            \"SHA3-256\",\n            \"SHA3-384\",\n            \"SHA3-512\"\n        ];\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n}\nclass ShaCrypto {\n    static size(algorithm) {\n        switch(algorithm.name.toUpperCase()){\n            case \"SHA-1\":\n                return 160;\n            case \"SHA-256\":\n            case \"SHA3-256\":\n                return 256;\n            case \"SHA-384\":\n            case \"SHA3-384\":\n                return 384;\n            case \"SHA-512\":\n            case \"SHA3-512\":\n                return 512;\n            default:\n                throw new Error(\"Unrecognized name\");\n        }\n    }\n    static getAlgorithmName(algorithm) {\n        switch(algorithm.name.toUpperCase()){\n            case \"SHA-1\":\n                return \"sha1\";\n            case \"SHA-256\":\n                return \"sha256\";\n            case \"SHA-384\":\n                return \"sha384\";\n            case \"SHA-512\":\n                return \"sha512\";\n            case \"SHA3-256\":\n                return \"sha3-256\";\n            case \"SHA3-384\":\n                return \"sha3-384\";\n            case \"SHA3-512\":\n                return \"sha3-512\";\n            default:\n                throw new Error(\"Unrecognized name\");\n        }\n    }\n    static digest(algorithm, data) {\n        const hashAlg = this.getAlgorithmName(algorithm);\n        const hash = crypto.createHash(hashAlg).update(Buffer.from(data)).digest();\n        return new Uint8Array(hash).buffer;\n    }\n}\nclass RsaOaepProvider extends core__namespace.RsaOaepProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onEncrypt(algorithm, key, data) {\n        const internalKey = getCryptoKey(key);\n        const dataView = new Uint8Array(data);\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\n        const dataLength = dataView.byteLength;\n        const psLength = keySize - dataLength - 2 * hashSize - 2;\n        if (dataLength > keySize - 2 * hashSize - 2) {\n            throw new Error(\"Data too large\");\n        }\n        const message = new Uint8Array(keySize);\n        const seed = message.subarray(1, hashSize + 1);\n        const dataBlock = message.subarray(hashSize + 1);\n        dataBlock.set(dataView, hashSize + psLength + 1);\n        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\")).update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0))).digest();\n        dataBlock.set(labelHash, 0);\n        dataBlock[hashSize + psLength] = 1;\n        crypto.randomFillSync(seed);\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\n        for(let i = 0; i < dataBlock.length; i++){\n            dataBlock[i] ^= dataBlockMask[i];\n        }\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\n        for(let i = 0; i < seed.length; i++){\n            seed[i] ^= seedMask[i];\n        }\n        if (!internalKey.pem) {\n            internalKey.pem = `-----BEGIN PUBLIC KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const pkcs0 = crypto.publicEncrypt({\n            key: internalKey.pem,\n            padding: crypto.constants.RSA_NO_PADDING\n        }, Buffer.from(message));\n        return new Uint8Array(pkcs0).buffer;\n    }\n    async onDecrypt(algorithm, key, data) {\n        const internalKey = getCryptoKey(key);\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\n        const dataLength = data.byteLength;\n        if (dataLength !== keySize) {\n            throw new Error(\"Bad data\");\n        }\n        if (!internalKey.pem) {\n            internalKey.pem = `-----BEGIN PRIVATE KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        let pkcs0 = crypto.privateDecrypt({\n            key: internalKey.pem,\n            padding: crypto.constants.RSA_NO_PADDING\n        }, Buffer.from(data));\n        const z = pkcs0[0];\n        const seed = pkcs0.subarray(1, hashSize + 1);\n        const dataBlock = pkcs0.subarray(hashSize + 1);\n        if (z !== 0) {\n            throw new Error(\"Decryption failed\");\n        }\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\n        for(let i = 0; i < seed.length; i++){\n            seed[i] ^= seedMask[i];\n        }\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\n        for(let i = 0; i < dataBlock.length; i++){\n            dataBlock[i] ^= dataBlockMask[i];\n        }\n        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\")).update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0))).digest();\n        for(let i = 0; i < hashSize; i++){\n            if (labelHash[i] !== dataBlock[i]) {\n                throw new Error(\"Decryption failed\");\n            }\n        }\n        let psEnd = hashSize;\n        for(; psEnd < dataBlock.length; psEnd++){\n            const psz = dataBlock[psEnd];\n            if (psz === 1) {\n                break;\n            }\n            if (psz !== 0) {\n                throw new Error(\"Decryption failed\");\n            }\n        }\n        if (psEnd === dataBlock.length) {\n            throw new Error(\"Decryption failed\");\n        }\n        pkcs0 = dataBlock.subarray(psEnd + 1);\n        return new Uint8Array(pkcs0).buffer;\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n    mgf1(algorithm, seed, length = 0) {\n        const hashSize = ShaCrypto.size(algorithm) >> 3;\n        const mask = new Uint8Array(length);\n        const counter = new Uint8Array(4);\n        const chunks = Math.ceil(length / hashSize);\n        for(let i = 0; i < chunks; i++){\n            counter[0] = i >>> 24;\n            counter[1] = i >>> 16 & 255;\n            counter[2] = i >>> 8 & 255;\n            counter[3] = i & 255;\n            const submask = mask.subarray(i * hashSize);\n            let chunk = crypto.createHash(algorithm.name.replace(\"-\", \"\")).update(seed).update(counter).digest();\n            if (chunk.length > submask.length) {\n                chunk = chunk.subarray(0, submask.length);\n            }\n            submask.set(chunk);\n        }\n        return mask;\n    }\n}\nclass RsaEsProvider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"RSAES-PKCS1-v1_5\";\n        this.usages = {\n            publicKey: [\n                \"encrypt\",\n                \"wrapKey\"\n            ],\n            privateKey: [\n                \"decrypt\",\n                \"unwrapKey\"\n            ]\n        };\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"publicExponent\");\n        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {\n            throw new TypeError(\"publicExponent: Missing or not a Uint8Array\");\n        }\n        const publicExponent = pvtsutils.Convert.ToBase64(algorithm.publicExponent);\n        if (!(publicExponent === \"Aw==\" || publicExponent === \"AQAB\")) {\n            throw new TypeError(\"publicExponent: Must be [3] or [1,0,1]\");\n        }\n        this.checkRequiredProperty(algorithm, \"modulusLength\");\n        switch(algorithm.modulusLength){\n            case 1024:\n            case 2048:\n            case 4096:\n                break;\n            default:\n                throw new TypeError(\"modulusLength: Must be 1024, 2048, or 4096\");\n        }\n    }\n    async onEncrypt(algorithm, key, data) {\n        const options = this.toCryptoOptions(key);\n        const enc = crypto__namespace.publicEncrypt(options, new Uint8Array(data));\n        return new Uint8Array(enc).buffer;\n    }\n    async onDecrypt(algorithm, key, data) {\n        const options = this.toCryptoOptions(key);\n        const dec = crypto__namespace.privateDecrypt(options, new Uint8Array(data));\n        return new Uint8Array(dec).buffer;\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n    toCryptoOptions(key) {\n        const type = key.type.toUpperCase();\n        return {\n            key: `-----BEGIN ${type} KEY-----\\n${getCryptoKey(key).data.toString(\"base64\")}\\n-----END ${type} KEY-----`,\n            padding: crypto__namespace.constants.RSA_PKCS1_PADDING\n        };\n    }\n}\nconst namedOIDs = {\n    \"1.2.840.10045.3.1.7\": \"P-256\",\n    \"P-256\": \"1.2.840.10045.3.1.7\",\n    \"1.3.132.0.34\": \"P-384\",\n    \"P-384\": \"1.3.132.0.34\",\n    \"1.3.132.0.35\": \"P-521\",\n    \"P-521\": \"1.3.132.0.35\",\n    \"1.3.132.0.10\": \"K-256\",\n    \"K-256\": \"1.3.132.0.10\",\n    \"brainpoolP160r1\": \"1.3.36.3.3.2.8.1.1.1\",\n    \"1.3.36.3.3.2.8.1.1.1\": \"brainpoolP160r1\",\n    \"brainpoolP160t1\": \"1.3.36.3.3.2.8.1.1.2\",\n    \"1.3.36.3.3.2.8.1.1.2\": \"brainpoolP160t1\",\n    \"brainpoolP192r1\": \"1.3.36.3.3.2.8.1.1.3\",\n    \"1.3.36.3.3.2.8.1.1.3\": \"brainpoolP192r1\",\n    \"brainpoolP192t1\": \"1.3.36.3.3.2.8.1.1.4\",\n    \"1.3.36.3.3.2.8.1.1.4\": \"brainpoolP192t1\",\n    \"brainpoolP224r1\": \"1.3.36.3.3.2.8.1.1.5\",\n    \"1.3.36.3.3.2.8.1.1.5\": \"brainpoolP224r1\",\n    \"brainpoolP224t1\": \"1.3.36.3.3.2.8.1.1.6\",\n    \"1.3.36.3.3.2.8.1.1.6\": \"brainpoolP224t1\",\n    \"brainpoolP256r1\": \"1.3.36.3.3.2.8.1.1.7\",\n    \"1.3.36.3.3.2.8.1.1.7\": \"brainpoolP256r1\",\n    \"brainpoolP256t1\": \"1.3.36.3.3.2.8.1.1.8\",\n    \"1.3.36.3.3.2.8.1.1.8\": \"brainpoolP256t1\",\n    \"brainpoolP320r1\": \"1.3.36.3.3.2.8.1.1.9\",\n    \"1.3.36.3.3.2.8.1.1.9\": \"brainpoolP320r1\",\n    \"brainpoolP320t1\": \"1.3.36.3.3.2.8.1.1.10\",\n    \"1.3.36.3.3.2.8.1.1.10\": \"brainpoolP320t1\",\n    \"brainpoolP384r1\": \"1.3.36.3.3.2.8.1.1.11\",\n    \"1.3.36.3.3.2.8.1.1.11\": \"brainpoolP384r1\",\n    \"brainpoolP384t1\": \"1.3.36.3.3.2.8.1.1.12\",\n    \"1.3.36.3.3.2.8.1.1.12\": \"brainpoolP384t1\",\n    \"brainpoolP512r1\": \"1.3.36.3.3.2.8.1.1.13\",\n    \"1.3.36.3.3.2.8.1.1.13\": \"brainpoolP512r1\",\n    \"brainpoolP512t1\": \"1.3.36.3.3.2.8.1.1.14\",\n    \"1.3.36.3.3.2.8.1.1.14\": \"brainpoolP512t1\"\n};\nfunction getOidByNamedCurve$1(namedCurve) {\n    const oid = namedOIDs[namedCurve];\n    if (!oid) {\n        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\n    }\n    return oid;\n}\nclass EcPrivateKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"private\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"EC\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));\n        const key = jsonSchema.JsonParser.fromJSON(json, {\n            targetSchema: core__namespace.asn1.EcPrivateKey\n        });\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\nclass EcPublicKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"public\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\n        return new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"EC\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        const key = jsonSchema.JsonParser.fromJSON(json, {\n            targetSchema: core__namespace.asn1.EcPublicKey\n        });\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));\n        keyInfo.publicKey = asn1Schema.AsnSerializer.toASN(key).valueHex;\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\nclass Sha1Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA-1\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha256Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA-256\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha384Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA-384\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha512Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA-512\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha3256Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA3-256\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha3384Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA3-384\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha3512Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA3-512\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass EcCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const privateKey = new EcPrivateKey();\n        privateKey.algorithm = algorithm;\n        privateKey.extractable = extractable;\n        privateKey.usages = keyUsages.filter((usage)=>this.privateKeyUsages.indexOf(usage) !== -1);\n        const publicKey = new EcPublicKey();\n        publicKey.algorithm = algorithm;\n        publicKey.extractable = true;\n        publicKey.usages = keyUsages.filter((usage)=>this.publicKeyUsages.indexOf(usage) !== -1);\n        const keys = crypto.generateKeyPairSync(\"ec\", {\n            namedCurve: this.getOpenSSLNamedCurve(algorithm.namedCurve),\n            publicKeyEncoding: {\n                format: \"der\",\n                type: \"spki\"\n            },\n            privateKeyEncoding: {\n                format: \"der\",\n                type: \"pkcs8\"\n            }\n        });\n        privateKey.data = keys.privateKey;\n        publicKey.data = keys.publicKey;\n        const res = {\n            privateKey,\n            publicKey\n        };\n        return res;\n    }\n    static async sign(algorithm, key, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);\n        const signer = crypto.createSign(cryptoAlg);\n        signer.update(Buffer.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        const signature = signer.sign(options);\n        const ecSignature = asn1Schema.AsnParser.parse(signature, core__namespace.asn1.EcDsaSignature);\n        const signatureRaw = core__namespace.EcUtils.encodeSignature(ecSignature, core__namespace.EcCurves.get(key.algorithm.namedCurve).size);\n        return signatureRaw.buffer;\n    }\n    static async verify(algorithm, key, signature, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);\n        const signer = crypto.createVerify(cryptoAlg);\n        signer.update(Buffer.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        const ecSignature = new core__namespace.asn1.EcDsaSignature();\n        const namedCurve = core__namespace.EcCurves.get(key.algorithm.namedCurve);\n        const signaturePoint = core__namespace.EcUtils.decodeSignature(signature, namedCurve.size);\n        ecSignature.r = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.r);\n        ecSignature.s = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.s);\n        const ecSignatureRaw = Buffer.from(asn1Schema.AsnSerializer.serialize(ecSignature));\n        const ok = signer.verify(options, ecSignatureRaw);\n        return ok;\n    }\n    static async deriveBits(algorithm, baseKey, length) {\n        const cryptoAlg = this.getOpenSSLNamedCurve(baseKey.algorithm.namedCurve);\n        const ecdh = crypto.createECDH(cryptoAlg);\n        const asnPrivateKey = asn1Schema.AsnParser.parse(baseKey.data, core__namespace.asn1.PrivateKeyInfo);\n        const asnEcPrivateKey = asn1Schema.AsnParser.parse(asnPrivateKey.privateKey, core__namespace.asn1.EcPrivateKey);\n        ecdh.setPrivateKey(Buffer.from(asnEcPrivateKey.privateKey));\n        const asnPublicKey = asn1Schema.AsnParser.parse(algorithm.public.data, core__namespace.asn1.PublicKeyInfo);\n        const bits = ecdh.computeSecret(Buffer.from(asnPublicKey.publicKey));\n        if (length === null) {\n            return bits;\n        }\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\n    }\n    static async exportKey(format, key) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(key);\n            case \"pkcs8\":\n            case \"spki\":\n                return new Uint8Array(key.data).buffer;\n            case \"raw\":\n                {\n                    const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);\n                    return publicKeyInfo.publicKey;\n                }\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                {\n                    const jwk = keyData;\n                    if (jwk.d) {\n                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {\n                            targetSchema: core__namespace.asn1.EcPrivateKey\n                        });\n                        return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                    } else {\n                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {\n                            targetSchema: core__namespace.asn1.EcPublicKey\n                        });\n                        return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                    }\n                }\n            case \"raw\":\n                {\n                    const asnKey = new core__namespace.asn1.EcPublicKey(keyData);\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            case \"spki\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\n                    const asnKey = new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);\n                    this.assertKeyParameters(keyInfo.publicKeyAlgorithm.parameters, algorithm.namedCurve);\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            case \"pkcs8\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\n                    const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);\n                    this.assertKeyParameters(keyInfo.privateKeyAlgorithm.parameters, algorithm.namedCurve);\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\n        }\n    }\n    static assertKeyParameters(parameters, namedCurve) {\n        if (!parameters) {\n            throw new core__namespace.CryptoError(\"Key info doesn't have required parameters\");\n        }\n        let namedCurveIdentifier = \"\";\n        try {\n            namedCurveIdentifier = asn1Schema.AsnParser.parse(parameters, core__namespace.asn1.ObjectIdentifier).value;\n        } catch (e) {\n            throw new core__namespace.CryptoError(\"Cannot read key info parameters\");\n        }\n        if (getOidByNamedCurve$1(namedCurve) !== namedCurveIdentifier) {\n            throw new core__namespace.CryptoError(\"Key info parameter doesn't match to named curve\");\n        }\n    }\n    static async importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(algorithm.namedCurve)));\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);\n        const key = new EcPrivateKey();\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        const namedCurve = getOidByNamedCurve$1(algorithm.namedCurve);\n        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(namedCurve));\n        keyInfo.publicKey = asnKey.value;\n        const key = new EcPublicKey();\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static getOpenSSLNamedCurve(curve) {\n        switch(curve.toUpperCase()){\n            case \"P-256\":\n                return \"prime256v1\";\n            case \"K-256\":\n                return \"secp256k1\";\n            case \"P-384\":\n                return \"secp384r1\";\n            case \"P-521\":\n                return \"secp521r1\";\n            default:\n                return curve;\n        }\n    }\n}\nEcCrypto.publicKeyUsages = [\n    \"verify\"\n];\nEcCrypto.privateKeyUsages = [\n    \"sign\",\n    \"deriveKey\",\n    \"deriveBits\"\n];\nclass EcdsaProvider extends core__namespace.EcdsaProvider {\n    constructor(){\n        super(...arguments);\n        this.namedCurves = core__namespace.EcCurves.names;\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\",\n            \"shake128\",\n            \"shake256\",\n            \"SHA3-256\",\n            \"SHA3-384\",\n            \"SHA3-512\"\n        ];\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EcCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return EcCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return EcCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return EcCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EcCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\n            throw new TypeError(\"key: Is not EC CryptoKey\");\n        }\n    }\n}\nclass EcdhProvider extends core__namespace.EcdhProvider {\n    constructor(){\n        super(...arguments);\n        this.namedCurves = core__namespace.EcCurves.names;\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EcCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onExportKey(format, key) {\n        return EcCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EcCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\n            throw new TypeError(\"key: Is not EC CryptoKey\");\n        }\n    }\n    async onDeriveBits(algorithm, baseKey, length) {\n        const bits = await EcCrypto.deriveBits({\n            ...algorithm,\n            public: getCryptoKey(algorithm.public)\n        }, getCryptoKey(baseKey), length);\n        return bits;\n    }\n}\nconst edOIDs = {\n    [core__namespace.asn1.idEd448]: \"Ed448\",\n    \"ed448\": core__namespace.asn1.idEd448,\n    [core__namespace.asn1.idX448]: \"X448\",\n    \"x448\": core__namespace.asn1.idX448,\n    [core__namespace.asn1.idEd25519]: \"Ed25519\",\n    \"ed25519\": core__namespace.asn1.idEd25519,\n    [core__namespace.asn1.idX25519]: \"X25519\",\n    \"x25519\": core__namespace.asn1.idX25519\n};\nfunction getOidByNamedCurve(namedCurve) {\n    const oid = edOIDs[namedCurve.toLowerCase()];\n    if (!oid) {\n        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\n    }\n    return oid;\n}\nclass EdPrivateKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"private\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"OKP\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);\n        const key = jsonSchema.JsonParser.fromJSON(json, {\n            targetSchema: core__namespace.asn1.CurvePrivateKey\n        });\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\nclass EdPublicKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"public\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\n        return keyInfo.publicKey;\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"OKP\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, {\n            x: pvtsutils.Convert.ToBase64Url(key)\n        });\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        if (!json.x) {\n            throw new core__namespace.OperationError(`Cannot get property from JWK. Property 'x' is required`);\n        }\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);\n        keyInfo.publicKey = pvtsutils.Convert.FromBase64Url(json.x);\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\nclass EdCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const privateKey = new EdPrivateKey();\n        privateKey.algorithm = algorithm;\n        privateKey.extractable = extractable;\n        privateKey.usages = keyUsages.filter((usage)=>this.privateKeyUsages.indexOf(usage) !== -1);\n        const publicKey = new EdPublicKey();\n        publicKey.algorithm = algorithm;\n        publicKey.extractable = true;\n        publicKey.usages = keyUsages.filter((usage)=>this.publicKeyUsages.indexOf(usage) !== -1);\n        const type = algorithm.namedCurve.toLowerCase();\n        const keys = crypto.generateKeyPairSync(type, {\n            publicKeyEncoding: {\n                format: \"der\",\n                type: \"spki\"\n            },\n            privateKeyEncoding: {\n                format: \"der\",\n                type: \"pkcs8\"\n            }\n        });\n        privateKey.data = keys.privateKey;\n        publicKey.data = keys.publicKey;\n        const res = {\n            privateKey,\n            publicKey\n        };\n        return res;\n    }\n    static async sign(algorithm, key, data) {\n        if (!key.pem) {\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        const signature = crypto.sign(null, Buffer.from(data), options);\n        return core__namespace.BufferSourceConverter.toArrayBuffer(signature);\n    }\n    static async verify(algorithm, key, signature, data) {\n        if (!key.pem) {\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        const ok = crypto.verify(null, Buffer.from(data), options, Buffer.from(signature));\n        return ok;\n    }\n    static async deriveBits(algorithm, baseKey, length) {\n        const publicKey = crypto.createPublicKey({\n            key: algorithm.public.data,\n            format: \"der\",\n            type: \"spki\"\n        });\n        const privateKey = crypto.createPrivateKey({\n            key: baseKey.data,\n            format: \"der\",\n            type: \"pkcs8\"\n        });\n        const bits = crypto.diffieHellman({\n            publicKey,\n            privateKey\n        });\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\n    }\n    static async exportKey(format, key) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(key);\n            case \"pkcs8\":\n            case \"spki\":\n                return new Uint8Array(key.data).buffer;\n            case \"raw\":\n                {\n                    const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);\n                    return publicKeyInfo.publicKey;\n                }\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                {\n                    const jwk = keyData;\n                    if (jwk.d) {\n                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {\n                            targetSchema: core__namespace.asn1.CurvePrivateKey\n                        });\n                        return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                    } else {\n                        if (!jwk.x) {\n                            throw new TypeError(\"keyData: Cannot get required 'x' filed\");\n                        }\n                        return this.importPublicKey(pvtsutils.Convert.FromBase64Url(jwk.x), algorithm, extractable, keyUsages);\n                    }\n                }\n            case \"raw\":\n                {\n                    return this.importPublicKey(keyData, algorithm, extractable, keyUsages);\n                }\n            case \"spki\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\n                    return this.importPublicKey(keyInfo.publicKey, algorithm, extractable, keyUsages);\n                }\n            case \"pkcs8\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\n                    const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\n        }\n    }\n    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\n        const key = new EdPrivateKey();\n        key.fromJSON({\n            crv: algorithm.namedCurve,\n            d: pvtsutils.Convert.ToBase64Url(asnKey.d)\n        });\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\n        const key = new EdPublicKey();\n        key.fromJSON({\n            crv: algorithm.namedCurve,\n            x: pvtsutils.Convert.ToBase64Url(asnKey)\n        });\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n}\nEdCrypto.publicKeyUsages = [\n    \"verify\"\n];\nEdCrypto.privateKeyUsages = [\n    \"sign\",\n    \"deriveKey\",\n    \"deriveBits\"\n];\nclass EdDsaProvider extends core__namespace.EdDsaProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EdCrypto.generateKey({\n            name: this.name,\n            namedCurve: algorithm.namedCurve.replace(/^ed/i, \"Ed\")\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return EdCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return EdCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return EdCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EdCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n}\nclass EcdhEsProvider extends core__namespace.EcdhEsProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EdCrypto.generateKey({\n            name: this.name,\n            namedCurve: algorithm.namedCurve.toUpperCase()\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onDeriveBits(algorithm, baseKey, length) {\n        const bits = await EdCrypto.deriveBits({\n            ...algorithm,\n            public: getCryptoKey(algorithm.public)\n        }, getCryptoKey(baseKey), length);\n        return bits;\n    }\n    async onExportKey(format, key) {\n        return EdCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EdCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n}\nclass PbkdfCryptoKey extends CryptoKey {\n}\nclass Pbkdf2Provider extends core__namespace.Pbkdf2Provider {\n    async onDeriveBits(algorithm, baseKey, length) {\n        return new Promise((resolve, reject)=>{\n            const salt = core__namespace.BufferSourceConverter.toArrayBuffer(algorithm.salt);\n            const hash = algorithm.hash.name.replace(\"-\", \"\");\n            crypto.pbkdf2(getCryptoKey(baseKey).data, Buffer.from(salt), algorithm.iterations, length >> 3, hash, (err, derivedBits)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(new Uint8Array(derivedBits).buffer);\n                }\n            });\n        });\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        if (format === \"raw\") {\n            const key = new PbkdfCryptoKey();\n            key.data = Buffer.from(keyData);\n            key.algorithm = {\n                name: this.name\n            };\n            key.extractable = false;\n            key.usages = keyUsages;\n            return setCryptoKey(key);\n        }\n        throw new core__namespace.OperationError(\"format: Must be 'raw'\");\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof PbkdfCryptoKey)) {\n            throw new TypeError(\"key: Is not PBKDF CryptoKey\");\n        }\n    }\n}\nclass HmacCryptoKey extends CryptoKey {\n    get alg() {\n        const hash = this.algorithm.hash.name.toUpperCase();\n        return `HS${hash.replace(\"SHA-\", \"\")}`;\n    }\n    set alg(value) {}\n}\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        name: \"k\",\n        converter: JsonBase64UrlConverter\n    })\n], HmacCryptoKey.prototype, \"data\", void 0);\nclass HmacProvider extends core__namespace.HmacProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const length = (algorithm.length || this.getDefaultLength(algorithm.hash.name)) >> 3 << 3;\n        const key = new HmacCryptoKey();\n        key.algorithm = {\n            ...algorithm,\n            length,\n            name: this.name\n        };\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        key.data = crypto.randomBytes(length >> 3);\n        return setCryptoKey(key);\n    }\n    async onSign(algorithm, key, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);\n        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data).update(Buffer.from(data)).digest();\n        return new Uint8Array(hmac).buffer;\n    }\n    async onVerify(algorithm, key, signature, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);\n        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data).update(Buffer.from(data)).digest();\n        return hmac.compare(Buffer.from(signature)) === 0;\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        let key;\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                key = jsonSchema.JsonParser.fromJSON(keyData, {\n                    targetSchema: HmacCryptoKey\n                });\n                break;\n            case \"raw\":\n                key = new HmacCryptoKey();\n                key.data = Buffer.from(keyData);\n                break;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n        key.algorithm = {\n            hash: {\n                name: algorithm.hash.name\n            },\n            name: this.name,\n            length: key.data.length << 3\n        };\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return setCryptoKey(key);\n    }\n    async onExportKey(format, key) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(getCryptoKey(key));\n            case \"raw\":\n                return new Uint8Array(getCryptoKey(key).data).buffer;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof HmacCryptoKey)) {\n            throw new TypeError(\"key: Is not HMAC CryptoKey\");\n        }\n    }\n}\nclass HkdfCryptoKey extends CryptoKey {\n}\nclass HkdfProvider extends core__namespace.HkdfProvider {\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        if (format.toLowerCase() !== \"raw\") {\n            throw new core__namespace.OperationError(\"Operation not supported\");\n        }\n        const key = new HkdfCryptoKey();\n        key.data = Buffer.from(keyData);\n        key.algorithm = {\n            name: this.name\n        };\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return setCryptoKey(key);\n    }\n    async onDeriveBits(params, baseKey, length) {\n        const hash = params.hash.name.replace(\"-\", \"\");\n        const hashLength = crypto.createHash(hash).digest().length;\n        const byteLength = length / 8;\n        const info = core.BufferSourceConverter.toUint8Array(params.info);\n        const PRK = crypto.createHmac(hash, core.BufferSourceConverter.toUint8Array(params.salt)).update(core.BufferSourceConverter.toUint8Array(getCryptoKey(baseKey).data)).digest();\n        const blocks = [\n            Buffer.alloc(0)\n        ];\n        const blockCount = Math.ceil(byteLength / hashLength) + 1;\n        for(let i = 1; i < blockCount; ++i){\n            blocks.push(crypto.createHmac(hash, PRK).update(Buffer.concat([\n                blocks[i - 1],\n                info,\n                Buffer.from([\n                    i\n                ])\n            ])).digest());\n        }\n        return Buffer.concat(blocks).slice(0, byteLength);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof HkdfCryptoKey)) {\n            throw new TypeError(\"key: Is not HKDF CryptoKey\");\n        }\n    }\n}\nclass ShakeCrypto {\n    static digest(algorithm, data) {\n        const hash = crypto.createHash(algorithm.name.toLowerCase(), {\n            outputLength: algorithm.length\n        }).update(Buffer.from(data)).digest();\n        return new Uint8Array(hash).buffer;\n    }\n}\nclass Shake128Provider extends core__namespace.Shake128Provider {\n    async onDigest(algorithm, data) {\n        return ShakeCrypto.digest(algorithm, data);\n    }\n}\nclass Shake256Provider extends core__namespace.Shake256Provider {\n    async onDigest(algorithm, data) {\n        return ShakeCrypto.digest(algorithm, data);\n    }\n}\nclass SubtleCrypto extends core__namespace.SubtleCrypto {\n    constructor(){\n        var _a;\n        super();\n        this.providers.set(new AesCbcProvider());\n        this.providers.set(new AesCtrProvider());\n        this.providers.set(new AesGcmProvider());\n        this.providers.set(new AesCmacProvider());\n        this.providers.set(new AesKwProvider());\n        this.providers.set(new AesEcbProvider());\n        this.providers.set(new DesCbcProvider());\n        this.providers.set(new DesEde3CbcProvider());\n        this.providers.set(new RsaSsaProvider());\n        this.providers.set(new RsaPssProvider());\n        this.providers.set(new RsaOaepProvider());\n        this.providers.set(new RsaEsProvider());\n        this.providers.set(new EcdsaProvider());\n        this.providers.set(new EcdhProvider());\n        this.providers.set(new Sha1Provider());\n        this.providers.set(new Sha256Provider());\n        this.providers.set(new Sha384Provider());\n        this.providers.set(new Sha512Provider());\n        this.providers.set(new Pbkdf2Provider());\n        this.providers.set(new HmacProvider());\n        this.providers.set(new HkdfProvider());\n        const nodeMajorVersion = (_a = /^v(\\d+)/.exec(process__namespace.version)) === null || _a === void 0 ? void 0 : _a[1];\n        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 12) {\n            this.providers.set(new Shake128Provider());\n            this.providers.set(new Shake256Provider());\n        }\n        const hashes = crypto__namespace.getHashes();\n        if (hashes.includes(\"sha3-256\")) {\n            this.providers.set(new Sha3256Provider());\n        }\n        if (hashes.includes(\"sha3-384\")) {\n            this.providers.set(new Sha3384Provider());\n        }\n        if (hashes.includes(\"sha3-512\")) {\n            this.providers.set(new Sha3512Provider());\n        }\n        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 14) {\n            this.providers.set(new EdDsaProvider());\n            this.providers.set(new EcdhEsProvider());\n        }\n    }\n}\nclass Crypto extends core__namespace.Crypto {\n    constructor(){\n        super(...arguments);\n        this.subtle = new SubtleCrypto();\n    }\n    getRandomValues(array) {\n        if (!ArrayBuffer.isView(array)) {\n            throw new TypeError(\"Failed to execute 'getRandomValues' on 'Crypto': parameter 1 is not of type 'ArrayBufferView'\");\n        }\n        const buffer = Buffer.from(array.buffer, array.byteOffset, array.byteLength);\n        crypto.randomFillSync(buffer);\n        return array;\n    }\n}\nObject.defineProperty(exports, \"CryptoKey\", ({\n    enumerable: true,\n    get: function() {\n        return core.CryptoKey;\n    }\n}));\nexports.Crypto = Crypto;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcGVjdWxpYXIvd2ViY3J5cHRvL2J1aWxkL3dlYmNyeXB0by5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQSxHQUVBO0FBRUEsSUFBSUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUMsU0FBU0QsbUJBQU9BLENBQUM7QUFDckIsSUFBSUUsVUFBVUYsbUJBQU9BLENBQUM7QUFDdEIsSUFBSUcsUUFBUUgsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUksYUFBYUosbUJBQU9BLENBQUM7QUFDekIsSUFBSUssWUFBWUwsbUJBQU9BLENBQUM7QUFDeEIsSUFBSU0sYUFBYU4sbUJBQU9BLENBQUM7QUFFekIsU0FBU08seUJBQXlCQyxDQUFDO0lBQ2pDLElBQUlDLElBQUlDLE9BQU9DLE1BQU0sQ0FBQztJQUN0QixJQUFJSCxHQUFHO1FBQ0xFLE9BQU9FLElBQUksQ0FBQ0osR0FBR0ssT0FBTyxDQUFDLFNBQVVDLENBQUM7WUFDaEMsSUFBSUEsTUFBTSxXQUFXO2dCQUNuQixJQUFJQyxJQUFJTCxPQUFPTSx3QkFBd0IsQ0FBQ1IsR0FBR007Z0JBQzNDSixPQUFPTyxjQUFjLENBQUNSLEdBQUdLLEdBQUdDLEVBQUVHLEdBQUcsR0FBR0gsSUFBSTtvQkFDdENJLFlBQVk7b0JBQ1pELEtBQUs7d0JBQWMsT0FBT1YsQ0FBQyxDQUFDTSxFQUFFO29CQUFFO2dCQUNsQztZQUNGO1FBQ0Y7SUFDRjtJQUNBTCxFQUFFVyxPQUFPLEdBQUdaO0lBQ1osT0FBT0UsT0FBT1csTUFBTSxDQUFDWjtBQUN2QjtBQUVBLElBQUlhLGtCQUFrQixXQUFXLEdBQUVmLHlCQUF5QlI7QUFDNUQsSUFBSXdCLG9CQUFvQixXQUFXLEdBQUVoQix5QkFBeUJOO0FBQzlELElBQUl1QixxQkFBcUIsV0FBVyxHQUFFakIseUJBQXlCTDtBQUUvRCxNQUFNdUIseUJBQXlCO0lBQzNCQyxVQUFVLENBQUNDLFFBQVVDLE9BQU9DLElBQUksQ0FBQ3hCLFVB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QixJQUFJLENBQUNOLFNBQVMsQ0FBQ2pVLEdBQUcsQ0FBQyxJQUFJZ1A7UUFDM0I7UUFDQSxJQUFJcUYsT0FBT0UsUUFBUSxDQUFDLGFBQWE7WUFDN0IsSUFBSSxDQUFDTixTQUFTLENBQUNqVSxHQUFHLENBQUMsSUFBSWlQO1FBQzNCO1FBQ0EsSUFBSWlGLG9CQUFvQkUsU0FBU0Ysa0JBQWtCLE9BQU8sSUFBSTtZQUMxRCxJQUFJLENBQUNELFNBQVMsQ0FBQ2pVLEdBQUcsQ0FBQyxJQUFJa1M7WUFDdkIsSUFBSSxDQUFDK0IsU0FBUyxDQUFDalUsR0FBRyxDQUFDLElBQUltUztRQUMzQjtJQUNKO0FBQ0o7QUFFQSxNQUFNcUMsZUFBZXRYLGdCQUFnQnNYLE1BQU07SUFDdkN6VyxhQUFjO1FBQ1YsS0FBSyxJQUFJQztRQUNULElBQUksQ0FBQ3lXLE1BQU0sR0FBRyxJQUFJVjtJQUN0QjtJQUNBVyxnQkFBZ0JDLEtBQUssRUFBRTtRQUNuQixJQUFJLENBQUNDLFlBQVlDLE1BQU0sQ0FBQ0YsUUFBUTtZQUM1QixNQUFNLElBQUluUixVQUFVO1FBQ3hCO1FBQ0EsTUFBTTdDLFNBQVNuRCxPQUFPQyxJQUFJLENBQUNrWCxNQUFNaFUsTUFBTSxFQUFFZ1UsTUFBTUcsVUFBVSxFQUFFSCxNQUFNeEwsVUFBVTtRQUMzRXROLE9BQU84USxjQUFjLENBQUNoTTtRQUN0QixPQUFPZ1U7SUFDWDtBQUNKO0FBRUFyWSw2Q0FBNEM7SUFDMUNTLFlBQVk7SUFDWkQsS0FBSztRQUFjLE9BQU9uQixLQUFLbUMsU0FBUztJQUFFO0FBQzVDLENBQUMsRUFBQztBQUNGaVgsY0FBYyxHQUFHUCIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLW1ha2V0cGxhY2UtYWRtaW4vLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL3dlYmNyeXB0by9idWlsZC93ZWJjcnlwdG8uanM/ZDAzMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiBDb3B5cmlnaHQgKGMpIFBlY3VsaWFyIFZlbnR1cmVzLCBMTENcbiovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNvcmUgPSByZXF1aXJlKCd3ZWJjcnlwdG8tY29yZScpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIHByb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzJyk7XG52YXIgdHNsaWIgPSByZXF1aXJlKCd0c2xpYicpO1xudmFyIGpzb25TY2hlbWEgPSByZXF1aXJlKCdAcGVjdWxpYXIvanNvbi1zY2hlbWEnKTtcbnZhciBwdnRzdXRpbHMgPSByZXF1aXJlKCdwdnRzdXRpbHMnKTtcbnZhciBhc24xU2NoZW1hID0gcmVxdWlyZSgnQHBlY3VsaWFyL2FzbjEtc2NoZW1hJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChlKSB7XG4gIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgaWYgKGUpIHtcbiAgICBPYmplY3Qua2V5cyhlKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgIHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZVtrXTsgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBuLmRlZmF1bHQgPSBlO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuKTtcbn1cblxudmFyIGNvcmVfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoY29yZSk7XG52YXIgY3J5cHRvX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KGNyeXB0byk7XG52YXIgcHJvY2Vzc19fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChwcm9jZXNzKTtcblxuY29uc3QgSnNvbkJhc2U2NFVybENvbnZlcnRlciA9IHtcclxuICAgIGZyb21KU09OOiAodmFsdWUpID0+IEJ1ZmZlci5mcm9tKHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwodmFsdWUpKSxcclxuICAgIHRvSlNPTjogKHZhbHVlKSA9PiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybCh2YWx1ZSksXHJcbn07XG5cbmNsYXNzIENyeXB0b0tleSBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5DcnlwdG9LZXkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIuYWxsb2MoMCk7XHJcbiAgICAgICAgdGhpcy5hbGdvcml0aG0gPSB7IG5hbWU6IFwiXCIgfTtcclxuICAgICAgICB0aGlzLmV4dHJhY3RhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJzZWNyZXRcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMua3R5ID0gXCJvY3RcIjtcclxuICAgICAgICB0aGlzLmFsZyA9IFwiXCI7XHJcbiAgICB9XHJcbn1cclxudHNsaWIuX19kZWNvcmF0ZShbXHJcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJleHRcIiwgdHlwZToganNvblNjaGVtYS5Kc29uUHJvcFR5cGVzLkJvb2xlYW4sIG9wdGlvbmFsOiB0cnVlIH0pXHJcbl0sIENyeXB0b0tleS5wcm90b3R5cGUsIFwiZXh0cmFjdGFibGVcIiwgdm9pZCAwKTtcclxudHNsaWIuX19kZWNvcmF0ZShbXHJcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJrZXlfb3BzXCIsIHR5cGU6IGpzb25TY2hlbWEuSnNvblByb3BUeXBlcy5TdHJpbmcsIHJlcGVhdGVkOiB0cnVlLCBvcHRpb25hbDogdHJ1ZSB9KVxyXG5dLCBDcnlwdG9LZXkucHJvdG90eXBlLCBcInVzYWdlc1wiLCB2b2lkIDApO1xyXG50c2xpYi5fX2RlY29yYXRlKFtcclxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyB0eXBlOiBqc29uU2NoZW1hLkpzb25Qcm9wVHlwZXMuU3RyaW5nIH0pXHJcbl0sIENyeXB0b0tleS5wcm90b3R5cGUsIFwia3R5XCIsIHZvaWQgMCk7XHJcbnRzbGliLl9fZGVjb3JhdGUoW1xyXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IHR5cGU6IGpzb25TY2hlbWEuSnNvblByb3BUeXBlcy5TdHJpbmcsIG9wdGlvbmFsOiB0cnVlIH0pXHJcbl0sIENyeXB0b0tleS5wcm90b3R5cGUsIFwiYWxnXCIsIHZvaWQgMCk7XG5cbmNsYXNzIFN5bW1ldHJpY0tleSBleHRlbmRzIENyeXB0b0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMua3R5ID0gXCJvY3RcIjtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInNlY3JldFwiO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEFzeW1tZXRyaWNLZXkgZXh0ZW5kcyBDcnlwdG9LZXkge1xyXG59XG5cbmNsYXNzIEFlc0NyeXB0b0tleSBleHRlbmRzIFN5bW1ldHJpY0tleSB7XHJcbiAgICBnZXQgYWxnKCkge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5hbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtQ0JDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYEEke3RoaXMuYWxnb3JpdGhtLmxlbmd0aH1DQkNgO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNUUlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBBJHt0aGlzLmFsZ29yaXRobS5sZW5ndGh9Q1RSYDtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1HQ01cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgQSR7dGhpcy5hbGdvcml0aG0ubGVuZ3RofUdDTWA7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtS1dcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgQSR7dGhpcy5hbGdvcml0aG0ubGVuZ3RofUtXYDtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1DTUFDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYEEke3RoaXMuYWxnb3JpdGhtLmxlbmd0aH1DTUFDYDtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1FQ0JcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgQSR7dGhpcy5hbGdvcml0aG0ubGVuZ3RofUVDQmA7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLkFsZ29yaXRobUVycm9yKFwiVW5zdXBwb3J0ZWQgYWxnb3JpdGhtIG5hbWVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0IGFsZyh2YWx1ZSkge1xyXG4gICAgfVxyXG59XHJcbnRzbGliLl9fZGVjb3JhdGUoW1xyXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwia1wiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxDb252ZXJ0ZXIgfSlcclxuXSwgQWVzQ3J5cHRvS2V5LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG5cbmNvbnN0IGtleVN0b3JhZ2UgPSBuZXcgV2Vha01hcCgpO1xyXG5mdW5jdGlvbiBnZXRDcnlwdG9LZXkoa2V5KSB7XHJcbiAgICBjb25zdCByZXMgPSBrZXlTdG9yYWdlLmdldChrZXkpO1xyXG4gICAgaWYgKCFyZXMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiQ2Fubm90IGdldCBDcnlwdG9LZXkgZnJvbSBzZWN1cmUgc3RvcmFnZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gc2V0Q3J5cHRvS2V5KHZhbHVlKSB7XHJcbiAgICBjb25zdCBrZXkgPSBjb3JlX19uYW1lc3BhY2UuQ3J5cHRvS2V5LmNyZWF0ZSh2YWx1ZS5hbGdvcml0aG0sIHZhbHVlLnR5cGUsIHZhbHVlLmV4dHJhY3RhYmxlLCB2YWx1ZS51c2FnZXMpO1xyXG4gICAgT2JqZWN0LmZyZWV6ZShrZXkpO1xyXG4gICAga2V5U3RvcmFnZS5zZXQoa2V5LCB2YWx1ZSk7XHJcbiAgICByZXR1cm4ga2V5O1xyXG59XG5cbmNsYXNzIEFlc0NyeXB0byB7XHJcbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IEFlc0NyeXB0b0tleSgpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICBrZXkuZGF0YSA9IGNyeXB0by5yYW5kb21CeXRlcyhhbGdvcml0aG0ubGVuZ3RoID4+IDMpO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXk6IElzIG5vdCBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShrZXkuZGF0YSkuYnVmZmVyO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJyBvciAncmF3J1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgbGV0IGtleTtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIGtleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogQWVzQ3J5cHRvS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcclxuICAgICAgICAgICAgICAgIGtleSA9IG5ldyBBZXNDcnlwdG9LZXkoKTtcclxuICAgICAgICAgICAgICAgIGtleS5kYXRhID0gQnVmZmVyLmZyb20oa2V5RGF0YSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycgb3IgJ3JhdydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAga2V5LmFsZ29yaXRobS5sZW5ndGggPSBrZXkuZGF0YS5sZW5ndGggPDwgMztcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHN3aXRjaCAoa2V5LmFsZ29yaXRobS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY2FzZSAxMjg6XHJcbiAgICAgICAgICAgIGNhc2UgMTkyOlxyXG4gICAgICAgICAgICBjYXNlIDI1NjpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImtleURhdGE6IElzIHdyb25nIGtleSBsZW5ndGhcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdEFlc0NCQyhhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNUUlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdEFlc0NUUihhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUdDTVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdEFlc0dDTShhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUtXXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0QWVzS1coYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1FQ0JcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRBZXNFQ0IoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXk6IElzIG5vdCBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdEFlc0NCQyhhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNUUlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdEFlc0NUUihhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUdDTVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdEFlc0dDTShhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUtXXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0QWVzS1coYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1FQ0JcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRBZXNFQ0IoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0QWVzQ0JDKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tY2JjYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KGFsZ29yaXRobS5pdikpO1xyXG4gICAgICAgIGxldCBlbmMgPSBjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGVuYyA9IEJ1ZmZlci5jb25jYXQoW2VuYywgY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShlbmMpLmJ1ZmZlcjtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHRBZXNDQkMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tY2JjYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KGFsZ29yaXRobS5pdikpO1xyXG4gICAgICAgIGxldCBkZWMgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZGVjID0gQnVmZmVyLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHRBZXNDVFIoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1jdHJgLCBrZXkuZGF0YSwgQnVmZmVyLmZyb20oYWxnb3JpdGhtLmNvdW50ZXIpKTtcclxuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBlbmMgPSBCdWZmZXIuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0QWVzQ1RSKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWN0cmAsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheShhbGdvcml0aG0uY291bnRlcikpO1xyXG4gICAgICAgIGxldCBkZWMgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZGVjID0gQnVmZmVyLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHRBZXNHQ00oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1nY21gLCBrZXkuZGF0YSwgQnVmZmVyLmZyb20oYWxnb3JpdGhtLml2KSwge1xyXG4gICAgICAgICAgICBhdXRoVGFnTGVuZ3RoOiAoYWxnb3JpdGhtLnRhZ0xlbmd0aCB8fCAxMjgpID4+IDMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGFsZ29yaXRobS5hZGRpdGlvbmFsRGF0YSkge1xyXG4gICAgICAgICAgICBjaXBoZXIuc2V0QUFEKEJ1ZmZlci5mcm9tKGFsZ29yaXRobS5hZGRpdGlvbmFsRGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBlbmMgPSBCdWZmZXIuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpLCBjaXBoZXIuZ2V0QXV0aFRhZygpXSk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0QWVzR0NNKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWdjbWAsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheShhbGdvcml0aG0uaXYpKTtcclxuICAgICAgICBjb25zdCB0YWdMZW5ndGggPSAoYWxnb3JpdGhtLnRhZ0xlbmd0aCB8fCAxMjgpID4+IDM7XHJcbiAgICAgICAgY29uc3QgZW5jID0gZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIHRhZ0xlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgdGFnID0gZGF0YS5zbGljZShkYXRhLmxlbmd0aCAtIHRhZ0xlbmd0aCk7XHJcbiAgICAgICAgaWYgKGFsZ29yaXRobS5hZGRpdGlvbmFsRGF0YSkge1xyXG4gICAgICAgICAgICBkZWNpcGhlci5zZXRBQUQoQnVmZmVyLmZyb20oYWxnb3JpdGhtLmFkZGl0aW9uYWxEYXRhKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlY2lwaGVyLnNldEF1dGhUYWcodGFnKTtcclxuICAgICAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGVuYyk7XHJcbiAgICAgICAgZGVjID0gQnVmZmVyLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHRBZXNLVyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihgaWQtYWVzJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0td3JhcGAsIGtleS5kYXRhLCB0aGlzLkFFU19LV19JVik7XHJcbiAgICAgICAgbGV0IGVuYyA9IGNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZW5jID0gQnVmZmVyLmNvbmNhdChbZW5jLCBjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShlbmMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0QWVzS1coYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBpZC1hZXMke2tleS5hbGdvcml0aG0ubGVuZ3RofS13cmFwYCwga2V5LmRhdGEsIHRoaXMuQUVTX0tXX0lWKTtcclxuICAgICAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGRlYyA9IEJ1ZmZlci5jb25jYXQoW2RlYywgZGVjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0QWVzRUNCKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tZWNiYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KDApKTtcclxuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBlbmMgPSBCdWZmZXIuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0QWVzRUNCKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWVjYmAsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheSgwKSk7XHJcbiAgICAgICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBkZWMgPSBCdWZmZXIuY29uY2F0KFtkZWMsIGRlY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjKS5idWZmZXI7XHJcbiAgICB9XHJcbn1cclxuQWVzQ3J5cHRvLkFFU19LV19JViA9IEJ1ZmZlci5mcm9tKFwiQTZBNkE2QTZBNkE2QTZBNlwiLCBcImhleFwiKTtcblxuY2xhc3MgQWVzQ2JjUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuQWVzQ2JjUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmVuY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5kZWNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEFlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IGFsZ29yaXRobS5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IGEgQWVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jb25zdCB6ZXJvID0gQnVmZmVyLmZyb20oWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcclxuY29uc3QgcmIgPSBCdWZmZXIuZnJvbShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMTM1XSk7XHJcbmNvbnN0IGJsb2NrU2l6ZSA9IDE2O1xyXG5mdW5jdGlvbiBiaXRTaGlmdExlZnQoYnVmZmVyKSB7XHJcbiAgICBjb25zdCBzaGlmdGVkID0gQnVmZmVyLmFsbG9jKGJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgY29uc3QgbGFzdCA9IGJ1ZmZlci5sZW5ndGggLSAxO1xyXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxhc3Q7IGluZGV4KyspIHtcclxuICAgICAgICBzaGlmdGVkW2luZGV4XSA9IGJ1ZmZlcltpbmRleF0gPDwgMTtcclxuICAgICAgICBpZiAoYnVmZmVyW2luZGV4ICsgMV0gJiAweDgwKSB7XHJcbiAgICAgICAgICAgIHNoaWZ0ZWRbaW5kZXhdICs9IDB4MDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2hpZnRlZFtsYXN0XSA9IGJ1ZmZlcltsYXN0XSA8PCAxO1xyXG4gICAgcmV0dXJuIHNoaWZ0ZWQ7XHJcbn1cclxuZnVuY3Rpb24geG9yKGEsIGIpIHtcclxuICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XHJcbiAgICBjb25zdCBvdXRwdXQgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICBvdXRwdXRbaW5kZXhdID0gYVtpbmRleF0gXiBiW2luZGV4XTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuZnVuY3Rpb24gYWVzKGtleSwgbWVzc2FnZSkge1xyXG4gICAgY29uc3QgY2lwaGVyID0gY3J5cHRvX19uYW1lc3BhY2UuY3JlYXRlQ2lwaGVyaXYoYGFlcyR7a2V5Lmxlbmd0aCA8PCAzfWAsIGtleSwgemVybyk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBjaXBoZXIudXBkYXRlKG1lc3NhZ2UpO1xyXG4gICAgY2lwaGVyLmZpbmFsKCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGdldE1lc3NhZ2VCbG9jayhtZXNzYWdlLCBibG9ja0luZGV4KSB7XHJcbiAgICBjb25zdCBibG9jayA9IEJ1ZmZlci5hbGxvYyhibG9ja1NpemUpO1xyXG4gICAgY29uc3Qgc3RhcnQgPSBibG9ja0luZGV4ICogYmxvY2tTaXplO1xyXG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBibG9ja1NpemU7XHJcbiAgICBtZXNzYWdlLmNvcHkoYmxvY2ssIDAsIHN0YXJ0LCBlbmQpO1xyXG4gICAgcmV0dXJuIGJsb2NrO1xyXG59XHJcbmZ1bmN0aW9uIGdldFBhZGRlZE1lc3NhZ2VCbG9jayhtZXNzYWdlLCBibG9ja0luZGV4KSB7XHJcbiAgICBjb25zdCBibG9jayA9IEJ1ZmZlci5hbGxvYyhibG9ja1NpemUpO1xyXG4gICAgY29uc3Qgc3RhcnQgPSBibG9ja0luZGV4ICogYmxvY2tTaXplO1xyXG4gICAgY29uc3QgZW5kID0gbWVzc2FnZS5sZW5ndGg7XHJcbiAgICBibG9jay5maWxsKDApO1xyXG4gICAgbWVzc2FnZS5jb3B5KGJsb2NrLCAwLCBzdGFydCwgZW5kKTtcclxuICAgIGJsb2NrW2VuZCAtIHN0YXJ0XSA9IDB4ODA7XHJcbiAgICByZXR1cm4gYmxvY2s7XHJcbn1cclxuZnVuY3Rpb24gZ2VuZXJhdGVTdWJrZXlzKGtleSkge1xyXG4gICAgY29uc3QgbCA9IGFlcyhrZXksIHplcm8pO1xyXG4gICAgbGV0IHN1YmtleTEgPSBiaXRTaGlmdExlZnQobCk7XHJcbiAgICBpZiAobFswXSAmIDB4ODApIHtcclxuICAgICAgICBzdWJrZXkxID0geG9yKHN1YmtleTEsIHJiKTtcclxuICAgIH1cclxuICAgIGxldCBzdWJrZXkyID0gYml0U2hpZnRMZWZ0KHN1YmtleTEpO1xyXG4gICAgaWYgKHN1YmtleTFbMF0gJiAweDgwKSB7XHJcbiAgICAgICAgc3Via2V5MiA9IHhvcihzdWJrZXkyLCByYik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBzdWJrZXkxLCBzdWJrZXkyIH07XHJcbn1cclxuZnVuY3Rpb24gYWVzQ21hYyhrZXksIG1lc3NhZ2UpIHtcclxuICAgIGNvbnN0IHN1YmtleXMgPSBnZW5lcmF0ZVN1YmtleXMoa2V5KTtcclxuICAgIGxldCBibG9ja0NvdW50ID0gTWF0aC5jZWlsKG1lc3NhZ2UubGVuZ3RoIC8gYmxvY2tTaXplKTtcclxuICAgIGxldCBsYXN0QmxvY2tDb21wbGV0ZUZsYWc7XHJcbiAgICBsZXQgbGFzdEJsb2NrO1xyXG4gICAgaWYgKGJsb2NrQ291bnQgPT09IDApIHtcclxuICAgICAgICBibG9ja0NvdW50ID0gMTtcclxuICAgICAgICBsYXN0QmxvY2tDb21wbGV0ZUZsYWcgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxhc3RCbG9ja0NvbXBsZXRlRmxhZyA9IChtZXNzYWdlLmxlbmd0aCAlIGJsb2NrU2l6ZSA9PT0gMCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsYXN0QmxvY2tJbmRleCA9IGJsb2NrQ291bnQgLSAxO1xyXG4gICAgaWYgKGxhc3RCbG9ja0NvbXBsZXRlRmxhZykge1xyXG4gICAgICAgIGxhc3RCbG9jayA9IHhvcihnZXRNZXNzYWdlQmxvY2sobWVzc2FnZSwgbGFzdEJsb2NrSW5kZXgpLCBzdWJrZXlzLnN1YmtleTEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGFzdEJsb2NrID0geG9yKGdldFBhZGRlZE1lc3NhZ2VCbG9jayhtZXNzYWdlLCBsYXN0QmxvY2tJbmRleCksIHN1YmtleXMuc3Via2V5Mik7XHJcbiAgICB9XHJcbiAgICBsZXQgeCA9IHplcm87XHJcbiAgICBsZXQgeTtcclxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsYXN0QmxvY2tJbmRleDsgaW5kZXgrKykge1xyXG4gICAgICAgIHkgPSB4b3IoeCwgZ2V0TWVzc2FnZUJsb2NrKG1lc3NhZ2UsIGluZGV4KSk7XHJcbiAgICAgICAgeCA9IGFlcyhrZXksIHkpO1xyXG4gICAgfVxyXG4gICAgeSA9IHhvcihsYXN0QmxvY2ssIHgpO1xyXG4gICAgcmV0dXJuIGFlcyhrZXksIHkpO1xyXG59XHJcbmNsYXNzIEFlc0NtYWNQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5BZXNDbWFjUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBhZXNDbWFjKGdldENyeXB0b0tleShrZXkpLmRhdGEsIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlMiA9IGF3YWl0IHRoaXMuc2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkuY29tcGFyZShCdWZmZXIuZnJvbShzaWduYXR1cmUyKSkgPT09IDA7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBBZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KHJlcyk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBBZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIEFlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgQWVzQ3RyUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuQWVzQ3RyUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmVuY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5kZWNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IEFlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IGFsZ29yaXRobS5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkocmVzKTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IGEgQWVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBBZXNHY21Qcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5BZXNHY21Qcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEFlc0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiBhbGdvcml0aG0ubGVuZ3RoLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZW5jcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmRlY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgQWVzQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgbmFtZTogYWxnb3JpdGhtLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShyZXMpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEFlc0t3UHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuQWVzS3dQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IEFlc0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiBhbGdvcml0aG0ubGVuZ3RoLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkocmVzKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IEFlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IGFsZ29yaXRobS5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkocmVzKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZW5jcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmRlY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEFlc0VjYlByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkFlc0VjYlByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgQWVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IGFsZ29yaXRobS5sZW5ndGgsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5lbmNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZGVjcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBBZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KHJlcyk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBBZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIEFlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRGVzQ3J5cHRvS2V5IGV4dGVuZHMgU3ltbWV0cmljS2V5IHtcclxuICAgIGdldCBhbGcoKSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIkRFUy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgREVTLUNCQ2A7XHJcbiAgICAgICAgICAgIGNhc2UgXCJERVMtRURFMy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgM0RFUy1DQkNgO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5BbGdvcml0aG1FcnJvcihcIlVuc3VwcG9ydGVkIGFsZ29yaXRobSBuYW1lXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldCBhbGcodmFsdWUpIHtcclxuICAgIH1cclxufVxyXG50c2xpYi5fX2RlY29yYXRlKFtcclxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImtcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQ29udmVydGVyIH0pXHJcbl0sIERlc0NyeXB0b0tleS5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuXG5jbGFzcyBEZXNDcnlwdG8ge1xyXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBEZXNDcnlwdG9LZXkoKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAga2V5LmRhdGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoYWxnb3JpdGhtLmxlbmd0aCA+PiAzKTtcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShrZXkuZGF0YSkuYnVmZmVyO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJyBvciAncmF3J1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgbGV0IGtleTtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIGtleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogRGVzQ3J5cHRvS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcclxuICAgICAgICAgICAgICAgIGtleSA9IG5ldyBEZXNDcnlwdG9LZXkoKTtcclxuICAgICAgICAgICAgICAgIGtleS5kYXRhID0gQnVmZmVyLmZyb20oa2V5RGF0YSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycgb3IgJ3JhdydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIkRFUy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHREZXNDQkMoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkRFUy1FREUzLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdERlc0VERTNDQkMoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluc3RhbmNlb2YgRGVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXk6IElzIG5vdCBEZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiREVTLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdERlc0NCQyhhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBjYXNlIFwiREVTLUVERTMtQ0JDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0RGVzRURFM0NCQyhhbGdvcml0aG0sIGtleSwgQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHREZXNDQkMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGRlcy1jYmNgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLml2KSk7XHJcbiAgICAgICAgbGV0IGVuYyA9IGNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZW5jID0gQnVmZmVyLmNvbmNhdChbZW5jLCBjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGVuYykuYnVmZmVyO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdERlc0NCQyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoYGRlcy1jYmNgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLml2KSk7XHJcbiAgICAgICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBkZWMgPSBCdWZmZXIuY29uY2F0KFtkZWMsIGRlY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdERlc0VERTNDQkMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGRlcy1lZGUzLWNiY2AsIGtleS5kYXRhLCBCdWZmZXIuZnJvbShhbGdvcml0aG0uaXYpKTtcclxuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBlbmMgPSBCdWZmZXIuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0RGVzRURFM0NCQyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoYGRlcy1lZGUzLWNiY2AsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheShhbGdvcml0aG0uaXYpKTtcclxuICAgICAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGRlYyA9IEJ1ZmZlci5jb25jYXQoW2RlYywgZGVjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcclxuICAgIH1cclxufVxuXG5jbGFzcyBEZXNDYmNQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5EZXNQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMua2V5U2l6ZUJpdHMgPSA2NDtcclxuICAgICAgICB0aGlzLml2U2l6ZSA9IDg7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJERVMtQ0JDXCI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IERlc0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLmtleVNpemVCaXRzLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBEZXNDcnlwdG8uZW5jcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gRGVzQ3J5cHRvLmRlY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gRGVzQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRGVzQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgbmFtZTogdGhpcy5uYW1lLCBsZW5ndGg6IHRoaXMua2V5U2l6ZUJpdHMgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgaWYgKGtleS5kYXRhLmxlbmd0aCAhPT0gKHRoaXMua2V5U2l6ZUJpdHMgPj4gMykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImtleURhdGE6IFdyb25nIGtleSBzaXplXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBEZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIERlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRGVzRWRlM0NiY1Byb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkRlc1Byb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5rZXlTaXplQml0cyA9IDE5MjtcclxuICAgICAgICB0aGlzLml2U2l6ZSA9IDg7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJERVMtRURFMy1DQkNcIjtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRGVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IHRoaXMua2V5U2l6ZUJpdHMsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIERlc0NyeXB0by5lbmNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBEZXNDcnlwdG8uZGVjcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBEZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBEZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiB0aGlzLm5hbWUsIGxlbmd0aDogdGhpcy5rZXlTaXplQml0cyB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICBpZiAoa2V5LmRhdGEubGVuZ3RoICE9PSAodGhpcy5rZXlTaXplQml0cyA+PiAzKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwia2V5RGF0YTogV3Jvbmcga2V5IHNpemVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIERlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IGEgRGVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBnZXRKd2tBbGdvcml0aG0oYWxnb3JpdGhtKSB7XHJcbiAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICBjYXNlIFwiUlNBLU9BRVBcIjoge1xyXG4gICAgICAgICAgICBjb25zdCBtZFNpemUgPSAvKFxcZCspJC8uZXhlYyhhbGdvcml0aG0uaGFzaC5uYW1lKVsxXTtcclxuICAgICAgICAgICAgcmV0dXJuIGBSU0EtT0FFUCR7bWRTaXplICE9PSBcIjFcIiA/IGAtJHttZFNpemV9YCA6IFwiXCJ9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcIlJTQVNTQS1QS0NTMS1WMV81XCI6XHJcbiAgICAgICAgICAgIHJldHVybiBgUlMkey8oXFxkKykkLy5leGVjKGFsZ29yaXRobS5oYXNoLm5hbWUpWzFdfWA7XHJcbiAgICAgICAgY2FzZSBcIlJTQS1QU1NcIjpcclxuICAgICAgICAgICAgcmV0dXJuIGBQUyR7LyhcXGQrKSQvLmV4ZWMoYWxnb3JpdGhtLmhhc2gubmFtZSlbMV19YDtcclxuICAgICAgICBjYXNlIFwiUlNBLVBLQ1MxXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBgUlMxYDtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBSc2FQcml2YXRlS2V5IGV4dGVuZHMgQXN5bW1ldHJpY0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwicHJpdmF0ZVwiO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5KCkge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZSh0aGlzLmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICByZXR1cm4gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5SW5mby5wcml2YXRlS2V5LCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQcml2YXRlS2V5KTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xyXG4gICAgICAgIGNvbnN0IGpzb24gPSB7XHJcbiAgICAgICAgICAgIGt0eTogXCJSU0FcIixcclxuICAgICAgICAgICAgYWxnOiBnZXRKd2tBbGdvcml0aG0odGhpcy5hbGdvcml0aG0pLFxyXG4gICAgICAgICAgICBrZXlfb3BzOiB0aGlzLnVzYWdlcyxcclxuICAgICAgICAgICAgZXh0OiB0aGlzLmV4dHJhY3RhYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oanNvbiwganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KSk7XHJcbiAgICB9XHJcbiAgICBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGpzb24sIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQcml2YXRlS2V5IH0pO1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjExMzU0OS4xLjEuMVwiO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gbnVsbDtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXkgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleSk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUnNhUHVibGljS2V5IGV4dGVuZHMgQXN5bW1ldHJpY0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwicHVibGljXCI7XHJcbiAgICB9XHJcbiAgICBnZXRLZXkoKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHRoaXMuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbyk7XHJcbiAgICAgICAgcmV0dXJuIGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHVibGljS2V5LCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQdWJsaWNLZXkpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KCk7XHJcbiAgICAgICAgY29uc3QganNvbiA9IHtcclxuICAgICAgICAgICAga3R5OiBcIlJTQVwiLFxyXG4gICAgICAgICAgICBhbGc6IGdldEp3a0FsZ29yaXRobSh0aGlzLmFsZ29yaXRobSksXHJcbiAgICAgICAgICAgIGtleV9vcHM6IHRoaXMudXNhZ2VzLFxyXG4gICAgICAgICAgICBleHQ6IHRoaXMuZXh0cmFjdGFibGUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihqc29uLCBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpKTtcclxuICAgIH1cclxuICAgIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oanNvbiwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLlJzYVB1YmxpY0tleSB9KTtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5hbGdvcml0aG0gPSBcIjEuMi44NDAuMTEzNTQ5LjEuMS4xXCI7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IG51bGw7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXkgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleSk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUnNhQ3J5cHRvIHtcclxuICAgIHN0YXRpYyBhc3luYyBnZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gbmV3IFJzYVByaXZhdGVLZXkoKTtcclxuICAgICAgICBwcml2YXRlS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBwcml2YXRlS2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAgcHJpdmF0ZUtleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wcml2YXRlS2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpICE9PSAtMSk7XHJcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IFJzYVB1YmxpY0tleSgpO1xyXG4gICAgICAgIHB1YmxpY0tleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAgcHVibGljS2V5LmV4dHJhY3RhYmxlID0gdHJ1ZTtcclxuICAgICAgICBwdWJsaWNLZXkudXNhZ2VzID0ga2V5VXNhZ2VzLmZpbHRlcigodXNhZ2UpID0+IHRoaXMucHVibGljS2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpICE9PSAtMSk7XHJcbiAgICAgICAgY29uc3QgcHVibGljRXhwb25lbnQgPSBCdWZmZXIuY29uY2F0KFtcclxuICAgICAgICAgICAgQnVmZmVyLmFsbG9jKDQgLSBhbGdvcml0aG0ucHVibGljRXhwb25lbnQuYnl0ZUxlbmd0aCwgMCksXHJcbiAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCksXHJcbiAgICAgICAgXSkucmVhZEludDMyQkUoMCk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGNyeXB0by5nZW5lcmF0ZUtleVBhaXJTeW5jKFwicnNhXCIsIHtcclxuICAgICAgICAgICAgbW9kdWx1c0xlbmd0aDogYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGgsXHJcbiAgICAgICAgICAgIHB1YmxpY0V4cG9uZW50LFxyXG4gICAgICAgICAgICBwdWJsaWNLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzcGtpXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJwa2NzOFwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHByaXZhdGVLZXkuZGF0YSA9IGtleXMucHJpdmF0ZUtleTtcclxuICAgICAgICBwdWJsaWNLZXkuZGF0YSA9IGtleXMucHVibGljS2V5O1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleSxcclxuICAgICAgICAgICAgcHVibGljS2V5LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBleHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpO1xyXG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjpcclxuICAgICAgICAgICAgY2FzZSBcInNwa2lcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShrZXkuZGF0YSkuYnVmZmVyO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJywgJ3BrY3M4JyBvciAnc3BraSdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBqd2sgPSBrZXlEYXRhO1xyXG4gICAgICAgICAgICAgICAgaWYgKGp3ay5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQcml2YXRlS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQdWJsaWNLZXkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5SW5mby5wdWJsaWNLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLlJzYVB1YmxpY0tleSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJwa2NzOFwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHJpdmF0ZUtleSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUnNhUHJpdmF0ZUtleSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJywgJ3BrY3M4JyBvciAnc3BraSdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIHNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlJTQS1QU1NcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlJTQVNTQS1QS0NTMS1WMV81XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduUnNhKGFsZ29yaXRobSwga2V5LCBkYXRhKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyB2ZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiUlNBLVBTU1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwiUlNBU1NBLVBLQ1MxLVYxXzVcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcmlmeVNTQShhbGdvcml0aG0sIGtleSwgZGF0YSwgc2lnbmF0dXJlKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJSU0EtT0FFUFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdE9BRVAoYWxnb3JpdGhtLCBrZXksIGRhdGEpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlJTQS1PQUVQXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0T0FFUChhbGdvcml0aG0sIGtleSwgZGF0YSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjExMzU0OS4xLjEuMVwiO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gbnVsbDtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXkgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGFzbktleSk7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IFJzYVByaXZhdGVLZXkoKTtcclxuICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0ucHVibGljRXhwb25lbnQgPSBuZXcgVWludDhBcnJheShhc25LZXkucHVibGljRXhwb25lbnQpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0ubW9kdWx1c0xlbmd0aCA9IGFzbktleS5tb2R1bHVzLmJ5dGVMZW5ndGggPDwgMztcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjExMzU0OS4xLjEuMVwiO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMgPSBudWxsO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5ID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShhc25LZXkpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBSc2FQdWJsaWNLZXkoKTtcclxuICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0ucHVibGljRXhwb25lbnQgPSBuZXcgVWludDhBcnJheShhc25LZXkucHVibGljRXhwb25lbnQpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0ubW9kdWx1c0xlbmd0aCA9IGFzbktleS5tb2R1bHVzLmJ5dGVMZW5ndGggPDwgMztcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0Q3J5cHRvQWxnb3JpdGhtKGFsZykge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnLmhhc2gubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUlNBLVNIQTFcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0yNTZcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlJTQS1TSEEyNTZcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0zODRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlJTQS1TSEEzODRcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS01MTJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlJTQS1TSEE1MTJcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMjU2XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBMy0yNTZcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMzg0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBMy0zODRcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtNTEyXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBMy01MTJcIjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG0uaGFzaDogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIHNpZ25Sc2EoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjcnlwdG9BbGcgPSB0aGlzLmdldENyeXB0b0FsZ29yaXRobShrZXkuYWxnb3JpdGhtKTtcclxuICAgICAgICBjb25zdCBzaWduZXIgPSBjcnlwdG8uY3JlYXRlU2lnbihjcnlwdG9BbGcpO1xyXG4gICAgICAgIHNpZ25lci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgIGlmICgha2V5LnBlbSkge1xyXG4gICAgICAgICAgICBrZXkucGVtID0gYC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleToga2V5LnBlbSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIlJTQS1QU1NcIikge1xyXG4gICAgICAgICAgICBvcHRpb25zLnBhZGRpbmcgPSBjcnlwdG8uY29uc3RhbnRzLlJTQV9QS0NTMV9QU1NfUEFERElORztcclxuICAgICAgICAgICAgb3B0aW9ucy5zYWx0TGVuZ3RoID0gYWxnb3JpdGhtLnNhbHRMZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25lci5zaWduKG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShzaWduYXR1cmUpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyB2ZXJpZnlTU0EoYWxnb3JpdGhtLCBrZXksIGRhdGEsIHNpZ25hdHVyZSkge1xyXG4gICAgICAgIGNvbnN0IGNyeXB0b0FsZyA9IHRoaXMuZ2V0Q3J5cHRvQWxnb3JpdGhtKGtleS5hbGdvcml0aG0pO1xyXG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGNyeXB0by5jcmVhdGVWZXJpZnkoY3J5cHRvQWxnKTtcclxuICAgICAgICBzaWduZXIudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICBpZiAoIWtleS5wZW0pIHtcclxuICAgICAgICAgICAga2V5LnBlbSA9IGAtLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2V5OiBrZXkucGVtLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkgPT09IFwiUlNBLVBTU1wiKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMucGFkZGluZyA9IGNyeXB0by5jb25zdGFudHMuUlNBX1BLQ1MxX1BTU19QQURESU5HO1xyXG4gICAgICAgICAgICBvcHRpb25zLnNhbHRMZW5ndGggPSBhbGdvcml0aG0uc2FsdExlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb2sgPSBzaWduZXIudmVyaWZ5KG9wdGlvbnMsIHNpZ25hdHVyZSk7XHJcbiAgICAgICAgcmV0dXJuIG9rO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGVuY3J5cHRPQUVQKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2V5OiBgLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLWAsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IGNyeXB0by5jb25zdGFudHMuUlNBX1BLQ1MxX09BRVBfUEFERElORyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChhbGdvcml0aG0ubGFiZWwpIDtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvLnB1YmxpY0VuY3J5cHQob3B0aW9ucywgZGF0YSkpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZWNyeXB0T0FFUChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleTogYC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLWAsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IGNyeXB0by5jb25zdGFudHMuUlNBX1BLQ1MxX09BRVBfUEFERElORyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChhbGdvcml0aG0ubGFiZWwpIDtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvLnByaXZhdGVEZWNyeXB0KG9wdGlvbnMsIGRhdGEpKS5idWZmZXI7XHJcbiAgICB9XHJcbn1cclxuUnNhQ3J5cHRvLnB1YmxpY0tleVVzYWdlcyA9IFtcInZlcmlmeVwiLCBcImVuY3J5cHRcIiwgXCJ3cmFwS2V5XCJdO1xyXG5Sc2FDcnlwdG8ucHJpdmF0ZUtleVVzYWdlcyA9IFtcInNpZ25cIiwgXCJkZWNyeXB0XCIsIFwidW53cmFwS2V5XCJdO1xuXG5jbGFzcyBSc2FTc2FQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Sc2FTc2FQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXHJcbiAgICAgICAgICAgIFwiU0hBLTFcIiwgXCJTSEEtMjU2XCIsIFwiU0hBLTM4NFwiLCBcIlNIQS01MTJcIixcclxuICAgICAgICAgICAgXCJzaGFrZTEyOFwiLCBcInNoYWtlMjU2XCIsXHJcbiAgICAgICAgICAgIFwiU0hBMy0yNTZcIiwgXCJTSEEzLTM4NFwiLCBcIlNIQTMtNTEyXCJcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgUnNhQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgLi4uYWxnb3JpdGhtLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25TaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFJzYUNyeXB0by5zaWduKGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uVmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLnZlcmlmeShhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShzaWduYXR1cmUpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBSc2FDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVByaXZhdGVLZXkgfHwgaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBSU0EgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBSc2FQc3NQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Sc2FQc3NQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXHJcbiAgICAgICAgICAgIFwiU0hBLTFcIiwgXCJTSEEtMjU2XCIsIFwiU0hBLTM4NFwiLCBcIlNIQS01MTJcIixcclxuICAgICAgICAgICAgXCJzaGFrZTEyOFwiLCBcInNoYWtlMjU2XCIsXHJcbiAgICAgICAgICAgIFwiU0hBMy0yNTZcIiwgXCJTSEEzLTM4NFwiLCBcIlNIQTMtNTEyXCJcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgUnNhQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgLi4uYWxnb3JpdGhtLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25TaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFJzYUNyeXB0by5zaWduKGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uVmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLnZlcmlmeShhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShzaWduYXR1cmUpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBSc2FDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVByaXZhdGVLZXkgfHwgaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBSU0EgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGFDcnlwdG8ge1xyXG4gICAgc3RhdGljIHNpemUoYWxnb3JpdGhtKSB7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE2MDtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0yNTZcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMjU2XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMjU2O1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTM4NFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiU0hBMy0zODRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiAzODQ7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtNTEyXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTUxMlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDUxMjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBuYW1lXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRBbGdvcml0aG1OYW1lKGFsZ29yaXRobSkge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTFcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTFcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0yNTZcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTI1NlwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTM4NFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2hhMzg0XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtNTEyXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGE1MTJcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMjU2XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGEzLTI1NlwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBMy0zODRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTMtMzg0XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTUxMlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2hhMy01MTJcIjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBuYW1lXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBkaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgaGFzaEFsZyA9IHRoaXMuZ2V0QWxnb3JpdGhtTmFtZShhbGdvcml0aG0pO1xyXG4gICAgICAgIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChoYXNoQWxnKVxyXG4gICAgICAgICAgICAudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKS5kaWdlc3QoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGFzaCkuYnVmZmVyO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFJzYU9hZXBQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Sc2FPYWVwUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgUnNhQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgLi4uYWxnb3JpdGhtLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xyXG4gICAgICAgIGNvbnN0IGtleVNpemUgPSBNYXRoLmNlaWwoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggPj4gMyk7XHJcbiAgICAgICAgY29uc3QgaGFzaFNpemUgPSBTaGFDcnlwdG8uc2l6ZShpbnRlcm5hbEtleS5hbGdvcml0aG0uaGFzaCkgPj4gMztcclxuICAgICAgICBjb25zdCBkYXRhTGVuZ3RoID0gZGF0YVZpZXcuYnl0ZUxlbmd0aDtcclxuICAgICAgICBjb25zdCBwc0xlbmd0aCA9IGtleVNpemUgLSBkYXRhTGVuZ3RoIC0gMiAqIGhhc2hTaXplIC0gMjtcclxuICAgICAgICBpZiAoZGF0YUxlbmd0aCA+IGtleVNpemUgLSAyICogaGFzaFNpemUgLSAyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgdG9vIGxhcmdlXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkoa2V5U2l6ZSk7XHJcbiAgICAgICAgY29uc3Qgc2VlZCA9IG1lc3NhZ2Uuc3ViYXJyYXkoMSwgaGFzaFNpemUgKyAxKTtcclxuICAgICAgICBjb25zdCBkYXRhQmxvY2sgPSBtZXNzYWdlLnN1YmFycmF5KGhhc2hTaXplICsgMSk7XHJcbiAgICAgICAgZGF0YUJsb2NrLnNldChkYXRhVmlldywgaGFzaFNpemUgKyBwc0xlbmd0aCArIDEpO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsSGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoLm5hbWUucmVwbGFjZShcIi1cIiwgXCJcIikpXHJcbiAgICAgICAgICAgIC51cGRhdGUoY29yZV9fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoYWxnb3JpdGhtLmxhYmVsIHx8IG5ldyBVaW50OEFycmF5KDApKSlcclxuICAgICAgICAgICAgLmRpZ2VzdCgpO1xyXG4gICAgICAgIGRhdGFCbG9jay5zZXQobGFiZWxIYXNoLCAwKTtcclxuICAgICAgICBkYXRhQmxvY2tbaGFzaFNpemUgKyBwc0xlbmd0aF0gPSAxO1xyXG4gICAgICAgIGNyeXB0by5yYW5kb21GaWxsU3luYyhzZWVkKTtcclxuICAgICAgICBjb25zdCBkYXRhQmxvY2tNYXNrID0gdGhpcy5tZ2YxKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoLCBzZWVkLCBkYXRhQmxvY2subGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFCbG9jay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkYXRhQmxvY2tbaV0gXj0gZGF0YUJsb2NrTWFza1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VlZE1hc2sgPSB0aGlzLm1nZjEoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gsIGRhdGFCbG9jaywgc2VlZC5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWVkW2ldIF49IHNlZWRNYXNrW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWludGVybmFsS2V5LnBlbSkge1xyXG4gICAgICAgICAgICBpbnRlcm5hbEtleS5wZW0gPSBgLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG4ke2ludGVybmFsS2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGtjczAgPSBjcnlwdG8ucHVibGljRW5jcnlwdCh7XHJcbiAgICAgICAgICAgIGtleTogaW50ZXJuYWxLZXkucGVtLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9OT19QQURESU5HLFxyXG4gICAgICAgIH0sIEJ1ZmZlci5mcm9tKG1lc3NhZ2UpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocGtjczApLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgY29uc3Qga2V5U2l6ZSA9IE1hdGguY2VpbChpbnRlcm5hbEtleS5hbGdvcml0aG0ubW9kdWx1c0xlbmd0aCA+PiAzKTtcclxuICAgICAgICBjb25zdCBoYXNoU2l6ZSA9IFNoYUNyeXB0by5zaXplKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoKSA+PiAzO1xyXG4gICAgICAgIGNvbnN0IGRhdGFMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgaWYgKGRhdGFMZW5ndGggIT09IGtleVNpemUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFkIGRhdGFcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaW50ZXJuYWxLZXkucGVtKSB7XHJcbiAgICAgICAgICAgIGludGVybmFsS2V5LnBlbSA9IGAtLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cXG4ke2ludGVybmFsS2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBwa2NzMCA9IGNyeXB0by5wcml2YXRlRGVjcnlwdCh7XHJcbiAgICAgICAgICAgIGtleTogaW50ZXJuYWxLZXkucGVtLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9OT19QQURESU5HLFxyXG4gICAgICAgIH0sIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICBjb25zdCB6ID0gcGtjczBbMF07XHJcbiAgICAgICAgY29uc3Qgc2VlZCA9IHBrY3MwLnN1YmFycmF5KDEsIGhhc2hTaXplICsgMSk7XHJcbiAgICAgICAgY29uc3QgZGF0YUJsb2NrID0gcGtjczAuc3ViYXJyYXkoaGFzaFNpemUgKyAxKTtcclxuICAgICAgICBpZiAoeiAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWNyeXB0aW9uIGZhaWxlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2VlZE1hc2sgPSB0aGlzLm1nZjEoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gsIGRhdGFCbG9jaywgc2VlZC5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VlZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWVkW2ldIF49IHNlZWRNYXNrW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkYXRhQmxvY2tNYXNrID0gdGhpcy5tZ2YxKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoLCBzZWVkLCBkYXRhQmxvY2subGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFCbG9jay5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkYXRhQmxvY2tbaV0gXj0gZGF0YUJsb2NrTWFza1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGFiZWxIYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gubmFtZS5yZXBsYWNlKFwiLVwiLCBcIlwiKSlcclxuICAgICAgICAgICAgLnVwZGF0ZShjb3JlX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShhbGdvcml0aG0ubGFiZWwgfHwgbmV3IFVpbnQ4QXJyYXkoMCkpKVxyXG4gICAgICAgICAgICAuZGlnZXN0KCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYXNoU2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsYWJlbEhhc2hbaV0gIT09IGRhdGFCbG9ja1tpXSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjcnlwdGlvbiBmYWlsZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHBzRW5kID0gaGFzaFNpemU7XHJcbiAgICAgICAgZm9yICg7IHBzRW5kIDwgZGF0YUJsb2NrLmxlbmd0aDsgcHNFbmQrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwc3ogPSBkYXRhQmxvY2tbcHNFbmRdO1xyXG4gICAgICAgICAgICBpZiAocHN6ID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHN6ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWNyeXB0aW9uIGZhaWxlZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHNFbmQgPT09IGRhdGFCbG9jay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjcnlwdGlvbiBmYWlsZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBrY3MwID0gZGF0YUJsb2NrLnN1YmFycmF5KHBzRW5kICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHBrY3MwKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBSc2FDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVByaXZhdGVLZXkgfHwgaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBSU0EgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1nZjEoYWxnb3JpdGhtLCBzZWVkLCBsZW5ndGggPSAwKSB7XHJcbiAgICAgICAgY29uc3QgaGFzaFNpemUgPSBTaGFDcnlwdG8uc2l6ZShhbGdvcml0aG0pID4+IDM7XHJcbiAgICAgICAgY29uc3QgbWFzayA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgY291bnRlciA9IG5ldyBVaW50OEFycmF5KDQpO1xyXG4gICAgICAgIGNvbnN0IGNodW5rcyA9IE1hdGguY2VpbChsZW5ndGggLyBoYXNoU2l6ZSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3M7IGkrKykge1xyXG4gICAgICAgICAgICBjb3VudGVyWzBdID0gaSA+Pj4gMjQ7XHJcbiAgICAgICAgICAgIGNvdW50ZXJbMV0gPSAoaSA+Pj4gMTYpICYgMjU1O1xyXG4gICAgICAgICAgICBjb3VudGVyWzJdID0gKGkgPj4+IDgpICYgMjU1O1xyXG4gICAgICAgICAgICBjb3VudGVyWzNdID0gaSAmIDI1NTtcclxuICAgICAgICAgICAgY29uc3Qgc3VibWFzayA9IG1hc2suc3ViYXJyYXkoaSAqIGhhc2hTaXplKTtcclxuICAgICAgICAgICAgbGV0IGNodW5rID0gY3J5cHRvLmNyZWF0ZUhhc2goYWxnb3JpdGhtLm5hbWUucmVwbGFjZShcIi1cIiwgXCJcIikpXHJcbiAgICAgICAgICAgICAgICAudXBkYXRlKHNlZWQpXHJcbiAgICAgICAgICAgICAgICAudXBkYXRlKGNvdW50ZXIpXHJcbiAgICAgICAgICAgICAgICAuZGlnZXN0KCk7XHJcbiAgICAgICAgICAgIGlmIChjaHVuay5sZW5ndGggPiBzdWJtYXNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY2h1bmsgPSBjaHVuay5zdWJhcnJheSgwLCBzdWJtYXNrLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3VibWFzay5zZXQoY2h1bmspO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWFzaztcclxuICAgIH1cclxufVxuXG5jbGFzcyBSc2FFc1Byb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlByb3ZpZGVyQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJSU0FFUy1QS0NTMS12MV81XCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSB7XHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogW1wiZW5jcnlwdFwiLCBcIndyYXBLZXlcIl0sXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IFtcImRlY3J5cHRcIiwgXCJ1bndyYXBLZXlcIl0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IFJzYUNyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNoZWNrR2VuZXJhdGVLZXlQYXJhbXMoYWxnb3JpdGhtKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcInB1YmxpY0V4cG9uZW50XCIpO1xyXG4gICAgICAgIGlmICghKGFsZ29yaXRobS5wdWJsaWNFeHBvbmVudCAmJiBhbGdvcml0aG0ucHVibGljRXhwb25lbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicHVibGljRXhwb25lbnQ6IE1pc3Npbmcgb3Igbm90IGEgVWludDhBcnJheVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcHVibGljRXhwb25lbnQgPSBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NChhbGdvcml0aG0ucHVibGljRXhwb25lbnQpO1xyXG4gICAgICAgIGlmICghKHB1YmxpY0V4cG9uZW50ID09PSBcIkF3PT1cIiB8fCBwdWJsaWNFeHBvbmVudCA9PT0gXCJBUUFCXCIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwdWJsaWNFeHBvbmVudDogTXVzdCBiZSBbM10gb3IgWzEsMCwxXVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGVja1JlcXVpcmVkUHJvcGVydHkoYWxnb3JpdGhtLCBcIm1vZHVsdXNMZW5ndGhcIik7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubW9kdWx1c0xlbmd0aCkge1xyXG4gICAgICAgICAgICBjYXNlIDEwMjQ6XHJcbiAgICAgICAgICAgIGNhc2UgMjA0ODpcclxuICAgICAgICAgICAgY2FzZSA0MDk2OlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibW9kdWx1c0xlbmd0aDogTXVzdCBiZSAxMDI0LCAyMDQ4LCBvciA0MDk2XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnRvQ3J5cHRvT3B0aW9ucyhrZXkpO1xyXG4gICAgICAgIGNvbnN0IGVuYyA9IGNyeXB0b19fbmFtZXNwYWNlLnB1YmxpY0VuY3J5cHQob3B0aW9ucywgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShlbmMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnRvQ3J5cHRvT3B0aW9ucyhrZXkpO1xyXG4gICAgICAgIGNvbnN0IGRlYyA9IGNyeXB0b19fbmFtZXNwYWNlLnByaXZhdGVEZWNyeXB0KG9wdGlvbnMsIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBSc2FDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIFJzYVByaXZhdGVLZXkgfHwgaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBSU0EgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvQ3J5cHRvT3B0aW9ucyhrZXkpIHtcclxuICAgICAgICBjb25zdCB0eXBlID0ga2V5LnR5cGUudG9VcHBlckNhc2UoKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBrZXk6IGAtLS0tLUJFR0lOICR7dHlwZX0gS0VZLS0tLS1cXG4ke2dldENyeXB0b0tleShrZXkpLmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgJHt0eXBlfSBLRVktLS0tLWAsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6IGNyeXB0b19fbmFtZXNwYWNlLmNvbnN0YW50cy5SU0FfUEtDUzFfUEFERElORyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IG5hbWVkT0lEcyA9IHtcclxuICAgIFwiMS4yLjg0MC4xMDA0NS4zLjEuN1wiOiBcIlAtMjU2XCIsXHJcbiAgICBcIlAtMjU2XCI6IFwiMS4yLjg0MC4xMDA0NS4zLjEuN1wiLFxyXG4gICAgXCIxLjMuMTMyLjAuMzRcIjogXCJQLTM4NFwiLFxyXG4gICAgXCJQLTM4NFwiOiBcIjEuMy4xMzIuMC4zNFwiLFxyXG4gICAgXCIxLjMuMTMyLjAuMzVcIjogXCJQLTUyMVwiLFxyXG4gICAgXCJQLTUyMVwiOiBcIjEuMy4xMzIuMC4zNVwiLFxyXG4gICAgXCIxLjMuMTMyLjAuMTBcIjogXCJLLTI1NlwiLFxyXG4gICAgXCJLLTI1NlwiOiBcIjEuMy4xMzIuMC4xMFwiLFxyXG4gICAgXCJicmFpbnBvb2xQMTYwcjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMVwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMVwiOiBcImJyYWlucG9vbFAxNjByMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMTYwdDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMlwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMlwiOiBcImJyYWlucG9vbFAxNjB0MVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMTkycjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuM1wiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuM1wiOiBcImJyYWlucG9vbFAxOTJyMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMTkydDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuNFwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuNFwiOiBcImJyYWlucG9vbFAxOTJ0MVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMjI0cjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuNVwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuNVwiOiBcImJyYWlucG9vbFAyMjRyMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMjI0dDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuNlwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuNlwiOiBcImJyYWlucG9vbFAyMjR0MVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMjU2cjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuN1wiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuN1wiOiBcImJyYWlucG9vbFAyNTZyMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMjU2dDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuOFwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuOFwiOiBcImJyYWlucG9vbFAyNTZ0MVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMzIwcjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuOVwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuOVwiOiBcImJyYWlucG9vbFAzMjByMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMzIwdDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTBcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjEwXCI6IFwiYnJhaW5wb29sUDMyMHQxXCIsXHJcbiAgICBcImJyYWlucG9vbFAzODRyMVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS4xMVwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTFcIjogXCJicmFpbnBvb2xQMzg0cjFcIixcclxuICAgIFwiYnJhaW5wb29sUDM4NHQxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjEyXCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS4xMlwiOiBcImJyYWlucG9vbFAzODR0MVwiLFxyXG4gICAgXCJicmFpbnBvb2xQNTEycjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTNcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjEzXCI6IFwiYnJhaW5wb29sUDUxMnIxXCIsXHJcbiAgICBcImJyYWlucG9vbFA1MTJ0MVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS4xNFwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTRcIjogXCJicmFpbnBvb2xQNTEydDFcIixcclxufTtcclxuZnVuY3Rpb24gZ2V0T2lkQnlOYW1lZEN1cnZlJDEobmFtZWRDdXJ2ZSkge1xyXG4gICAgY29uc3Qgb2lkID0gbmFtZWRPSURzW25hbWVkQ3VydmVdO1xyXG4gICAgaWYgKCFvaWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgY29udmVydCBXZWJDcnlwdG8gbmFtZWQgY3VydmUgJyR7bmFtZWRDdXJ2ZX0nIHRvIE9JRGApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9pZDtcclxufVxuXG5jbGFzcyBFY1ByaXZhdGVLZXkgZXh0ZW5kcyBBc3ltbWV0cmljS2V5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJwcml2YXRlXCI7XHJcbiAgICB9XHJcbiAgICBnZXRLZXkoKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHRoaXMuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8pO1xyXG4gICAgICAgIHJldHVybiBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXlJbmZvLnByaXZhdGVLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHJpdmF0ZUtleSk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcclxuICAgICAgICBjb25zdCBqc29uID0ge1xyXG4gICAgICAgICAgICBrdHk6IFwiRUNcIixcclxuICAgICAgICAgICAgY3J2OiB0aGlzLmFsZ29yaXRobS5uYW1lZEN1cnZlLFxyXG4gICAgICAgICAgICBrZXlfb3BzOiB0aGlzLnVzYWdlcyxcclxuICAgICAgICAgICAgZXh0OiB0aGlzLmV4dHJhY3RhYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oanNvbiwganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KSk7XHJcbiAgICB9XHJcbiAgICBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgaWYgKCFqc29uLmNydikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgZ2V0IG5hbWVkIGN1cnZlIGZyb20gSldLLiBQcm9wZXJ0eSAnY3J2JyBpcyByZXF1aXJlZGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMDA0NS4yLjFcIjtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUobmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLk9iamVjdElkZW50aWZpZXIoZ2V0T2lkQnlOYW1lZEN1cnZlJDEoanNvbi5jcnYpKSk7XHJcbiAgICAgICAgY29uc3Qga2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGpzb24sIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1ByaXZhdGVLZXkgfSk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5ID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXkpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEVjUHVibGljS2V5IGV4dGVuZHMgQXN5bW1ldHJpY0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwicHVibGljXCI7XHJcbiAgICB9XHJcbiAgICBnZXRLZXkoKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHRoaXMuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1B1YmxpY0tleShrZXlJbmZvLnB1YmxpY0tleSk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcclxuICAgICAgICBjb25zdCBqc29uID0ge1xyXG4gICAgICAgICAgICBrdHk6IFwiRUNcIixcclxuICAgICAgICAgICAgY3J2OiB0aGlzLmFsZ29yaXRobS5uYW1lZEN1cnZlLFxyXG4gICAgICAgICAgICBrZXlfb3BzOiB0aGlzLnVzYWdlcyxcclxuICAgICAgICAgICAgZXh0OiB0aGlzLmV4dHJhY3RhYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oanNvbiwganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KSk7XHJcbiAgICB9XHJcbiAgICBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgaWYgKCFqc29uLmNydikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgZ2V0IG5hbWVkIGN1cnZlIGZyb20gSldLLiBQcm9wZXJ0eSAnY3J2JyBpcyByZXF1aXJlZGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBrZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oanNvbiwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHVibGljS2V5IH0pO1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMDA0NS4yLjFcIjtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuT2JqZWN0SWRlbnRpZmllcihnZXRPaWRCeU5hbWVkQ3VydmUkMShqc29uLmNydikpKTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleSA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci50b0FTTihrZXkpLnZhbHVlSGV4O1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYTFQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Qcm92aWRlckNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiU0hBLTFcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGEyNTZQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Qcm92aWRlckNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiU0hBLTI1NlwiO1xyXG4gICAgICAgIHRoaXMudXNhZ2VzID0gW107XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hhQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYTM4NFByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlByb3ZpZGVyQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJTSEEtMzg0XCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hhNTEyUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUHJvdmlkZXJDcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQS01MTJcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGEzMjU2UHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUHJvdmlkZXJDcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQTMtMjU2XCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hhMzM4NFByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlByb3ZpZGVyQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJTSEEzLTM4NFwiO1xyXG4gICAgICAgIHRoaXMudXNhZ2VzID0gW107XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hhQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYTM1MTJQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Qcm92aWRlckNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiU0hBMy01MTJcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBFY0NyeXB0byB7XHJcbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IG5ldyBFY1ByaXZhdGVLZXkoKTtcclxuICAgICAgICBwcml2YXRlS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBwcml2YXRlS2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAgcHJpdmF0ZUtleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wcml2YXRlS2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpICE9PSAtMSk7XHJcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IEVjUHVibGljS2V5KCk7XHJcbiAgICAgICAgcHVibGljS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBwdWJsaWNLZXkuZXh0cmFjdGFibGUgPSB0cnVlO1xyXG4gICAgICAgIHB1YmxpY0tleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wdWJsaWNLZXlVc2FnZXMuaW5kZXhPZih1c2FnZSkgIT09IC0xKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gY3J5cHRvLmdlbmVyYXRlS2V5UGFpclN5bmMoXCJlY1wiLCB7XHJcbiAgICAgICAgICAgIG5hbWVkQ3VydmU6IHRoaXMuZ2V0T3BlblNTTE5hbWVkQ3VydmUoYWxnb3JpdGhtLm5hbWVkQ3VydmUpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzcGtpXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJwa2NzOFwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHByaXZhdGVLZXkuZGF0YSA9IGtleXMucHJpdmF0ZUtleTtcclxuICAgICAgICBwdWJsaWNLZXkuZGF0YSA9IGtleXMucHVibGljS2V5O1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleSxcclxuICAgICAgICAgICAgcHVibGljS2V5LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBzaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gU2hhQ3J5cHRvLmdldEFsZ29yaXRobU5hbWUoYWxnb3JpdGhtLmhhc2gpO1xyXG4gICAgICAgIGNvbnN0IHNpZ25lciA9IGNyeXB0by5jcmVhdGVTaWduKGNyeXB0b0FsZyk7XHJcbiAgICAgICAgc2lnbmVyLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgaWYgKCFrZXkucGVtKSB7XHJcbiAgICAgICAgICAgIGtleS5wZW0gPSBgLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2V5OiBrZXkucGVtLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmVyLnNpZ24ob3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgZWNTaWduYXR1cmUgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShzaWduYXR1cmUsIGNvcmVfX25hbWVzcGFjZS5hc24xLkVjRHNhU2lnbmF0dXJlKTtcclxuICAgICAgICBjb25zdCBzaWduYXR1cmVSYXcgPSBjb3JlX19uYW1lc3BhY2UuRWNVdGlscy5lbmNvZGVTaWduYXR1cmUoZWNTaWduYXR1cmUsIGNvcmVfX25hbWVzcGFjZS5FY0N1cnZlcy5nZXQoa2V5LmFsZ29yaXRobS5uYW1lZEN1cnZlKS5zaXplKTtcclxuICAgICAgICByZXR1cm4gc2lnbmF0dXJlUmF3LmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyB2ZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNyeXB0b0FsZyA9IFNoYUNyeXB0by5nZXRBbGdvcml0aG1OYW1lKGFsZ29yaXRobS5oYXNoKTtcclxuICAgICAgICBjb25zdCBzaWduZXIgPSBjcnlwdG8uY3JlYXRlVmVyaWZ5KGNyeXB0b0FsZyk7XHJcbiAgICAgICAgc2lnbmVyLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgaWYgKCFrZXkucGVtKSB7XHJcbiAgICAgICAgICAgIGtleS5wZW0gPSBgLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleToga2V5LnBlbSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGVjU2lnbmF0dXJlID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLkVjRHNhU2lnbmF0dXJlKCk7XHJcbiAgICAgICAgY29uc3QgbmFtZWRDdXJ2ZSA9IGNvcmVfX25hbWVzcGFjZS5FY0N1cnZlcy5nZXQoa2V5LmFsZ29yaXRobS5uYW1lZEN1cnZlKTtcclxuICAgICAgICBjb25zdCBzaWduYXR1cmVQb2ludCA9IGNvcmVfX25hbWVzcGFjZS5FY1V0aWxzLmRlY29kZVNpZ25hdHVyZShzaWduYXR1cmUsIG5hbWVkQ3VydmUuc2l6ZSk7XHJcbiAgICAgICAgZWNTaWduYXR1cmUuciA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihzaWduYXR1cmVQb2ludC5yKTtcclxuICAgICAgICBlY1NpZ25hdHVyZS5zID0gcHZ0c3V0aWxzLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKHNpZ25hdHVyZVBvaW50LnMpO1xyXG4gICAgICAgIGNvbnN0IGVjU2lnbmF0dXJlUmF3ID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShlY1NpZ25hdHVyZSkpO1xyXG4gICAgICAgIGNvbnN0IG9rID0gc2lnbmVyLnZlcmlmeShvcHRpb25zLCBlY1NpZ25hdHVyZVJhdyk7XHJcbiAgICAgICAgcmV0dXJuIG9rO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBjcnlwdG9BbGcgPSB0aGlzLmdldE9wZW5TU0xOYW1lZEN1cnZlKGJhc2VLZXkuYWxnb3JpdGhtLm5hbWVkQ3VydmUpO1xyXG4gICAgICAgIGNvbnN0IGVjZGggPSBjcnlwdG8uY3JlYXRlRUNESChjcnlwdG9BbGcpO1xyXG4gICAgICAgIGNvbnN0IGFzblByaXZhdGVLZXkgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShiYXNlS2V5LmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICBjb25zdCBhc25FY1ByaXZhdGVLZXkgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShhc25Qcml2YXRlS2V5LnByaXZhdGVLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHJpdmF0ZUtleSk7XHJcbiAgICAgICAgZWNkaC5zZXRQcml2YXRlS2V5KEJ1ZmZlci5mcm9tKGFzbkVjUHJpdmF0ZUtleS5wcml2YXRlS2V5KSk7XHJcbiAgICAgICAgY29uc3QgYXNuUHVibGljS2V5ID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UoYWxnb3JpdGhtLnB1YmxpYy5kYXRhLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKTtcclxuICAgICAgICBjb25zdCBiaXRzID0gZWNkaC5jb21wdXRlU2VjcmV0KEJ1ZmZlci5mcm9tKGFzblB1YmxpY0tleS5wdWJsaWNLZXkpKTtcclxuICAgICAgICBpZiAobGVuZ3RoID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYml0cykuYnVmZmVyLnNsaWNlKDAsIGxlbmd0aCA+PiAzKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBleHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpO1xyXG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjpcclxuICAgICAgICAgICAgY2FzZSBcInNwa2lcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShrZXkuZGF0YSkuYnVmZmVyO1xyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXkuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHVibGljS2V5SW5mby5wdWJsaWNLZXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycsICdyYXcnLCBwa2NzOCcgb3IgJ3Nwa2knXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgandrID0ga2V5RGF0YTtcclxuICAgICAgICAgICAgICAgIGlmIChqd2suZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNQcml2YXRlS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1B1YmxpY0tleSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHVibGljS2V5KGtleURhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHVibGljS2V5KGtleUluZm8ucHVibGljS2V5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0S2V5UGFyYW1ldGVycyhrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5wYXJhbWV0ZXJzLCBhbGdvcml0aG0ubmFtZWRDdXJ2ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJwa2NzOFwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHJpdmF0ZUtleSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNQcml2YXRlS2V5KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXNzZXJ0S2V5UGFyYW1ldGVycyhrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0ucGFyYW1ldGVycywgYWxnb3JpdGhtLm5hbWVkQ3VydmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycsICdyYXcnLCAncGtjczgnIG9yICdzcGtpJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXNzZXJ0S2V5UGFyYW1ldGVycyhwYXJhbWV0ZXJzLCBuYW1lZEN1cnZlKSB7XHJcbiAgICAgICAgaWYgKCFwYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuQ3J5cHRvRXJyb3IoXCJLZXkgaW5mbyBkb2Vzbid0IGhhdmUgcmVxdWlyZWQgcGFyYW1ldGVyc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5hbWVkQ3VydmVJZGVudGlmaWVyID0gXCJcIjtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBuYW1lZEN1cnZlSWRlbnRpZmllciA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHBhcmFtZXRlcnMsIGNvcmVfX25hbWVzcGFjZS5hc24xLk9iamVjdElkZW50aWZpZXIpLnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLkNyeXB0b0Vycm9yKFwiQ2Fubm90IHJlYWQga2V5IGluZm8gcGFyYW1ldGVyc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdldE9pZEJ5TmFtZWRDdXJ2ZSQxKG5hbWVkQ3VydmUpICE9PSBuYW1lZEN1cnZlSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLkNyeXB0b0Vycm9yKFwiS2V5IGluZm8gcGFyYW1ldGVyIGRvZXNuJ3QgbWF0Y2ggdG8gbmFtZWQgY3VydmVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMDA0NS4yLjFcIjtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUobmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLk9iamVjdElkZW50aWZpZXIoZ2V0T2lkQnlOYW1lZEN1cnZlJDEoYWxnb3JpdGhtLm5hbWVkQ3VydmUpKSk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5ID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShhc25LZXkpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBFY1ByaXZhdGVLZXkoKTtcclxuICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5hbGdvcml0aG0gPSBcIjEuMi44NDAuMTAwNDUuMi4xXCI7XHJcbiAgICAgICAgY29uc3QgbmFtZWRDdXJ2ZSA9IGdldE9pZEJ5TmFtZWRDdXJ2ZSQxKGFsZ29yaXRobS5uYW1lZEN1cnZlKTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuT2JqZWN0SWRlbnRpZmllcihuYW1lZEN1cnZlKSk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXkgPSBhc25LZXkudmFsdWU7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IEVjUHVibGljS2V5KCk7XHJcbiAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gT2JqZWN0LmFzc2lnbih7fSwgYWxnb3JpdGhtKTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0T3BlblNTTE5hbWVkQ3VydmUoY3VydmUpIHtcclxuICAgICAgICBzd2l0Y2ggKGN1cnZlLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlAtMjU2XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJwcmltZTI1NnYxXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJLLTI1NlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2VjcDI1NmsxXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJQLTM4NFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2VjcDM4NHIxXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJQLTUyMVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2VjcDUyMXIxXCI7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VydmU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbkVjQ3J5cHRvLnB1YmxpY0tleVVzYWdlcyA9IFtcInZlcmlmeVwiXTtcclxuRWNDcnlwdG8ucHJpdmF0ZUtleVVzYWdlcyA9IFtcInNpZ25cIiwgXCJkZXJpdmVLZXlcIiwgXCJkZXJpdmVCaXRzXCJdO1xuXG5jbGFzcyBFY2RzYVByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkVjZHNhUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWVkQ3VydmVzID0gY29yZV9fbmFtZXNwYWNlLkVjQ3VydmVzLm5hbWVzO1xyXG4gICAgICAgIHRoaXMuaGFzaEFsZ29yaXRobXMgPSBbXHJcbiAgICAgICAgICAgIFwiU0hBLTFcIiwgXCJTSEEtMjU2XCIsIFwiU0hBLTM4NFwiLCBcIlNIQS01MTJcIixcclxuICAgICAgICAgICAgXCJzaGFrZTEyOFwiLCBcInNoYWtlMjU2XCIsXHJcbiAgICAgICAgICAgIFwiU0hBMy0yNTZcIiwgXCJTSEEzLTM4NFwiLCBcIlNIQTMtNTEyXCJcclxuICAgICAgICBdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgRWNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICAuLi5hbGdvcml0aG0sXHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcclxuICAgICAgICAgICAgcHVibGljS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wdWJsaWNLZXkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gRWNDcnlwdG8uc2lnbihhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEVjQ3J5cHRvLnZlcmlmeShhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShzaWduYXR1cmUpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBFY0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEVjQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgaWYgKCEoaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBFY1ByaXZhdGVLZXkgfHwgaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBFY1B1YmxpY0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IEVDIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRWNkaFByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkVjZGhQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZWRDdXJ2ZXMgPSBjb3JlX19uYW1lc3BhY2UuRWNDdXJ2ZXMubmFtZXM7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBFY0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEVjQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRWNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyAuLi5hbGdvcml0aG0sIG5hbWU6IHRoaXMubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJuYWxLZXkgPSBnZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgICAgICBpZiAoIShpbnRlcm5hbEtleSBpbnN0YW5jZW9mIEVjUHJpdmF0ZUtleSB8fCBpbnRlcm5hbEtleSBpbnN0YW5jZW9mIEVjUHVibGljS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgRUMgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVyaXZlQml0cyhhbGdvcml0aG0sIGJhc2VLZXksIGxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGJpdHMgPSBhd2FpdCBFY0NyeXB0by5kZXJpdmVCaXRzKHsgLi4uYWxnb3JpdGhtLCBwdWJsaWM6IGdldENyeXB0b0tleShhbGdvcml0aG0ucHVibGljKSB9LCBnZXRDcnlwdG9LZXkoYmFzZUtleSksIGxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICB9XHJcbn1cblxuY29uc3QgZWRPSURzID0ge1xyXG4gICAgW2NvcmVfX25hbWVzcGFjZS5hc24xLmlkRWQ0NDhdOiBcIkVkNDQ4XCIsXHJcbiAgICBcImVkNDQ4XCI6IGNvcmVfX25hbWVzcGFjZS5hc24xLmlkRWQ0NDgsXHJcbiAgICBbY29yZV9fbmFtZXNwYWNlLmFzbjEuaWRYNDQ4XTogXCJYNDQ4XCIsXHJcbiAgICBcIng0NDhcIjogY29yZV9fbmFtZXNwYWNlLmFzbjEuaWRYNDQ4LFxyXG4gICAgW2NvcmVfX25hbWVzcGFjZS5hc24xLmlkRWQyNTUxOV06IFwiRWQyNTUxOVwiLFxyXG4gICAgXCJlZDI1NTE5XCI6IGNvcmVfX25hbWVzcGFjZS5hc24xLmlkRWQyNTUxOSxcclxuICAgIFtjb3JlX19uYW1lc3BhY2UuYXNuMS5pZFgyNTUxOV06IFwiWDI1NTE5XCIsXHJcbiAgICBcIngyNTUxOVwiOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5pZFgyNTUxOSxcclxufTtcclxuZnVuY3Rpb24gZ2V0T2lkQnlOYW1lZEN1cnZlKG5hbWVkQ3VydmUpIHtcclxuICAgIGNvbnN0IG9pZCA9IGVkT0lEc1tuYW1lZEN1cnZlLnRvTG93ZXJDYXNlKCldO1xyXG4gICAgaWYgKCFvaWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgY29udmVydCBXZWJDcnlwdG8gbmFtZWQgY3VydmUgJyR7bmFtZWRDdXJ2ZX0nIHRvIE9JRGApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9pZDtcclxufVxuXG5jbGFzcyBFZFByaXZhdGVLZXkgZXh0ZW5kcyBBc3ltbWV0cmljS2V5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJwcml2YXRlXCI7XHJcbiAgICB9XHJcbiAgICBnZXRLZXkoKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKHRoaXMuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8pO1xyXG4gICAgICAgIHJldHVybiBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXlJbmZvLnByaXZhdGVLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLkN1cnZlUHJpdmF0ZUtleSk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcclxuICAgICAgICBjb25zdCBqc29uID0ge1xyXG4gICAgICAgICAgICBrdHk6IFwiT0tQXCIsXHJcbiAgICAgICAgICAgIGNydjogdGhpcy5hbGdvcml0aG0ubmFtZWRDdXJ2ZSxcclxuICAgICAgICAgICAga2V5X29wczogdGhpcy51c2FnZXMsXHJcbiAgICAgICAgICAgIGV4dDogdGhpcy5leHRyYWN0YWJsZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGpzb24sIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSkpO1xyXG4gICAgfVxyXG4gICAgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGlmICghanNvbi5jcnYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGdldCBuYW1lZCBjdXJ2ZSBmcm9tIEpXSy4gUHJvcGVydHkgJ2NydicgaXMgcmVxdWlyZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5hbGdvcml0aG0gPSBnZXRPaWRCeU5hbWVkQ3VydmUoanNvbi5jcnYpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihqc29uLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuQ3VydmVQcml2YXRlS2V5IH0pO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleSA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5KTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxuXG5jbGFzcyBFZFB1YmxpY0tleSBleHRlbmRzIEFzeW1tZXRyaWNLZXkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInB1YmxpY1wiO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5KCkge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZSh0aGlzLmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgIHJldHVybiBrZXlJbmZvLnB1YmxpY0tleTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xyXG4gICAgICAgIGNvbnN0IGpzb24gPSB7XHJcbiAgICAgICAgICAgIGt0eTogXCJPS1BcIixcclxuICAgICAgICAgICAgY3J2OiB0aGlzLmFsZ29yaXRobS5uYW1lZEN1cnZlLFxyXG4gICAgICAgICAgICBrZXlfb3BzOiB0aGlzLnVzYWdlcyxcclxuICAgICAgICAgICAgZXh0OiB0aGlzLmV4dHJhY3RhYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oanNvbiwge1xyXG4gICAgICAgICAgICB4OiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybChrZXkpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgaWYgKCFqc29uLmNydikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgZ2V0IG5hbWVkIGN1cnZlIGZyb20gSldLLiBQcm9wZXJ0eSAnY3J2JyBpcyByZXF1aXJlZGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWpzb24ueCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKGBDYW5ub3QgZ2V0IHByb3BlcnR5IGZyb20gSldLLiBQcm9wZXJ0eSAneCcgaXMgcmVxdWlyZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gZ2V0T2lkQnlOYW1lZEN1cnZlKGpzb24uY3J2KTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleSA9IHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwoanNvbi54KTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxuXG5jbGFzcyBFZENyeXB0byB7XHJcbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IG5ldyBFZFByaXZhdGVLZXkoKTtcclxuICAgICAgICBwcml2YXRlS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBwcml2YXRlS2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAgcHJpdmF0ZUtleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wcml2YXRlS2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpICE9PSAtMSk7XHJcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IEVkUHVibGljS2V5KCk7XHJcbiAgICAgICAgcHVibGljS2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBwdWJsaWNLZXkuZXh0cmFjdGFibGUgPSB0cnVlO1xyXG4gICAgICAgIHB1YmxpY0tleS51c2FnZXMgPSBrZXlVc2FnZXMuZmlsdGVyKCh1c2FnZSkgPT4gdGhpcy5wdWJsaWNLZXlVc2FnZXMuaW5kZXhPZih1c2FnZSkgIT09IC0xKTtcclxuICAgICAgICBjb25zdCB0eXBlID0gYWxnb3JpdGhtLm5hbWVkQ3VydmUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBjb25zdCBrZXlzID0gY3J5cHRvLmdlbmVyYXRlS2V5UGFpclN5bmModHlwZSwge1xyXG4gICAgICAgICAgICBwdWJsaWNLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzcGtpXCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXlFbmNvZGluZzoge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJwa2NzOFwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHByaXZhdGVLZXkuZGF0YSA9IGtleXMucHJpdmF0ZUtleTtcclxuICAgICAgICBwdWJsaWNLZXkuZGF0YSA9IGtleXMucHVibGljS2V5O1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleSxcclxuICAgICAgICAgICAgcHVibGljS2V5LFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBzaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKCFrZXkucGVtKSB7XHJcbiAgICAgICAgICAgIGtleS5wZW0gPSBgLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2V5OiBrZXkucGVtLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gY3J5cHRvLnNpZ24obnVsbCwgQnVmZmVyLmZyb20oZGF0YSksIG9wdGlvbnMpO1xyXG4gICAgICAgIHJldHVybiBjb3JlX19uYW1lc3BhY2UuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoc2lnbmF0dXJlKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyB2ZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIGlmICgha2V5LnBlbSkge1xyXG4gICAgICAgICAgICBrZXkucGVtID0gYC0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBrZXk6IGtleS5wZW0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBvayA9IGNyeXB0by52ZXJpZnkobnVsbCwgQnVmZmVyLmZyb20oZGF0YSksIG9wdGlvbnMsIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkpO1xyXG4gICAgICAgIHJldHVybiBvaztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZXJpdmVCaXRzKGFsZ29yaXRobSwgYmFzZUtleSwgbGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gY3J5cHRvLmNyZWF0ZVB1YmxpY0tleSh7XHJcbiAgICAgICAgICAgIGtleTogYWxnb3JpdGhtLnB1YmxpYy5kYXRhLFxyXG4gICAgICAgICAgICBmb3JtYXQ6IFwiZGVyXCIsXHJcbiAgICAgICAgICAgIHR5cGU6IFwic3BraVwiLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBjcnlwdG8uY3JlYXRlUHJpdmF0ZUtleSh7XHJcbiAgICAgICAgICAgIGtleTogYmFzZUtleS5kYXRhLFxyXG4gICAgICAgICAgICBmb3JtYXQ6IFwiZGVyXCIsXHJcbiAgICAgICAgICAgIHR5cGU6IFwicGtjczhcIixcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBiaXRzID0gY3J5cHRvLmRpZmZpZUhlbGxtYW4oe1xyXG4gICAgICAgICAgICBwdWJsaWNLZXksXHJcbiAgICAgICAgICAgIHByaXZhdGVLZXksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJpdHMpLmJ1ZmZlci5zbGljZSgwLCBsZW5ndGggPj4gMyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KTtcclxuICAgICAgICAgICAgY2FzZSBcInBrY3M4XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJzcGtpXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoa2V5LmRhdGEpLmJ1ZmZlcjtcclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNLZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5LmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1YmxpY0tleUluZm8ucHVibGljS2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snLCAncmF3JywgcGtjczgnIG9yICdzcGtpJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGp3ayA9IGtleURhdGE7XHJcbiAgICAgICAgICAgICAgICBpZiAoandrLmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oa2V5RGF0YSwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLkN1cnZlUHJpdmF0ZUtleSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghandrLngpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleURhdGE6IENhbm5vdCBnZXQgcmVxdWlyZWQgJ3gnIGZpbGVkXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkocHZ0c3V0aWxzLkNvbnZlcnQuRnJvbUJhc2U2NFVybChqd2sueCksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQdWJsaWNLZXkoa2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGtleUluZm8ucHVibGljS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJwa2NzOFwiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UobmV3IFVpbnQ4QXJyYXkoa2V5RGF0YSksIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHJpdmF0ZUtleSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuQ3VydmVQcml2YXRlS2V5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snLCAncmF3JywgJ3BrY3M4JyBvciAnc3BraSdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgRWRQcml2YXRlS2V5KCk7XHJcbiAgICAgICAga2V5LmZyb21KU09OKHtcclxuICAgICAgICAgICAgY3J2OiBhbGdvcml0aG0ubmFtZWRDdXJ2ZSxcclxuICAgICAgICAgICAgZDogcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwoYXNuS2V5LmQpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRQdWJsaWNLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgRWRQdWJsaWNLZXkoKTtcclxuICAgICAgICBrZXkuZnJvbUpTT04oe1xyXG4gICAgICAgICAgICBjcnY6IGFsZ29yaXRobS5uYW1lZEN1cnZlLFxyXG4gICAgICAgICAgICB4OiBwdnRzdXRpbHMuQ29udmVydC5Ub0Jhc2U2NFVybChhc25LZXkpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSBPYmplY3QuYXNzaWduKHt9LCBhbGdvcml0aG0pO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxufVxyXG5FZENyeXB0by5wdWJsaWNLZXlVc2FnZXMgPSBbXCJ2ZXJpZnlcIl07XHJcbkVkQ3J5cHRvLnByaXZhdGVLZXlVc2FnZXMgPSBbXCJzaWduXCIsIFwiZGVyaXZlS2V5XCIsIFwiZGVyaXZlQml0c1wiXTtcblxuY2xhc3MgRWREc2FQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5FZERzYVByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IEVkQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBuYW1lZEN1cnZlOiBhbGdvcml0aG0ubmFtZWRDdXJ2ZS5yZXBsYWNlKC9eZWQvaSwgXCJFZFwiKSxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcclxuICAgICAgICAgICAgcHVibGljS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wdWJsaWNLZXkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gRWRDcnlwdG8uc2lnbihhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEVkQ3J5cHRvLnZlcmlmeShhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShzaWduYXR1cmUpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBFZENyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEVkQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIEVjZGhFc1Byb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkVjZGhFc1Byb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IEVkQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBuYW1lZEN1cnZlOiBhbGdvcml0aG0ubmFtZWRDdXJ2ZS50b1VwcGVyQ2FzZSgpLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVyaXZlQml0cyhhbGdvcml0aG0sIGJhc2VLZXksIGxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGJpdHMgPSBhd2FpdCBFZENyeXB0by5kZXJpdmVCaXRzKHsgLi4uYWxnb3JpdGhtLCBwdWJsaWM6IGdldENyeXB0b0tleShhbGdvcml0aG0ucHVibGljKSB9LCBnZXRDcnlwdG9LZXkoYmFzZUtleSksIGxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBFZENyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEVkQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFBia2RmQ3J5cHRvS2V5IGV4dGVuZHMgQ3J5cHRvS2V5IHtcclxufVxuXG5jbGFzcyBQYmtkZjJQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5QYmtkZjJQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkRlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzYWx0ID0gY29yZV9fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKGFsZ29yaXRobS5zYWx0KTtcclxuICAgICAgICAgICAgY29uc3QgaGFzaCA9IGFsZ29yaXRobS5oYXNoLm5hbWUucmVwbGFjZShcIi1cIiwgXCJcIik7XHJcbiAgICAgICAgICAgIGNyeXB0by5wYmtkZjIoZ2V0Q3J5cHRvS2V5KGJhc2VLZXkpLmRhdGEsIEJ1ZmZlci5mcm9tKHNhbHQpLCBhbGdvcml0aG0uaXRlcmF0aW9ucywgbGVuZ3RoID4+IDMsIGhhc2gsIChlcnIsIGRlcml2ZWRCaXRzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG5ldyBVaW50OEFycmF5KGRlcml2ZWRCaXRzKS5idWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJyYXdcIikge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBuZXcgUGJrZGZDcnlwdG9LZXkoKTtcclxuICAgICAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShrZXlEYXRhKTtcclxuICAgICAgICAgICAga2V5LmFsZ29yaXRobSA9IHsgbmFtZTogdGhpcy5uYW1lIH07XHJcbiAgICAgICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ3JhdydcIik7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBQYmtkZkNyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IFBCS0RGIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgSG1hY0NyeXB0b0tleSBleHRlbmRzIENyeXB0b0tleSB7XHJcbiAgICBnZXQgYWxnKCkge1xyXG4gICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLmFsZ29yaXRobS5oYXNoLm5hbWUudG9VcHBlckNhc2UoKTtcclxuICAgICAgICByZXR1cm4gYEhTJHtoYXNoLnJlcGxhY2UoXCJTSEEtXCIsIFwiXCIpfWA7XHJcbiAgICB9XHJcbiAgICBzZXQgYWxnKHZhbHVlKSB7XHJcbiAgICB9XHJcbn1cclxudHNsaWIuX19kZWNvcmF0ZShbXHJcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJrXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybENvbnZlcnRlciB9KVxyXG5dLCBIbWFjQ3J5cHRvS2V5LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG5cbmNsYXNzIEhtYWNQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5IbWFjUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSAoYWxnb3JpdGhtLmxlbmd0aCB8fCB0aGlzLmdldERlZmF1bHRMZW5ndGgoYWxnb3JpdGhtLmhhc2gubmFtZSkpID4+IDMgPDwgMztcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgSG1hY0NyeXB0b0tleSgpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSB7XHJcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcclxuICAgICAgICAgICAgbGVuZ3RoLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIGtleS5kYXRhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCA+PiAzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjcnlwdG9BbGcgPSBTaGFDcnlwdG8uZ2V0QWxnb3JpdGhtTmFtZShrZXkuYWxnb3JpdGhtLmhhc2gpO1xyXG4gICAgICAgIGNvbnN0IGhtYWMgPSBjcnlwdG8uY3JlYXRlSG1hYyhjcnlwdG9BbGcsIGdldENyeXB0b0tleShrZXkpLmRhdGEpXHJcbiAgICAgICAgICAgIC51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpLmRpZ2VzdCgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShobWFjKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gU2hhQ3J5cHRvLmdldEFsZ29yaXRobU5hbWUoa2V5LmFsZ29yaXRobS5oYXNoKTtcclxuICAgICAgICBjb25zdCBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoY3J5cHRvQWxnLCBnZXRDcnlwdG9LZXkoa2V5KS5kYXRhKVxyXG4gICAgICAgICAgICAudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKS5kaWdlc3QoKTtcclxuICAgICAgICByZXR1cm4gaG1hYy5jb21wYXJlKEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkpID09PSAwO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBsZXQga2V5O1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAga2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBIbWFjQ3J5cHRvS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcclxuICAgICAgICAgICAgICAgIGtleSA9IG5ldyBIbWFjQ3J5cHRvS2V5KCk7XHJcbiAgICAgICAgICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGtleURhdGEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snIG9yICdyYXcnXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0ge1xyXG4gICAgICAgICAgICBoYXNoOiB7IG5hbWU6IGFsZ29yaXRobS5oYXNoLm5hbWUgfSxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IGtleS5kYXRhLmxlbmd0aCA8PCAzLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGdldENyeXB0b0tleShrZXkpKTtcclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGdldENyeXB0b0tleShrZXkpLmRhdGEpLmJ1ZmZlcjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycgb3IgJ3JhdydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgSG1hY0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IEhNQUMgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBIa2RmQ3J5cHRvS2V5IGV4dGVuZHMgQ3J5cHRvS2V5IHtcclxufVxuXG5jbGFzcyBIa2RmUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuSGtkZlByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgaWYgKGZvcm1hdC50b0xvd2VyQ2FzZSgpICE9PSBcInJhd1wiKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJPcGVyYXRpb24gbm90IHN1cHBvcnRlZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IEhrZGZDcnlwdG9LZXkoKTtcclxuICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGtleURhdGEpO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0gPSB7IG5hbWU6IHRoaXMubmFtZSB9O1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZXJpdmVCaXRzKHBhcmFtcywgYmFzZUtleSwgbGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgaGFzaCA9IHBhcmFtcy5oYXNoLm5hbWUucmVwbGFjZShcIi1cIiwgXCJcIik7XHJcbiAgICAgICAgY29uc3QgaGFzaExlbmd0aCA9IGNyeXB0by5jcmVhdGVIYXNoKGhhc2gpLmRpZ2VzdCgpLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gbGVuZ3RoIC8gODtcclxuICAgICAgICBjb25zdCBpbmZvID0gY29yZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KHBhcmFtcy5pbmZvKTtcclxuICAgICAgICBjb25zdCBQUksgPSBjcnlwdG8uY3JlYXRlSG1hYyhoYXNoLCBjb3JlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkocGFyYW1zLnNhbHQpKVxyXG4gICAgICAgICAgICAudXBkYXRlKGNvcmUuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShnZXRDcnlwdG9LZXkoYmFzZUtleSkuZGF0YSkpXHJcbiAgICAgICAgICAgIC5kaWdlc3QoKTtcclxuICAgICAgICBjb25zdCBibG9ja3MgPSBbQnVmZmVyLmFsbG9jKDApXTtcclxuICAgICAgICBjb25zdCBibG9ja0NvdW50ID0gTWF0aC5jZWlsKGJ5dGVMZW5ndGggLyBoYXNoTGVuZ3RoKSArIDE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBibG9ja0NvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgYmxvY2tzLnB1c2goY3J5cHRvLmNyZWF0ZUhtYWMoaGFzaCwgUFJLKVxyXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShCdWZmZXIuY29uY2F0KFtibG9ja3NbaSAtIDFdLCBpbmZvLCBCdWZmZXIuZnJvbShbaV0pXSkpXHJcbiAgICAgICAgICAgICAgICAuZGlnZXN0KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChibG9ja3MpLnNsaWNlKDAsIGJ5dGVMZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgSGtkZkNyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IEhLREYgQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGFrZUNyeXB0byB7XHJcbiAgICBzdGF0aWMgZGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChhbGdvcml0aG0ubmFtZS50b0xvd2VyQ2FzZSgpLCB7IG91dHB1dExlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCB9KVxyXG4gICAgICAgICAgICAudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKS5kaWdlc3QoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaGFzaCkuYnVmZmVyO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYWtlMTI4UHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuU2hha2UxMjhQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hha2VDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hha2UyNTZQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5TaGFrZTI1NlByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFrZUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTdWJ0bGVDcnlwdG8gZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuU3VidGxlQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgQWVzQ2JjUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBBZXNDdHJQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0djbVByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgQWVzQ21hY1Byb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgQWVzS3dQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0VjYlByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgRGVzQ2JjUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBEZXNFZGUzQ2JjUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBSc2FTc2FQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFJzYVBzc1Byb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgUnNhT2FlcFByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgUnNhRXNQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEVjZHNhUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBFY2RoUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGExUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGEyNTZQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYTM4NFByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hhNTEyUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBQYmtkZjJQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEhtYWNQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEhrZGZQcm92aWRlcigpKTtcclxuICAgICAgICBjb25zdCBub2RlTWFqb3JWZXJzaW9uID0gKF9hID0gL152KFxcZCspLy5leGVjKHByb2Nlc3NfX25hbWVzcGFjZS52ZXJzaW9uKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzFdO1xyXG4gICAgICAgIGlmIChub2RlTWFqb3JWZXJzaW9uICYmIHBhcnNlSW50KG5vZGVNYWpvclZlcnNpb24sIDEwKSA+PSAxMikge1xyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYWtlMTI4UHJvdmlkZXIoKSk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hha2UyNTZQcm92aWRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGFzaGVzID0gY3J5cHRvX19uYW1lc3BhY2UuZ2V0SGFzaGVzKCk7XHJcbiAgICAgICAgaWYgKGhhc2hlcy5pbmNsdWRlcyhcInNoYTMtMjU2XCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hhMzI1NlByb3ZpZGVyKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzaGVzLmluY2x1ZGVzKFwic2hhMy0zODRcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGEzMzg0UHJvdmlkZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNoZXMuaW5jbHVkZXMoXCJzaGEzLTUxMlwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYTM1MTJQcm92aWRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGVNYWpvclZlcnNpb24gJiYgcGFyc2VJbnQobm9kZU1ham9yVmVyc2lvbiwgMTApID49IDE0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgRWREc2FQcm92aWRlcigpKTtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBFY2RoRXNQcm92aWRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgQ3J5cHRvIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuc3VidGxlID0gbmV3IFN1YnRsZUNyeXB0bygpO1xyXG4gICAgfVxyXG4gICAgZ2V0UmFuZG9tVmFsdWVzKGFycmF5KSB7XHJcbiAgICAgICAgaWYgKCFBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnZ2V0UmFuZG9tVmFsdWVzJyBvbiAnQ3J5cHRvJzogcGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ0FycmF5QnVmZmVyVmlldydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGFycmF5LmJ1ZmZlciwgYXJyYXkuYnl0ZU9mZnNldCwgYXJyYXkuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKGJ1ZmZlcik7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfVxyXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnQ3J5cHRvS2V5Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmUuQ3J5cHRvS2V5OyB9XG59KTtcbmV4cG9ydHMuQ3J5cHRvID0gQ3J5cHRvO1xuIl0sIm5hbWVzIjpbImNvcmUiLCJyZXF1aXJlIiwiY3J5cHRvIiwicHJvY2VzcyIsInRzbGliIiwianNvblNjaGVtYSIsInB2dHN1dGlscyIsImFzbjFTY2hlbWEiLCJfaW50ZXJvcE5hbWVzcGFjZURlZmF1bHQiLCJlIiwibiIsIk9iamVjdCIsImNyZWF0ZSIsImtleXMiLCJmb3JFYWNoIiwiayIsImQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImVudW1lcmFibGUiLCJkZWZhdWx0IiwiZnJlZXplIiwiY29yZV9fbmFtZXNwYWNlIiwiY3J5cHRvX19uYW1lc3BhY2UiLCJwcm9jZXNzX19uYW1lc3BhY2UiLCJKc29uQmFzZTY0VXJsQ29udmVydGVyIiwiZnJvbUpTT04iLCJ2YWx1ZSIsIkJ1ZmZlciIsImZyb20iLCJDb252ZXJ0IiwiRnJvbUJhc2U2NFVybCIsInRvSlNPTiIsIlRvQmFzZTY0VXJsIiwiQ3J5cHRvS2V5IiwiY29uc3RydWN0b3IiLCJhcmd1bWVudHMiLCJkYXRhIiwiYWxsb2MiLCJhbGdvcml0aG0iLCJuYW1lIiwiZXh0cmFjdGFibGUiLCJ0eXBlIiwidXNhZ2VzIiwia3R5IiwiYWxnIiwiX19kZWNvcmF0ZSIsIkpzb25Qcm9wIiwiSnNvblByb3BUeXBlcyIsIkJvb2xlYW4iLCJvcHRpb25hbCIsInByb3RvdHlwZSIsIlN0cmluZyIsInJlcGVhdGVkIiwiU3ltbWV0cmljS2V5IiwiQXN5bW1ldHJpY0tleSIsIkFlc0NyeXB0b0tleSIsInRvVXBwZXJDYXNlIiwibGVuZ3RoIiwiQWxnb3JpdGhtRXJyb3IiLCJjb252ZXJ0ZXIiLCJrZXlTdG9yYWdlIiwiV2Vha01hcCIsImdldENyeXB0b0tleSIsImtleSIsInJlcyIsIk9wZXJhdGlvbkVycm9yIiwic2V0Q3J5cHRvS2V5Iiwic2V0IiwiQWVzQ3J5cHRvIiwiZ2VuZXJhdGVLZXkiLCJrZXlVc2FnZXMiLCJyYW5kb21CeXRlcyIsImV4cG9ydEtleSIsImZvcm1hdCIsIkVycm9yIiwidG9Mb3dlckNhc2UiLCJKc29uU2VyaWFsaXplciIsIlVpbnQ4QXJyYXkiLCJidWZmZXIiLCJpbXBvcnRLZXkiLCJrZXlEYXRhIiwiSnNvblBhcnNlciIsInRhcmdldFNjaGVtYSIsImVuY3J5cHQiLCJlbmNyeXB0QWVzQ0JDIiwiZW5jcnlwdEFlc0NUUiIsImVuY3J5cHRBZXNHQ00iLCJlbmNyeXB0QWVzS1ciLCJlbmNyeXB0QWVzRUNCIiwiZGVjcnlwdCIsImRlY3J5cHRBZXNDQkMiLCJkZWNyeXB0QWVzQ1RSIiwiZGVjcnlwdEFlc0dDTSIsImRlY3J5cHRBZXNLVyIsImRlY3J5cHRBZXNFQ0IiLCJjaXBoZXIiLCJjcmVhdGVDaXBoZXJpdiIsIml2IiwiZW5jIiwidXBkYXRlIiwiY29uY2F0IiwiZmluYWwiLCJkZWNpcGhlciIsImNyZWF0ZURlY2lwaGVyaXYiLCJkZWMiLCJjb3VudGVyIiwiYXV0aFRhZ0xlbmd0aCIsInRhZ0xlbmd0aCIsImFkZGl0aW9uYWxEYXRhIiwic2V0QUFEIiwiZ2V0QXV0aFRhZyIsInNsaWNlIiwidGFnIiwic2V0QXV0aFRhZyIsIkFFU19LV19JViIsIkFlc0NiY1Byb3ZpZGVyIiwib25HZW5lcmF0ZUtleSIsIm9uRW5jcnlwdCIsIm9uRGVjcnlwdCIsIm9uRXhwb3J0S2V5Iiwib25JbXBvcnRLZXkiLCJjaGVja0NyeXB0b0tleSIsImtleVVzYWdlIiwiVHlwZUVycm9yIiwiemVybyIsInJiIiwiYmxvY2tTaXplIiwiYml0U2hpZnRMZWZ0Iiwic2hpZnRlZCIsImxhc3QiLCJpbmRleCIsInhvciIsImEiLCJiIiwiTWF0aCIsIm1pbiIsIm91dHB1dCIsImFlcyIsIm1lc3NhZ2UiLCJyZXN1bHQiLCJnZXRNZXNzYWdlQmxvY2siLCJibG9ja0luZGV4IiwiYmxvY2siLCJzdGFydCIsImVuZCIsImNvcHkiLCJnZXRQYWRkZWRNZXNzYWdlQmxvY2siLCJmaWxsIiwiZ2VuZXJhdGVTdWJrZXlzIiwibCIsInN1YmtleTEiLCJzdWJrZXkyIiwiYWVzQ21hYyIsInN1YmtleXMiLCJibG9ja0NvdW50IiwiY2VpbCIsImxhc3RCbG9ja0NvbXBsZXRlRmxhZyIsImxhc3RCbG9jayIsImxhc3RCbG9ja0luZGV4IiwieCIsInkiLCJBZXNDbWFjUHJvdmlkZXIiLCJvblNpZ24iLCJvblZlcmlmeSIsInNpZ25hdHVyZSIsInNpZ25hdHVyZTIiLCJzaWduIiwiY29tcGFyZSIsIkFlc0N0clByb3ZpZGVyIiwiQWVzR2NtUHJvdmlkZXIiLCJBZXNLd1Byb3ZpZGVyIiwiQWVzRWNiUHJvdmlkZXIiLCJEZXNDcnlwdG9LZXkiLCJEZXNDcnlwdG8iLCJlbmNyeXB0RGVzQ0JDIiwiZW5jcnlwdERlc0VERTNDQkMiLCJkZWNyeXB0RGVzQ0JDIiwiZGVjcnlwdERlc0VERTNDQkMiLCJEZXNDYmNQcm92aWRlciIsIkRlc1Byb3ZpZGVyIiwia2V5U2l6ZUJpdHMiLCJpdlNpemUiLCJEZXNFZGUzQ2JjUHJvdmlkZXIiLCJnZXRKd2tBbGdvcml0aG0iLCJtZFNpemUiLCJleGVjIiwiaGFzaCIsIlJzYVByaXZhdGVLZXkiLCJnZXRLZXkiLCJrZXlJbmZvIiwiQXNuUGFyc2VyIiwicGFyc2UiLCJhc24xIiwiUHJpdmF0ZUtleUluZm8iLCJwcml2YXRlS2V5IiwianNvbiIsImtleV9vcHMiLCJleHQiLCJhc3NpZ24iLCJwcml2YXRlS2V5QWxnb3JpdGhtIiwicGFyYW1ldGVycyIsIkFzblNlcmlhbGl6ZXIiLCJzZXJpYWxpemUiLCJSc2FQdWJsaWNLZXkiLCJQdWJsaWNLZXlJbmZvIiwicHVibGljS2V5IiwicHVibGljS2V5QWxnb3JpdGhtIiwiUnNhQ3J5cHRvIiwiZmlsdGVyIiwidXNhZ2UiLCJwcml2YXRlS2V5VXNhZ2VzIiwiaW5kZXhPZiIsInB1YmxpY0tleVVzYWdlcyIsInB1YmxpY0V4cG9uZW50IiwiYnl0ZUxlbmd0aCIsInJlYWRJbnQzMkJFIiwiZ2VuZXJhdGVLZXlQYWlyU3luYyIsIm1vZHVsdXNMZW5ndGgiLCJwdWJsaWNLZXlFbmNvZGluZyIsInByaXZhdGVLZXlFbmNvZGluZyIsImp3ayIsImFzbktleSIsImltcG9ydFByaXZhdGVLZXkiLCJpbXBvcnRQdWJsaWNLZXkiLCJzaWduUnNhIiwidmVyaWZ5IiwidmVyaWZ5U1NBIiwiZW5jcnlwdE9BRVAiLCJkZWNyeXB0T0FFUCIsIm1vZHVsdXMiLCJnZXRDcnlwdG9BbGdvcml0aG0iLCJjcnlwdG9BbGciLCJzaWduZXIiLCJjcmVhdGVTaWduIiwicGVtIiwidG9TdHJpbmciLCJvcHRpb25zIiwicGFkZGluZyIsImNvbnN0YW50cyIsIlJTQV9QS0NTMV9QU1NfUEFERElORyIsInNhbHRMZW5ndGgiLCJjcmVhdGVWZXJpZnkiLCJvayIsIlJTQV9QS0NTMV9PQUVQX1BBRERJTkciLCJsYWJlbCIsInB1YmxpY0VuY3J5cHQiLCJwcml2YXRlRGVjcnlwdCIsIlJzYVNzYVByb3ZpZGVyIiwiaGFzaEFsZ29yaXRobXMiLCJpbnRlcm5hbEtleSIsIlJzYVBzc1Byb3ZpZGVyIiwiU2hhQ3J5cHRvIiwic2l6ZSIsImdldEFsZ29yaXRobU5hbWUiLCJkaWdlc3QiLCJoYXNoQWxnIiwiY3JlYXRlSGFzaCIsIlJzYU9hZXBQcm92aWRlciIsImRhdGFWaWV3Iiwia2V5U2l6ZSIsImhhc2hTaXplIiwiZGF0YUxlbmd0aCIsInBzTGVuZ3RoIiwic2VlZCIsInN1YmFycmF5IiwiZGF0YUJsb2NrIiwibGFiZWxIYXNoIiwicmVwbGFjZSIsIkJ1ZmZlclNvdXJjZUNvbnZlcnRlciIsInRvVWludDhBcnJheSIsInJhbmRvbUZpbGxTeW5jIiwiZGF0YUJsb2NrTWFzayIsIm1nZjEiLCJpIiwic2VlZE1hc2siLCJwa2NzMCIsIlJTQV9OT19QQURESU5HIiwieiIsInBzRW5kIiwicHN6IiwibWFzayIsImNodW5rcyIsInN1Ym1hc2siLCJjaHVuayIsIlJzYUVzUHJvdmlkZXIiLCJQcm92aWRlckNyeXB0byIsImNoZWNrR2VuZXJhdGVLZXlQYXJhbXMiLCJjaGVja1JlcXVpcmVkUHJvcGVydHkiLCJUb0Jhc2U2NCIsInRvQ3J5cHRvT3B0aW9ucyIsIlJTQV9QS0NTMV9QQURESU5HIiwibmFtZWRPSURzIiwiZ2V0T2lkQnlOYW1lZEN1cnZlJDEiLCJuYW1lZEN1cnZlIiwib2lkIiwiRWNQcml2YXRlS2V5IiwiY3J2IiwiT2JqZWN0SWRlbnRpZmllciIsIkVjUHVibGljS2V5IiwidG9BU04iLCJ2YWx1ZUhleCIsIlNoYTFQcm92aWRlciIsIm9uRGlnZXN0IiwiU2hhMjU2UHJvdmlkZXIiLCJTaGEzODRQcm92aWRlciIsIlNoYTUxMlByb3ZpZGVyIiwiU2hhMzI1NlByb3ZpZGVyIiwiU2hhMzM4NFByb3ZpZGVyIiwiU2hhMzUxMlByb3ZpZGVyIiwiRWNDcnlwdG8iLCJnZXRPcGVuU1NMTmFtZWRDdXJ2ZSIsImVjU2lnbmF0dXJlIiwiRWNEc2FTaWduYXR1cmUiLCJzaWduYXR1cmVSYXciLCJFY1V0aWxzIiwiZW5jb2RlU2lnbmF0dXJlIiwiRWNDdXJ2ZXMiLCJzaWduYXR1cmVQb2ludCIsImRlY29kZVNpZ25hdHVyZSIsInIiLCJ0b0FycmF5QnVmZmVyIiwicyIsImVjU2lnbmF0dXJlUmF3IiwiZGVyaXZlQml0cyIsImJhc2VLZXkiLCJlY2RoIiwiY3JlYXRlRUNESCIsImFzblByaXZhdGVLZXkiLCJhc25FY1ByaXZhdGVLZXkiLCJzZXRQcml2YXRlS2V5IiwiYXNuUHVibGljS2V5IiwicHVibGljIiwiYml0cyIsImNvbXB1dGVTZWNyZXQiLCJwdWJsaWNLZXlJbmZvIiwiYXNzZXJ0S2V5UGFyYW1ldGVycyIsIkNyeXB0b0Vycm9yIiwibmFtZWRDdXJ2ZUlkZW50aWZpZXIiLCJjdXJ2ZSIsIkVjZHNhUHJvdmlkZXIiLCJuYW1lZEN1cnZlcyIsIm5hbWVzIiwiRWNkaFByb3ZpZGVyIiwib25EZXJpdmVCaXRzIiwiZWRPSURzIiwiaWRFZDQ0OCIsImlkWDQ0OCIsImlkRWQyNTUxOSIsImlkWDI1NTE5IiwiZ2V0T2lkQnlOYW1lZEN1cnZlIiwiRWRQcml2YXRlS2V5IiwiQ3VydmVQcml2YXRlS2V5IiwiRWRQdWJsaWNLZXkiLCJFZENyeXB0byIsImNyZWF0ZVB1YmxpY0tleSIsImNyZWF0ZVByaXZhdGVLZXkiLCJkaWZmaWVIZWxsbWFuIiwiRWREc2FQcm92aWRlciIsIkVjZGhFc1Byb3ZpZGVyIiwiUGJrZGZDcnlwdG9LZXkiLCJQYmtkZjJQcm92aWRlciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0Iiwic2FsdCIsInBia2RmMiIsIml0ZXJhdGlvbnMiLCJlcnIiLCJkZXJpdmVkQml0cyIsIkhtYWNDcnlwdG9LZXkiLCJIbWFjUHJvdmlkZXIiLCJnZXREZWZhdWx0TGVuZ3RoIiwiaG1hYyIsImNyZWF0ZUhtYWMiLCJIa2RmQ3J5cHRvS2V5IiwiSGtkZlByb3ZpZGVyIiwicGFyYW1zIiwiaGFzaExlbmd0aCIsImluZm8iLCJQUksiLCJibG9ja3MiLCJwdXNoIiwiU2hha2VDcnlwdG8iLCJvdXRwdXRMZW5ndGgiLCJTaGFrZTEyOFByb3ZpZGVyIiwiU2hha2UyNTZQcm92aWRlciIsIlN1YnRsZUNyeXB0byIsIl9hIiwicHJvdmlkZXJzIiwibm9kZU1ham9yVmVyc2lvbiIsInZlcnNpb24iLCJwYXJzZUludCIsImhhc2hlcyIsImdldEhhc2hlcyIsImluY2x1ZGVzIiwiQ3J5cHRvIiwic3VidGxlIiwiZ2V0UmFuZG9tVmFsdWVzIiwiYXJyYXkiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImJ5dGVPZmZzZXQiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@peculiar/webcrypto/build/webcrypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@peculiar/webcrypto/build/webcrypto.js":
/*!*************************************************************!*\
  !*** ./node_modules/@peculiar/webcrypto/build/webcrypto.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n Copyright (c) Peculiar Ventures, LLC\n*/ \nvar core = __webpack_require__(/*! webcrypto-core */ \"(rsc)/./node_modules/webcrypto-core/build/webcrypto-core.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar process = __webpack_require__(/*! process */ \"process\");\nvar tslib = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nvar jsonSchema = __webpack_require__(/*! @peculiar/json-schema */ \"(rsc)/./node_modules/@peculiar/json-schema/build/index.js\");\nvar pvtsutils = __webpack_require__(/*! pvtsutils */ \"(rsc)/./node_modules/pvtsutils/build/index.js\");\nvar asn1Schema = __webpack_require__(/*! @peculiar/asn1-schema */ \"(rsc)/./node_modules/@peculiar/asn1-schema/build/cjs/index.js\");\nfunction _interopNamespaceDefault(e) {\n    var n = Object.create(null);\n    if (e) {\n        Object.keys(e).forEach(function(k) {\n            if (k !== \"default\") {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    }\n    n.default = e;\n    return Object.freeze(n);\n}\nvar core__namespace = /*#__PURE__*/ _interopNamespaceDefault(core);\nvar crypto__namespace = /*#__PURE__*/ _interopNamespaceDefault(crypto);\nvar process__namespace = /*#__PURE__*/ _interopNamespaceDefault(process);\nconst JsonBase64UrlConverter = {\n    fromJSON: (value)=>Buffer.from(pvtsutils.Convert.FromBase64Url(value)),\n    toJSON: (value)=>pvtsutils.Convert.ToBase64Url(value)\n};\nclass CryptoKey extends core__namespace.CryptoKey {\n    constructor(){\n        super(...arguments);\n        this.data = Buffer.alloc(0);\n        this.algorithm = {\n            name: \"\"\n        };\n        this.extractable = false;\n        this.type = \"secret\";\n        this.usages = [];\n        this.kty = \"oct\";\n        this.alg = \"\";\n    }\n}\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        name: \"ext\",\n        type: jsonSchema.JsonPropTypes.Boolean,\n        optional: true\n    })\n], CryptoKey.prototype, \"extractable\", void 0);\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        name: \"key_ops\",\n        type: jsonSchema.JsonPropTypes.String,\n        repeated: true,\n        optional: true\n    })\n], CryptoKey.prototype, \"usages\", void 0);\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        type: jsonSchema.JsonPropTypes.String\n    })\n], CryptoKey.prototype, \"kty\", void 0);\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        type: jsonSchema.JsonPropTypes.String,\n        optional: true\n    })\n], CryptoKey.prototype, \"alg\", void 0);\nclass SymmetricKey extends CryptoKey {\n    constructor(){\n        super(...arguments);\n        this.kty = \"oct\";\n        this.type = \"secret\";\n    }\n}\nclass AsymmetricKey extends CryptoKey {\n}\nclass AesCryptoKey extends SymmetricKey {\n    get alg() {\n        switch(this.algorithm.name.toUpperCase()){\n            case \"AES-CBC\":\n                return `A${this.algorithm.length}CBC`;\n            case \"AES-CTR\":\n                return `A${this.algorithm.length}CTR`;\n            case \"AES-GCM\":\n                return `A${this.algorithm.length}GCM`;\n            case \"AES-KW\":\n                return `A${this.algorithm.length}KW`;\n            case \"AES-CMAC\":\n                return `A${this.algorithm.length}CMAC`;\n            case \"AES-ECB\":\n                return `A${this.algorithm.length}ECB`;\n            default:\n                throw new core__namespace.AlgorithmError(\"Unsupported algorithm name\");\n        }\n    }\n    set alg(value) {}\n}\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        name: \"k\",\n        converter: JsonBase64UrlConverter\n    })\n], AesCryptoKey.prototype, \"data\", void 0);\nconst keyStorage = new WeakMap();\nfunction getCryptoKey(key) {\n    const res = keyStorage.get(key);\n    if (!res) {\n        throw new core__namespace.OperationError(\"Cannot get CryptoKey from secure storage\");\n    }\n    return res;\n}\nfunction setCryptoKey(value) {\n    const key = core__namespace.CryptoKey.create(value.algorithm, value.type, value.extractable, value.usages);\n    Object.freeze(key);\n    keyStorage.set(key, value);\n    return key;\n}\nclass AesCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const key = new AesCryptoKey();\n        key.algorithm = algorithm;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        key.data = crypto.randomBytes(algorithm.length >> 3);\n        return key;\n    }\n    static async exportKey(format, key) {\n        if (!(key instanceof AesCryptoKey)) {\n            throw new Error(\"key: Is not AesCryptoKey\");\n        }\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(key);\n            case \"raw\":\n                return new Uint8Array(key.data).buffer;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        let key;\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                key = jsonSchema.JsonParser.fromJSON(keyData, {\n                    targetSchema: AesCryptoKey\n                });\n                break;\n            case \"raw\":\n                key = new AesCryptoKey();\n                key.data = Buffer.from(keyData);\n                break;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n        key.algorithm = algorithm;\n        key.algorithm.length = key.data.length << 3;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        switch(key.algorithm.length){\n            case 128:\n            case 192:\n            case 256:\n                break;\n            default:\n                throw new core__namespace.OperationError(\"keyData: Is wrong key length\");\n        }\n        return key;\n    }\n    static async encrypt(algorithm, key, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"AES-CBC\":\n                return this.encryptAesCBC(algorithm, key, Buffer.from(data));\n            case \"AES-CTR\":\n                return this.encryptAesCTR(algorithm, key, Buffer.from(data));\n            case \"AES-GCM\":\n                return this.encryptAesGCM(algorithm, key, Buffer.from(data));\n            case \"AES-KW\":\n                return this.encryptAesKW(algorithm, key, Buffer.from(data));\n            case \"AES-ECB\":\n                return this.encryptAesECB(algorithm, key, Buffer.from(data));\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async decrypt(algorithm, key, data) {\n        if (!(key instanceof AesCryptoKey)) {\n            throw new Error(\"key: Is not AesCryptoKey\");\n        }\n        switch(algorithm.name.toUpperCase()){\n            case \"AES-CBC\":\n                return this.decryptAesCBC(algorithm, key, Buffer.from(data));\n            case \"AES-CTR\":\n                return this.decryptAesCTR(algorithm, key, Buffer.from(data));\n            case \"AES-GCM\":\n                return this.decryptAesGCM(algorithm, key, Buffer.from(data));\n            case \"AES-KW\":\n                return this.decryptAesKW(algorithm, key, Buffer.from(data));\n            case \"AES-ECB\":\n                return this.decryptAesECB(algorithm, key, Buffer.from(data));\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async encryptAesCBC(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesCBC(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesCTR(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ctr`, key.data, Buffer.from(algorithm.counter));\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesCTR(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ctr`, key.data, new Uint8Array(algorithm.counter));\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesGCM(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-gcm`, key.data, Buffer.from(algorithm.iv), {\n            authTagLength: (algorithm.tagLength || 128) >> 3\n        });\n        if (algorithm.additionalData) {\n            cipher.setAAD(Buffer.from(algorithm.additionalData));\n        }\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final(),\n            cipher.getAuthTag()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesGCM(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-gcm`, key.data, new Uint8Array(algorithm.iv));\n        const tagLength = (algorithm.tagLength || 128) >> 3;\n        const enc = data.slice(0, data.length - tagLength);\n        const tag = data.slice(data.length - tagLength);\n        if (algorithm.additionalData) {\n            decipher.setAAD(Buffer.from(algorithm.additionalData));\n        }\n        decipher.setAuthTag(tag);\n        let dec = decipher.update(enc);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesKW(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        return new Uint8Array(enc).buffer;\n    }\n    static async decryptAesKW(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesECB(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesECB(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n}\nAesCrypto.AES_KW_IV = Buffer.from(\"A6A6A6A6A6A6A6A6\", \"hex\");\nclass AesCbcProvider extends core__namespace.AesCbcProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nconst zero = Buffer.from([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0\n]);\nconst rb = Buffer.from([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    135\n]);\nconst blockSize = 16;\nfunction bitShiftLeft(buffer) {\n    const shifted = Buffer.alloc(buffer.length);\n    const last = buffer.length - 1;\n    for(let index = 0; index < last; index++){\n        shifted[index] = buffer[index] << 1;\n        if (buffer[index + 1] & 0x80) {\n            shifted[index] += 0x01;\n        }\n    }\n    shifted[last] = buffer[last] << 1;\n    return shifted;\n}\nfunction xor(a, b) {\n    const length = Math.min(a.length, b.length);\n    const output = Buffer.alloc(length);\n    for(let index = 0; index < length; index++){\n        output[index] = a[index] ^ b[index];\n    }\n    return output;\n}\nfunction aes(key, message) {\n    const cipher = crypto__namespace.createCipheriv(`aes${key.length << 3}`, key, zero);\n    const result = cipher.update(message);\n    cipher.final();\n    return result;\n}\nfunction getMessageBlock(message, blockIndex) {\n    const block = Buffer.alloc(blockSize);\n    const start = blockIndex * blockSize;\n    const end = start + blockSize;\n    message.copy(block, 0, start, end);\n    return block;\n}\nfunction getPaddedMessageBlock(message, blockIndex) {\n    const block = Buffer.alloc(blockSize);\n    const start = blockIndex * blockSize;\n    const end = message.length;\n    block.fill(0);\n    message.copy(block, 0, start, end);\n    block[end - start] = 0x80;\n    return block;\n}\nfunction generateSubkeys(key) {\n    const l = aes(key, zero);\n    let subkey1 = bitShiftLeft(l);\n    if (l[0] & 0x80) {\n        subkey1 = xor(subkey1, rb);\n    }\n    let subkey2 = bitShiftLeft(subkey1);\n    if (subkey1[0] & 0x80) {\n        subkey2 = xor(subkey2, rb);\n    }\n    return {\n        subkey1,\n        subkey2\n    };\n}\nfunction aesCmac(key, message) {\n    const subkeys = generateSubkeys(key);\n    let blockCount = Math.ceil(message.length / blockSize);\n    let lastBlockCompleteFlag;\n    let lastBlock;\n    if (blockCount === 0) {\n        blockCount = 1;\n        lastBlockCompleteFlag = false;\n    } else {\n        lastBlockCompleteFlag = message.length % blockSize === 0;\n    }\n    const lastBlockIndex = blockCount - 1;\n    if (lastBlockCompleteFlag) {\n        lastBlock = xor(getMessageBlock(message, lastBlockIndex), subkeys.subkey1);\n    } else {\n        lastBlock = xor(getPaddedMessageBlock(message, lastBlockIndex), subkeys.subkey2);\n    }\n    let x = zero;\n    let y;\n    for(let index = 0; index < lastBlockIndex; index++){\n        y = xor(x, getMessageBlock(message, index));\n        x = aes(key, y);\n    }\n    y = xor(lastBlock, x);\n    return aes(key, y);\n}\nclass AesCmacProvider extends core__namespace.AesCmacProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onSign(algorithm, key, data) {\n        const result = aesCmac(getCryptoKey(key).data, Buffer.from(data));\n        return new Uint8Array(result).buffer;\n    }\n    async onVerify(algorithm, key, signature, data) {\n        const signature2 = await this.sign(algorithm, key, data);\n        return Buffer.from(signature).compare(Buffer.from(signature2)) === 0;\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nclass AesCtrProvider extends core__namespace.AesCtrProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nclass AesGcmProvider extends core__namespace.AesGcmProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nclass AesKwProvider extends core__namespace.AesKwProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nclass AesEcbProvider extends core__namespace.AesEcbProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, {\n            name: algorithm.name\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\nclass DesCryptoKey extends SymmetricKey {\n    get alg() {\n        switch(this.algorithm.name.toUpperCase()){\n            case \"DES-CBC\":\n                return `DES-CBC`;\n            case \"DES-EDE3-CBC\":\n                return `3DES-CBC`;\n            default:\n                throw new core__namespace.AlgorithmError(\"Unsupported algorithm name\");\n        }\n    }\n    set alg(value) {}\n}\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        name: \"k\",\n        converter: JsonBase64UrlConverter\n    })\n], DesCryptoKey.prototype, \"data\", void 0);\nclass DesCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const key = new DesCryptoKey();\n        key.algorithm = algorithm;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        key.data = crypto.randomBytes(algorithm.length >> 3);\n        return key;\n    }\n    static async exportKey(format, key) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(key);\n            case \"raw\":\n                return new Uint8Array(key.data).buffer;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        let key;\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                key = jsonSchema.JsonParser.fromJSON(keyData, {\n                    targetSchema: DesCryptoKey\n                });\n                break;\n            case \"raw\":\n                key = new DesCryptoKey();\n                key.data = Buffer.from(keyData);\n                break;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n        key.algorithm = algorithm;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static async encrypt(algorithm, key, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"DES-CBC\":\n                return this.encryptDesCBC(algorithm, key, Buffer.from(data));\n            case \"DES-EDE3-CBC\":\n                return this.encryptDesEDE3CBC(algorithm, key, Buffer.from(data));\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async decrypt(algorithm, key, data) {\n        if (!(key instanceof DesCryptoKey)) {\n            throw new Error(\"key: Is not DesCryptoKey\");\n        }\n        switch(algorithm.name.toUpperCase()){\n            case \"DES-CBC\":\n                return this.decryptDesCBC(algorithm, key, Buffer.from(data));\n            case \"DES-EDE3-CBC\":\n                return this.decryptDesEDE3CBC(algorithm, key, Buffer.from(data));\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async encryptDesCBC(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptDesCBC(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptDesEDE3CBC(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`des-ede3-cbc`, key.data, Buffer.from(algorithm.iv));\n        let enc = cipher.update(data);\n        enc = Buffer.concat([\n            enc,\n            cipher.final()\n        ]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptDesEDE3CBC(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`des-ede3-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let dec = decipher.update(data);\n        dec = Buffer.concat([\n            dec,\n            decipher.final()\n        ]);\n        return new Uint8Array(dec).buffer;\n    }\n}\nclass DesCbcProvider extends core__namespace.DesProvider {\n    constructor(){\n        super(...arguments);\n        this.keySizeBits = 64;\n        this.ivSize = 8;\n        this.name = \"DES-CBC\";\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.generateKey({\n            name: this.name,\n            length: this.keySizeBits\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return DesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.importKey(format, keyData, {\n            name: this.name,\n            length: this.keySizeBits\n        }, extractable, keyUsages);\n        if (key.data.length !== this.keySizeBits >> 3) {\n            throw new core__namespace.OperationError(\"keyData: Wrong key size\");\n        }\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\n        }\n    }\n}\nclass DesEde3CbcProvider extends core__namespace.DesProvider {\n    constructor(){\n        super(...arguments);\n        this.keySizeBits = 192;\n        this.ivSize = 8;\n        this.name = \"DES-EDE3-CBC\";\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.generateKey({\n            name: this.name,\n            length: this.keySizeBits\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return DesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.importKey(format, keyData, {\n            name: this.name,\n            length: this.keySizeBits\n        }, extractable, keyUsages);\n        if (key.data.length !== this.keySizeBits >> 3) {\n            throw new core__namespace.OperationError(\"keyData: Wrong key size\");\n        }\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\n        }\n    }\n}\nfunction getJwkAlgorithm(algorithm) {\n    switch(algorithm.name.toUpperCase()){\n        case \"RSA-OAEP\":\n            {\n                const mdSize = /(\\d+)$/.exec(algorithm.hash.name)[1];\n                return `RSA-OAEP${mdSize !== \"1\" ? `-${mdSize}` : \"\"}`;\n            }\n        case \"RSASSA-PKCS1-V1_5\":\n            return `RS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\n        case \"RSA-PSS\":\n            return `PS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\n        case \"RSA-PKCS1\":\n            return `RS1`;\n        default:\n            throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n    }\n}\nclass RsaPrivateKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"private\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"RSA\",\n            alg: getJwkAlgorithm(this.algorithm),\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        const key = jsonSchema.JsonParser.fromJSON(json, {\n            targetSchema: core__namespace.asn1.RsaPrivateKey\n        });\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.privateKeyAlgorithm.parameters = null;\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n    }\n}\nclass RsaPublicKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"public\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\n        return asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"RSA\",\n            alg: getJwkAlgorithm(this.algorithm),\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        const key = jsonSchema.JsonParser.fromJSON(json, {\n            targetSchema: core__namespace.asn1.RsaPublicKey\n        });\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.publicKeyAlgorithm.parameters = null;\n        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(key);\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n    }\n}\nclass RsaCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const privateKey = new RsaPrivateKey();\n        privateKey.algorithm = algorithm;\n        privateKey.extractable = extractable;\n        privateKey.usages = keyUsages.filter((usage)=>this.privateKeyUsages.indexOf(usage) !== -1);\n        const publicKey = new RsaPublicKey();\n        publicKey.algorithm = algorithm;\n        publicKey.extractable = true;\n        publicKey.usages = keyUsages.filter((usage)=>this.publicKeyUsages.indexOf(usage) !== -1);\n        const publicExponent = Buffer.concat([\n            Buffer.alloc(4 - algorithm.publicExponent.byteLength, 0),\n            Buffer.from(algorithm.publicExponent)\n        ]).readInt32BE(0);\n        const keys = crypto.generateKeyPairSync(\"rsa\", {\n            modulusLength: algorithm.modulusLength,\n            publicExponent,\n            publicKeyEncoding: {\n                format: \"der\",\n                type: \"spki\"\n            },\n            privateKeyEncoding: {\n                format: \"der\",\n                type: \"pkcs8\"\n            }\n        });\n        privateKey.data = keys.privateKey;\n        publicKey.data = keys.publicKey;\n        const res = {\n            privateKey,\n            publicKey\n        };\n        return res;\n    }\n    static async exportKey(format, key) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(key);\n            case \"pkcs8\":\n            case \"spki\":\n                return new Uint8Array(key.data).buffer;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                {\n                    const jwk = keyData;\n                    if (jwk.d) {\n                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {\n                            targetSchema: core__namespace.asn1.RsaPrivateKey\n                        });\n                        return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                    } else {\n                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {\n                            targetSchema: core__namespace.asn1.RsaPublicKey\n                        });\n                        return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                    }\n                }\n            case \"spki\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\n                    const asnKey = asn1Schema.AsnParser.parse(keyInfo.publicKey, core__namespace.asn1.RsaPublicKey);\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            case \"pkcs8\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\n                    const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.RsaPrivateKey);\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\n        }\n    }\n    static async sign(algorithm, key, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"RSA-PSS\":\n            case \"RSASSA-PKCS1-V1_5\":\n                return this.signRsa(algorithm, key, data);\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async verify(algorithm, key, signature, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"RSA-PSS\":\n            case \"RSASSA-PKCS1-V1_5\":\n                return this.verifySSA(algorithm, key, data, signature);\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async encrypt(algorithm, key, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"RSA-OAEP\":\n                return this.encryptOAEP(algorithm, key, data);\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async decrypt(algorithm, key, data) {\n        switch(algorithm.name.toUpperCase()){\n            case \"RSA-OAEP\":\n                return this.decryptOAEP(algorithm, key, data);\n            default:\n                throw new core__namespace.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.privateKeyAlgorithm.parameters = null;\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);\n        const key = new RsaPrivateKey();\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static importPublicKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.publicKeyAlgorithm.parameters = null;\n        keyInfo.publicKey = asn1Schema.AsnSerializer.serialize(asnKey);\n        const key = new RsaPublicKey();\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static getCryptoAlgorithm(alg) {\n        switch(alg.hash.name.toUpperCase()){\n            case \"SHA-1\":\n                return \"RSA-SHA1\";\n            case \"SHA-256\":\n                return \"RSA-SHA256\";\n            case \"SHA-384\":\n                return \"RSA-SHA384\";\n            case \"SHA-512\":\n                return \"RSA-SHA512\";\n            case \"SHA3-256\":\n                return \"RSA-SHA3-256\";\n            case \"SHA3-384\":\n                return \"RSA-SHA3-384\";\n            case \"SHA3-512\":\n                return \"RSA-SHA3-512\";\n            default:\n                throw new core__namespace.OperationError(\"algorithm.hash: Is not recognized\");\n        }\n    }\n    static signRsa(algorithm, key, data) {\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\n        const signer = crypto.createSign(cryptoAlg);\n        signer.update(Buffer.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\n            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;\n            options.saltLength = algorithm.saltLength;\n        }\n        const signature = signer.sign(options);\n        return new Uint8Array(signature).buffer;\n    }\n    static verifySSA(algorithm, key, data, signature) {\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\n        const signer = crypto.createVerify(cryptoAlg);\n        signer.update(Buffer.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\n            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;\n            options.saltLength = algorithm.saltLength;\n        }\n        const ok = signer.verify(options, signature);\n        return ok;\n    }\n    static encryptOAEP(algorithm, key, data) {\n        const options = {\n            key: `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`,\n            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING\n        };\n        if (algorithm.label) ;\n        return new Uint8Array(crypto.publicEncrypt(options, data)).buffer;\n    }\n    static decryptOAEP(algorithm, key, data) {\n        const options = {\n            key: `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`,\n            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING\n        };\n        if (algorithm.label) ;\n        return new Uint8Array(crypto.privateDecrypt(options, data)).buffer;\n    }\n}\nRsaCrypto.publicKeyUsages = [\n    \"verify\",\n    \"encrypt\",\n    \"wrapKey\"\n];\nRsaCrypto.privateKeyUsages = [\n    \"sign\",\n    \"decrypt\",\n    \"unwrapKey\"\n];\nclass RsaSsaProvider extends core__namespace.RsaSsaProvider {\n    constructor(){\n        super(...arguments);\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\",\n            \"shake128\",\n            \"shake256\",\n            \"SHA3-256\",\n            \"SHA3-384\",\n            \"SHA3-512\"\n        ];\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n}\nclass RsaPssProvider extends core__namespace.RsaPssProvider {\n    constructor(){\n        super(...arguments);\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\",\n            \"shake128\",\n            \"shake256\",\n            \"SHA3-256\",\n            \"SHA3-384\",\n            \"SHA3-512\"\n        ];\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n}\nclass ShaCrypto {\n    static size(algorithm) {\n        switch(algorithm.name.toUpperCase()){\n            case \"SHA-1\":\n                return 160;\n            case \"SHA-256\":\n            case \"SHA3-256\":\n                return 256;\n            case \"SHA-384\":\n            case \"SHA3-384\":\n                return 384;\n            case \"SHA-512\":\n            case \"SHA3-512\":\n                return 512;\n            default:\n                throw new Error(\"Unrecognized name\");\n        }\n    }\n    static getAlgorithmName(algorithm) {\n        switch(algorithm.name.toUpperCase()){\n            case \"SHA-1\":\n                return \"sha1\";\n            case \"SHA-256\":\n                return \"sha256\";\n            case \"SHA-384\":\n                return \"sha384\";\n            case \"SHA-512\":\n                return \"sha512\";\n            case \"SHA3-256\":\n                return \"sha3-256\";\n            case \"SHA3-384\":\n                return \"sha3-384\";\n            case \"SHA3-512\":\n                return \"sha3-512\";\n            default:\n                throw new Error(\"Unrecognized name\");\n        }\n    }\n    static digest(algorithm, data) {\n        const hashAlg = this.getAlgorithmName(algorithm);\n        const hash = crypto.createHash(hashAlg).update(Buffer.from(data)).digest();\n        return new Uint8Array(hash).buffer;\n    }\n}\nclass RsaOaepProvider extends core__namespace.RsaOaepProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onEncrypt(algorithm, key, data) {\n        const internalKey = getCryptoKey(key);\n        const dataView = new Uint8Array(data);\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\n        const dataLength = dataView.byteLength;\n        const psLength = keySize - dataLength - 2 * hashSize - 2;\n        if (dataLength > keySize - 2 * hashSize - 2) {\n            throw new Error(\"Data too large\");\n        }\n        const message = new Uint8Array(keySize);\n        const seed = message.subarray(1, hashSize + 1);\n        const dataBlock = message.subarray(hashSize + 1);\n        dataBlock.set(dataView, hashSize + psLength + 1);\n        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\")).update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0))).digest();\n        dataBlock.set(labelHash, 0);\n        dataBlock[hashSize + psLength] = 1;\n        crypto.randomFillSync(seed);\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\n        for(let i = 0; i < dataBlock.length; i++){\n            dataBlock[i] ^= dataBlockMask[i];\n        }\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\n        for(let i = 0; i < seed.length; i++){\n            seed[i] ^= seedMask[i];\n        }\n        if (!internalKey.pem) {\n            internalKey.pem = `-----BEGIN PUBLIC KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const pkcs0 = crypto.publicEncrypt({\n            key: internalKey.pem,\n            padding: crypto.constants.RSA_NO_PADDING\n        }, Buffer.from(message));\n        return new Uint8Array(pkcs0).buffer;\n    }\n    async onDecrypt(algorithm, key, data) {\n        const internalKey = getCryptoKey(key);\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\n        const dataLength = data.byteLength;\n        if (dataLength !== keySize) {\n            throw new Error(\"Bad data\");\n        }\n        if (!internalKey.pem) {\n            internalKey.pem = `-----BEGIN PRIVATE KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        let pkcs0 = crypto.privateDecrypt({\n            key: internalKey.pem,\n            padding: crypto.constants.RSA_NO_PADDING\n        }, Buffer.from(data));\n        const z = pkcs0[0];\n        const seed = pkcs0.subarray(1, hashSize + 1);\n        const dataBlock = pkcs0.subarray(hashSize + 1);\n        if (z !== 0) {\n            throw new Error(\"Decryption failed\");\n        }\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\n        for(let i = 0; i < seed.length; i++){\n            seed[i] ^= seedMask[i];\n        }\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\n        for(let i = 0; i < dataBlock.length; i++){\n            dataBlock[i] ^= dataBlockMask[i];\n        }\n        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\")).update(core__namespace.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0))).digest();\n        for(let i = 0; i < hashSize; i++){\n            if (labelHash[i] !== dataBlock[i]) {\n                throw new Error(\"Decryption failed\");\n            }\n        }\n        let psEnd = hashSize;\n        for(; psEnd < dataBlock.length; psEnd++){\n            const psz = dataBlock[psEnd];\n            if (psz === 1) {\n                break;\n            }\n            if (psz !== 0) {\n                throw new Error(\"Decryption failed\");\n            }\n        }\n        if (psEnd === dataBlock.length) {\n            throw new Error(\"Decryption failed\");\n        }\n        pkcs0 = dataBlock.subarray(psEnd + 1);\n        return new Uint8Array(pkcs0).buffer;\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n    mgf1(algorithm, seed, length = 0) {\n        const hashSize = ShaCrypto.size(algorithm) >> 3;\n        const mask = new Uint8Array(length);\n        const counter = new Uint8Array(4);\n        const chunks = Math.ceil(length / hashSize);\n        for(let i = 0; i < chunks; i++){\n            counter[0] = i >>> 24;\n            counter[1] = i >>> 16 & 255;\n            counter[2] = i >>> 8 & 255;\n            counter[3] = i & 255;\n            const submask = mask.subarray(i * hashSize);\n            let chunk = crypto.createHash(algorithm.name.replace(\"-\", \"\")).update(seed).update(counter).digest();\n            if (chunk.length > submask.length) {\n                chunk = chunk.subarray(0, submask.length);\n            }\n            submask.set(chunk);\n        }\n        return mask;\n    }\n}\nclass RsaEsProvider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"RSAES-PKCS1-v1_5\";\n        this.usages = {\n            publicKey: [\n                \"encrypt\",\n                \"wrapKey\"\n            ],\n            privateKey: [\n                \"decrypt\",\n                \"unwrapKey\"\n            ]\n        };\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"publicExponent\");\n        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {\n            throw new TypeError(\"publicExponent: Missing or not a Uint8Array\");\n        }\n        const publicExponent = pvtsutils.Convert.ToBase64(algorithm.publicExponent);\n        if (!(publicExponent === \"Aw==\" || publicExponent === \"AQAB\")) {\n            throw new TypeError(\"publicExponent: Must be [3] or [1,0,1]\");\n        }\n        this.checkRequiredProperty(algorithm, \"modulusLength\");\n        switch(algorithm.modulusLength){\n            case 1024:\n            case 2048:\n            case 4096:\n                break;\n            default:\n                throw new TypeError(\"modulusLength: Must be 1024, 2048, or 4096\");\n        }\n    }\n    async onEncrypt(algorithm, key, data) {\n        const options = this.toCryptoOptions(key);\n        const enc = crypto__namespace.publicEncrypt(options, new Uint8Array(data));\n        return new Uint8Array(enc).buffer;\n    }\n    async onDecrypt(algorithm, key, data) {\n        const options = this.toCryptoOptions(key);\n        const dec = crypto__namespace.privateDecrypt(options, new Uint8Array(data));\n        return new Uint8Array(dec).buffer;\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n    toCryptoOptions(key) {\n        const type = key.type.toUpperCase();\n        return {\n            key: `-----BEGIN ${type} KEY-----\\n${getCryptoKey(key).data.toString(\"base64\")}\\n-----END ${type} KEY-----`,\n            padding: crypto__namespace.constants.RSA_PKCS1_PADDING\n        };\n    }\n}\nconst namedOIDs = {\n    \"1.2.840.10045.3.1.7\": \"P-256\",\n    \"P-256\": \"1.2.840.10045.3.1.7\",\n    \"1.3.132.0.34\": \"P-384\",\n    \"P-384\": \"1.3.132.0.34\",\n    \"1.3.132.0.35\": \"P-521\",\n    \"P-521\": \"1.3.132.0.35\",\n    \"1.3.132.0.10\": \"K-256\",\n    \"K-256\": \"1.3.132.0.10\",\n    \"brainpoolP160r1\": \"1.3.36.3.3.2.8.1.1.1\",\n    \"1.3.36.3.3.2.8.1.1.1\": \"brainpoolP160r1\",\n    \"brainpoolP160t1\": \"1.3.36.3.3.2.8.1.1.2\",\n    \"1.3.36.3.3.2.8.1.1.2\": \"brainpoolP160t1\",\n    \"brainpoolP192r1\": \"1.3.36.3.3.2.8.1.1.3\",\n    \"1.3.36.3.3.2.8.1.1.3\": \"brainpoolP192r1\",\n    \"brainpoolP192t1\": \"1.3.36.3.3.2.8.1.1.4\",\n    \"1.3.36.3.3.2.8.1.1.4\": \"brainpoolP192t1\",\n    \"brainpoolP224r1\": \"1.3.36.3.3.2.8.1.1.5\",\n    \"1.3.36.3.3.2.8.1.1.5\": \"brainpoolP224r1\",\n    \"brainpoolP224t1\": \"1.3.36.3.3.2.8.1.1.6\",\n    \"1.3.36.3.3.2.8.1.1.6\": \"brainpoolP224t1\",\n    \"brainpoolP256r1\": \"1.3.36.3.3.2.8.1.1.7\",\n    \"1.3.36.3.3.2.8.1.1.7\": \"brainpoolP256r1\",\n    \"brainpoolP256t1\": \"1.3.36.3.3.2.8.1.1.8\",\n    \"1.3.36.3.3.2.8.1.1.8\": \"brainpoolP256t1\",\n    \"brainpoolP320r1\": \"1.3.36.3.3.2.8.1.1.9\",\n    \"1.3.36.3.3.2.8.1.1.9\": \"brainpoolP320r1\",\n    \"brainpoolP320t1\": \"1.3.36.3.3.2.8.1.1.10\",\n    \"1.3.36.3.3.2.8.1.1.10\": \"brainpoolP320t1\",\n    \"brainpoolP384r1\": \"1.3.36.3.3.2.8.1.1.11\",\n    \"1.3.36.3.3.2.8.1.1.11\": \"brainpoolP384r1\",\n    \"brainpoolP384t1\": \"1.3.36.3.3.2.8.1.1.12\",\n    \"1.3.36.3.3.2.8.1.1.12\": \"brainpoolP384t1\",\n    \"brainpoolP512r1\": \"1.3.36.3.3.2.8.1.1.13\",\n    \"1.3.36.3.3.2.8.1.1.13\": \"brainpoolP512r1\",\n    \"brainpoolP512t1\": \"1.3.36.3.3.2.8.1.1.14\",\n    \"1.3.36.3.3.2.8.1.1.14\": \"brainpoolP512t1\"\n};\nfunction getOidByNamedCurve$1(namedCurve) {\n    const oid = namedOIDs[namedCurve];\n    if (!oid) {\n        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\n    }\n    return oid;\n}\nclass EcPrivateKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"private\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"EC\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));\n        const key = jsonSchema.JsonParser.fromJSON(json, {\n            targetSchema: core__namespace.asn1.EcPrivateKey\n        });\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\nclass EcPublicKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"public\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\n        return new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"EC\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        const key = jsonSchema.JsonParser.fromJSON(json, {\n            targetSchema: core__namespace.asn1.EcPublicKey\n        });\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));\n        keyInfo.publicKey = asn1Schema.AsnSerializer.toASN(key).valueHex;\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\nclass Sha1Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA-1\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha256Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA-256\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha384Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA-384\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha512Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA-512\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha3256Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA3-256\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha3384Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA3-384\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass Sha3512Provider extends core__namespace.ProviderCrypto {\n    constructor(){\n        super(...arguments);\n        this.name = \"SHA3-512\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\nclass EcCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const privateKey = new EcPrivateKey();\n        privateKey.algorithm = algorithm;\n        privateKey.extractable = extractable;\n        privateKey.usages = keyUsages.filter((usage)=>this.privateKeyUsages.indexOf(usage) !== -1);\n        const publicKey = new EcPublicKey();\n        publicKey.algorithm = algorithm;\n        publicKey.extractable = true;\n        publicKey.usages = keyUsages.filter((usage)=>this.publicKeyUsages.indexOf(usage) !== -1);\n        const keys = crypto.generateKeyPairSync(\"ec\", {\n            namedCurve: this.getOpenSSLNamedCurve(algorithm.namedCurve),\n            publicKeyEncoding: {\n                format: \"der\",\n                type: \"spki\"\n            },\n            privateKeyEncoding: {\n                format: \"der\",\n                type: \"pkcs8\"\n            }\n        });\n        privateKey.data = keys.privateKey;\n        publicKey.data = keys.publicKey;\n        const res = {\n            privateKey,\n            publicKey\n        };\n        return res;\n    }\n    static async sign(algorithm, key, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);\n        const signer = crypto.createSign(cryptoAlg);\n        signer.update(Buffer.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        const signature = signer.sign(options);\n        const ecSignature = asn1Schema.AsnParser.parse(signature, core__namespace.asn1.EcDsaSignature);\n        const signatureRaw = core__namespace.EcUtils.encodeSignature(ecSignature, core__namespace.EcCurves.get(key.algorithm.namedCurve).size);\n        return signatureRaw.buffer;\n    }\n    static async verify(algorithm, key, signature, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);\n        const signer = crypto.createVerify(cryptoAlg);\n        signer.update(Buffer.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        const ecSignature = new core__namespace.asn1.EcDsaSignature();\n        const namedCurve = core__namespace.EcCurves.get(key.algorithm.namedCurve);\n        const signaturePoint = core__namespace.EcUtils.decodeSignature(signature, namedCurve.size);\n        ecSignature.r = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.r);\n        ecSignature.s = pvtsutils.BufferSourceConverter.toArrayBuffer(signaturePoint.s);\n        const ecSignatureRaw = Buffer.from(asn1Schema.AsnSerializer.serialize(ecSignature));\n        const ok = signer.verify(options, ecSignatureRaw);\n        return ok;\n    }\n    static async deriveBits(algorithm, baseKey, length) {\n        const cryptoAlg = this.getOpenSSLNamedCurve(baseKey.algorithm.namedCurve);\n        const ecdh = crypto.createECDH(cryptoAlg);\n        const asnPrivateKey = asn1Schema.AsnParser.parse(baseKey.data, core__namespace.asn1.PrivateKeyInfo);\n        const asnEcPrivateKey = asn1Schema.AsnParser.parse(asnPrivateKey.privateKey, core__namespace.asn1.EcPrivateKey);\n        ecdh.setPrivateKey(Buffer.from(asnEcPrivateKey.privateKey));\n        const asnPublicKey = asn1Schema.AsnParser.parse(algorithm.public.data, core__namespace.asn1.PublicKeyInfo);\n        const bits = ecdh.computeSecret(Buffer.from(asnPublicKey.publicKey));\n        if (length === null) {\n            return bits;\n        }\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\n    }\n    static async exportKey(format, key) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(key);\n            case \"pkcs8\":\n            case \"spki\":\n                return new Uint8Array(key.data).buffer;\n            case \"raw\":\n                {\n                    const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);\n                    return publicKeyInfo.publicKey;\n                }\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                {\n                    const jwk = keyData;\n                    if (jwk.d) {\n                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {\n                            targetSchema: core__namespace.asn1.EcPrivateKey\n                        });\n                        return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                    } else {\n                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {\n                            targetSchema: core__namespace.asn1.EcPublicKey\n                        });\n                        return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                    }\n                }\n            case \"raw\":\n                {\n                    const asnKey = new core__namespace.asn1.EcPublicKey(keyData);\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            case \"spki\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\n                    const asnKey = new core__namespace.asn1.EcPublicKey(keyInfo.publicKey);\n                    this.assertKeyParameters(keyInfo.publicKeyAlgorithm.parameters, algorithm.namedCurve);\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            case \"pkcs8\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\n                    const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.EcPrivateKey);\n                    this.assertKeyParameters(keyInfo.privateKeyAlgorithm.parameters, algorithm.namedCurve);\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\n        }\n    }\n    static assertKeyParameters(parameters, namedCurve) {\n        if (!parameters) {\n            throw new core__namespace.CryptoError(\"Key info doesn't have required parameters\");\n        }\n        let namedCurveIdentifier = \"\";\n        try {\n            namedCurveIdentifier = asn1Schema.AsnParser.parse(parameters, core__namespace.asn1.ObjectIdentifier).value;\n        } catch (e) {\n            throw new core__namespace.CryptoError(\"Cannot read key info parameters\");\n        }\n        if (getOidByNamedCurve$1(namedCurve) !== namedCurveIdentifier) {\n            throw new core__namespace.CryptoError(\"Key info parameter doesn't match to named curve\");\n        }\n    }\n    static async importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        keyInfo.privateKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(getOidByNamedCurve$1(algorithm.namedCurve)));\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(asnKey);\n        const key = new EcPrivateKey();\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        const namedCurve = getOidByNamedCurve$1(algorithm.namedCurve);\n        keyInfo.publicKeyAlgorithm.parameters = asn1Schema.AsnSerializer.serialize(new core__namespace.asn1.ObjectIdentifier(namedCurve));\n        keyInfo.publicKey = asnKey.value;\n        const key = new EcPublicKey();\n        key.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static getOpenSSLNamedCurve(curve) {\n        switch(curve.toUpperCase()){\n            case \"P-256\":\n                return \"prime256v1\";\n            case \"K-256\":\n                return \"secp256k1\";\n            case \"P-384\":\n                return \"secp384r1\";\n            case \"P-521\":\n                return \"secp521r1\";\n            default:\n                return curve;\n        }\n    }\n}\nEcCrypto.publicKeyUsages = [\n    \"verify\"\n];\nEcCrypto.privateKeyUsages = [\n    \"sign\",\n    \"deriveKey\",\n    \"deriveBits\"\n];\nclass EcdsaProvider extends core__namespace.EcdsaProvider {\n    constructor(){\n        super(...arguments);\n        this.namedCurves = core__namespace.EcCurves.names;\n        this.hashAlgorithms = [\n            \"SHA-1\",\n            \"SHA-256\",\n            \"SHA-384\",\n            \"SHA-512\",\n            \"shake128\",\n            \"shake256\",\n            \"SHA3-256\",\n            \"SHA3-384\",\n            \"SHA3-512\"\n        ];\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EcCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return EcCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return EcCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return EcCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EcCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\n            throw new TypeError(\"key: Is not EC CryptoKey\");\n        }\n    }\n}\nclass EcdhProvider extends core__namespace.EcdhProvider {\n    constructor(){\n        super(...arguments);\n        this.namedCurves = core__namespace.EcCurves.names;\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EcCrypto.generateKey({\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onExportKey(format, key) {\n        return EcCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EcCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\n            throw new TypeError(\"key: Is not EC CryptoKey\");\n        }\n    }\n    async onDeriveBits(algorithm, baseKey, length) {\n        const bits = await EcCrypto.deriveBits({\n            ...algorithm,\n            public: getCryptoKey(algorithm.public)\n        }, getCryptoKey(baseKey), length);\n        return bits;\n    }\n}\nconst edOIDs = {\n    [core__namespace.asn1.idEd448]: \"Ed448\",\n    \"ed448\": core__namespace.asn1.idEd448,\n    [core__namespace.asn1.idX448]: \"X448\",\n    \"x448\": core__namespace.asn1.idX448,\n    [core__namespace.asn1.idEd25519]: \"Ed25519\",\n    \"ed25519\": core__namespace.asn1.idEd25519,\n    [core__namespace.asn1.idX25519]: \"X25519\",\n    \"x25519\": core__namespace.asn1.idX25519\n};\nfunction getOidByNamedCurve(namedCurve) {\n    const oid = edOIDs[namedCurve.toLowerCase()];\n    if (!oid) {\n        throw new core__namespace.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\n    }\n    return oid;\n}\nclass EdPrivateKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"private\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PrivateKeyInfo);\n        return asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"OKP\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, jsonSchema.JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        const keyInfo = new core__namespace.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);\n        const key = jsonSchema.JsonParser.fromJSON(json, {\n            targetSchema: core__namespace.asn1.CurvePrivateKey\n        });\n        keyInfo.privateKey = asn1Schema.AsnSerializer.serialize(key);\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\nclass EdPublicKey extends AsymmetricKey {\n    constructor(){\n        super(...arguments);\n        this.type = \"public\";\n    }\n    getKey() {\n        const keyInfo = asn1Schema.AsnParser.parse(this.data, core__namespace.asn1.PublicKeyInfo);\n        return keyInfo.publicKey;\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"OKP\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable\n        };\n        return Object.assign(json, {\n            x: pvtsutils.Convert.ToBase64Url(key)\n        });\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new core__namespace.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        if (!json.x) {\n            throw new core__namespace.OperationError(`Cannot get property from JWK. Property 'x' is required`);\n        }\n        const keyInfo = new core__namespace.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);\n        keyInfo.publicKey = pvtsutils.Convert.FromBase64Url(json.x);\n        this.data = Buffer.from(asn1Schema.AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\nclass EdCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const privateKey = new EdPrivateKey();\n        privateKey.algorithm = algorithm;\n        privateKey.extractable = extractable;\n        privateKey.usages = keyUsages.filter((usage)=>this.privateKeyUsages.indexOf(usage) !== -1);\n        const publicKey = new EdPublicKey();\n        publicKey.algorithm = algorithm;\n        publicKey.extractable = true;\n        publicKey.usages = keyUsages.filter((usage)=>this.publicKeyUsages.indexOf(usage) !== -1);\n        const type = algorithm.namedCurve.toLowerCase();\n        const keys = crypto.generateKeyPairSync(type, {\n            publicKeyEncoding: {\n                format: \"der\",\n                type: \"spki\"\n            },\n            privateKeyEncoding: {\n                format: \"der\",\n                type: \"pkcs8\"\n            }\n        });\n        privateKey.data = keys.privateKey;\n        publicKey.data = keys.publicKey;\n        const res = {\n            privateKey,\n            publicKey\n        };\n        return res;\n    }\n    static async sign(algorithm, key, data) {\n        if (!key.pem) {\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        const signature = crypto.sign(null, Buffer.from(data), options);\n        return core__namespace.BufferSourceConverter.toArrayBuffer(signature);\n    }\n    static async verify(algorithm, key, signature, data) {\n        if (!key.pem) {\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const options = {\n            key: key.pem\n        };\n        const ok = crypto.verify(null, Buffer.from(data), options, Buffer.from(signature));\n        return ok;\n    }\n    static async deriveBits(algorithm, baseKey, length) {\n        const publicKey = crypto.createPublicKey({\n            key: algorithm.public.data,\n            format: \"der\",\n            type: \"spki\"\n        });\n        const privateKey = crypto.createPrivateKey({\n            key: baseKey.data,\n            format: \"der\",\n            type: \"pkcs8\"\n        });\n        const bits = crypto.diffieHellman({\n            publicKey,\n            privateKey\n        });\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\n    }\n    static async exportKey(format, key) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(key);\n            case \"pkcs8\":\n            case \"spki\":\n                return new Uint8Array(key.data).buffer;\n            case \"raw\":\n                {\n                    const publicKeyInfo = asn1Schema.AsnParser.parse(key.data, core__namespace.asn1.PublicKeyInfo);\n                    return publicKeyInfo.publicKey;\n                }\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                {\n                    const jwk = keyData;\n                    if (jwk.d) {\n                        const asnKey = jsonSchema.JsonParser.fromJSON(keyData, {\n                            targetSchema: core__namespace.asn1.CurvePrivateKey\n                        });\n                        return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                    } else {\n                        if (!jwk.x) {\n                            throw new TypeError(\"keyData: Cannot get required 'x' filed\");\n                        }\n                        return this.importPublicKey(pvtsutils.Convert.FromBase64Url(jwk.x), algorithm, extractable, keyUsages);\n                    }\n                }\n            case \"raw\":\n                {\n                    return this.importPublicKey(keyData, algorithm, extractable, keyUsages);\n                }\n            case \"spki\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PublicKeyInfo);\n                    return this.importPublicKey(keyInfo.publicKey, algorithm, extractable, keyUsages);\n                }\n            case \"pkcs8\":\n                {\n                    const keyInfo = asn1Schema.AsnParser.parse(new Uint8Array(keyData), core__namespace.asn1.PrivateKeyInfo);\n                    const asnKey = asn1Schema.AsnParser.parse(keyInfo.privateKey, core__namespace.asn1.CurvePrivateKey);\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\n        }\n    }\n    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\n        const key = new EdPrivateKey();\n        key.fromJSON({\n            crv: algorithm.namedCurve,\n            d: pvtsutils.Convert.ToBase64Url(asnKey.d)\n        });\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\n        const key = new EdPublicKey();\n        key.fromJSON({\n            crv: algorithm.namedCurve,\n            x: pvtsutils.Convert.ToBase64Url(asnKey)\n        });\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n}\nEdCrypto.publicKeyUsages = [\n    \"verify\"\n];\nEdCrypto.privateKeyUsages = [\n    \"sign\",\n    \"deriveKey\",\n    \"deriveBits\"\n];\nclass EdDsaProvider extends core__namespace.EdDsaProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EdCrypto.generateKey({\n            name: this.name,\n            namedCurve: algorithm.namedCurve.replace(/^ed/i, \"Ed\")\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return EdCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return EdCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return EdCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EdCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n}\nclass EcdhEsProvider extends core__namespace.EcdhEsProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EdCrypto.generateKey({\n            name: this.name,\n            namedCurve: algorithm.namedCurve.toUpperCase()\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey)\n        };\n    }\n    async onDeriveBits(algorithm, baseKey, length) {\n        const bits = await EdCrypto.deriveBits({\n            ...algorithm,\n            public: getCryptoKey(algorithm.public)\n        }, getCryptoKey(baseKey), length);\n        return bits;\n    }\n    async onExportKey(format, key) {\n        return EdCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EdCrypto.importKey(format, keyData, {\n            ...algorithm,\n            name: this.name\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n}\nclass PbkdfCryptoKey extends CryptoKey {\n}\nclass Pbkdf2Provider extends core__namespace.Pbkdf2Provider {\n    async onDeriveBits(algorithm, baseKey, length) {\n        return new Promise((resolve, reject)=>{\n            const salt = core__namespace.BufferSourceConverter.toArrayBuffer(algorithm.salt);\n            const hash = algorithm.hash.name.replace(\"-\", \"\");\n            crypto.pbkdf2(getCryptoKey(baseKey).data, Buffer.from(salt), algorithm.iterations, length >> 3, hash, (err, derivedBits)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(new Uint8Array(derivedBits).buffer);\n                }\n            });\n        });\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        if (format === \"raw\") {\n            const key = new PbkdfCryptoKey();\n            key.data = Buffer.from(keyData);\n            key.algorithm = {\n                name: this.name\n            };\n            key.extractable = false;\n            key.usages = keyUsages;\n            return setCryptoKey(key);\n        }\n        throw new core__namespace.OperationError(\"format: Must be 'raw'\");\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof PbkdfCryptoKey)) {\n            throw new TypeError(\"key: Is not PBKDF CryptoKey\");\n        }\n    }\n}\nclass HmacCryptoKey extends CryptoKey {\n    get alg() {\n        const hash = this.algorithm.hash.name.toUpperCase();\n        return `HS${hash.replace(\"SHA-\", \"\")}`;\n    }\n    set alg(value) {}\n}\ntslib.__decorate([\n    jsonSchema.JsonProp({\n        name: \"k\",\n        converter: JsonBase64UrlConverter\n    })\n], HmacCryptoKey.prototype, \"data\", void 0);\nclass HmacProvider extends core__namespace.HmacProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const length = (algorithm.length || this.getDefaultLength(algorithm.hash.name)) >> 3 << 3;\n        const key = new HmacCryptoKey();\n        key.algorithm = {\n            ...algorithm,\n            length,\n            name: this.name\n        };\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        key.data = crypto.randomBytes(length >> 3);\n        return setCryptoKey(key);\n    }\n    async onSign(algorithm, key, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);\n        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data).update(Buffer.from(data)).digest();\n        return new Uint8Array(hmac).buffer;\n    }\n    async onVerify(algorithm, key, signature, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);\n        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data).update(Buffer.from(data)).digest();\n        return hmac.compare(Buffer.from(signature)) === 0;\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        let key;\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                key = jsonSchema.JsonParser.fromJSON(keyData, {\n                    targetSchema: HmacCryptoKey\n                });\n                break;\n            case \"raw\":\n                key = new HmacCryptoKey();\n                key.data = Buffer.from(keyData);\n                break;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n        key.algorithm = {\n            hash: {\n                name: algorithm.hash.name\n            },\n            name: this.name,\n            length: key.data.length << 3\n        };\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return setCryptoKey(key);\n    }\n    async onExportKey(format, key) {\n        switch(format.toLowerCase()){\n            case \"jwk\":\n                return jsonSchema.JsonSerializer.toJSON(getCryptoKey(key));\n            case \"raw\":\n                return new Uint8Array(getCryptoKey(key).data).buffer;\n            default:\n                throw new core__namespace.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof HmacCryptoKey)) {\n            throw new TypeError(\"key: Is not HMAC CryptoKey\");\n        }\n    }\n}\nclass HkdfCryptoKey extends CryptoKey {\n}\nclass HkdfProvider extends core__namespace.HkdfProvider {\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        if (format.toLowerCase() !== \"raw\") {\n            throw new core__namespace.OperationError(\"Operation not supported\");\n        }\n        const key = new HkdfCryptoKey();\n        key.data = Buffer.from(keyData);\n        key.algorithm = {\n            name: this.name\n        };\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return setCryptoKey(key);\n    }\n    async onDeriveBits(params, baseKey, length) {\n        const hash = params.hash.name.replace(\"-\", \"\");\n        const hashLength = crypto.createHash(hash).digest().length;\n        const byteLength = length / 8;\n        const info = core.BufferSourceConverter.toUint8Array(params.info);\n        const PRK = crypto.createHmac(hash, core.BufferSourceConverter.toUint8Array(params.salt)).update(core.BufferSourceConverter.toUint8Array(getCryptoKey(baseKey).data)).digest();\n        const blocks = [\n            Buffer.alloc(0)\n        ];\n        const blockCount = Math.ceil(byteLength / hashLength) + 1;\n        for(let i = 1; i < blockCount; ++i){\n            blocks.push(crypto.createHmac(hash, PRK).update(Buffer.concat([\n                blocks[i - 1],\n                info,\n                Buffer.from([\n                    i\n                ])\n            ])).digest());\n        }\n        return Buffer.concat(blocks).slice(0, byteLength);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof HkdfCryptoKey)) {\n            throw new TypeError(\"key: Is not HKDF CryptoKey\");\n        }\n    }\n}\nclass ShakeCrypto {\n    static digest(algorithm, data) {\n        const hash = crypto.createHash(algorithm.name.toLowerCase(), {\n            outputLength: algorithm.length\n        }).update(Buffer.from(data)).digest();\n        return new Uint8Array(hash).buffer;\n    }\n}\nclass Shake128Provider extends core__namespace.Shake128Provider {\n    async onDigest(algorithm, data) {\n        return ShakeCrypto.digest(algorithm, data);\n    }\n}\nclass Shake256Provider extends core__namespace.Shake256Provider {\n    async onDigest(algorithm, data) {\n        return ShakeCrypto.digest(algorithm, data);\n    }\n}\nclass SubtleCrypto extends core__namespace.SubtleCrypto {\n    constructor(){\n        var _a;\n        super();\n        this.providers.set(new AesCbcProvider());\n        this.providers.set(new AesCtrProvider());\n        this.providers.set(new AesGcmProvider());\n        this.providers.set(new AesCmacProvider());\n        this.providers.set(new AesKwProvider());\n        this.providers.set(new AesEcbProvider());\n        this.providers.set(new DesCbcProvider());\n        this.providers.set(new DesEde3CbcProvider());\n        this.providers.set(new RsaSsaProvider());\n        this.providers.set(new RsaPssProvider());\n        this.providers.set(new RsaOaepProvider());\n        this.providers.set(new RsaEsProvider());\n        this.providers.set(new EcdsaProvider());\n        this.providers.set(new EcdhProvider());\n        this.providers.set(new Sha1Provider());\n        this.providers.set(new Sha256Provider());\n        this.providers.set(new Sha384Provider());\n        this.providers.set(new Sha512Provider());\n        this.providers.set(new Pbkdf2Provider());\n        this.providers.set(new HmacProvider());\n        this.providers.set(new HkdfProvider());\n        const nodeMajorVersion = (_a = /^v(\\d+)/.exec(process__namespace.version)) === null || _a === void 0 ? void 0 : _a[1];\n        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 12) {\n            this.providers.set(new Shake128Provider());\n            this.providers.set(new Shake256Provider());\n        }\n        const hashes = crypto__namespace.getHashes();\n        if (hashes.includes(\"sha3-256\")) {\n            this.providers.set(new Sha3256Provider());\n        }\n        if (hashes.includes(\"sha3-384\")) {\n            this.providers.set(new Sha3384Provider());\n        }\n        if (hashes.includes(\"sha3-512\")) {\n            this.providers.set(new Sha3512Provider());\n        }\n        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 14) {\n            this.providers.set(new EdDsaProvider());\n            this.providers.set(new EcdhEsProvider());\n        }\n    }\n}\nclass Crypto extends core__namespace.Crypto {\n    constructor(){\n        super(...arguments);\n        this.subtle = new SubtleCrypto();\n    }\n    getRandomValues(array) {\n        if (!ArrayBuffer.isView(array)) {\n            throw new TypeError(\"Failed to execute 'getRandomValues' on 'Crypto': parameter 1 is not of type 'ArrayBufferView'\");\n        }\n        const buffer = Buffer.from(array.buffer, array.byteOffset, array.byteLength);\n        crypto.randomFillSync(buffer);\n        return array;\n    }\n}\nObject.defineProperty(exports, \"CryptoKey\", ({\n    enumerable: true,\n    get: function() {\n        return core.CryptoKey;\n    }\n}));\nexports.Crypto = Crypto;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHBlY3VsaWFyL3dlYmNyeXB0by9idWlsZC93ZWJjcnlwdG8uanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsR0FFQTtBQUVBLElBQUlBLE9BQU9DLG1CQUFPQSxDQUFDO0FBQ25CLElBQUlDLFNBQVNELG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlFLFVBQVVGLG1CQUFPQSxDQUFDO0FBQ3RCLElBQUlHLFFBQVFILG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlJLGFBQWFKLG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlLLFlBQVlMLG1CQUFPQSxDQUFDO0FBQ3hCLElBQUlNLGFBQWFOLG1CQUFPQSxDQUFDO0FBRXpCLFNBQVNPLHlCQUF5QkMsQ0FBQztJQUNqQyxJQUFJQyxJQUFJQyxPQUFPQyxNQUFNLENBQUM7SUFDdEIsSUFBSUgsR0FBRztRQUNMRSxPQUFPRSxJQUFJLENBQUNKLEdBQUdLLE9BQU8sQ0FBQyxTQUFVQyxDQUFDO1lBQ2hDLElBQUlBLE1BQU0sV0FBVztnQkFDbkIsSUFBSUMsSUFBSUwsT0FBT00sd0JBQXdCLENBQUNSLEdBQUdNO2dCQUMzQ0osT0FBT08sY0FBYyxDQUFDUixHQUFHSyxHQUFHQyxFQUFFRyxHQUFHLEdBQUdILElBQUk7b0JBQ3RDSSxZQUFZO29CQUNaRCxLQUFLO3dCQUFjLE9BQU9WLENBQUMsQ0FBQ00sRUFBRTtvQkFBRTtnQkFDbEM7WUFDRjtRQUNGO0lBQ0Y7SUFDQUwsRUFBRVcsT0FBTyxHQUFHWjtJQUNaLE9BQU9FLE9BQU9XLE1BQU0sQ0FBQ1o7QUFDdkI7QUFFQSxJQUFJYSxrQkFBa0IsV0FBVyxHQUFFZix5QkFBeUJSO0FBQzVELElBQUl3QixvQkFBb0IsV0FBVyxHQUFFaEIseUJBQXlCTjtBQUM5RCxJQUFJdUIscUJBQXFCLFdBQVcsR0FBRWpCLHlCQUF5Qkw7QUFFL0QsTUFBTXVCLHlCQUF5QjtJQUMzQkMsVUFBVSxDQUFDQyxRQUFVQyxPQUFPQyxJQUFJLENBQUN4QixVQUFVeUIsT0FBTyxDQUFDQyxhQUFhLENBQUNKO0lBQ2pFSyxRQUFRLENBQUNMLFFBQVV0QixVQUFVeUIsT0FBTyxDQUFDRyxXQUFXLENBQUNOO0FBQ3JEO0FBRUEsTUFBTU8sa0JBQWtCWixnQkFBZ0JZLFNBQVM7SUFDN0NDLGFBQWM7UUFDVixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDQyxJQUFJLEdBQUdULE9BQU9VLEtBQUssQ0FBQztRQUN6QixJQUFJLENBQUNDLFNBQVMsR0FBRztZQUFFQyxNQUFNO1FBQUc7UUFDNUIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLE1BQU0sR0FBRyxFQUFFO1FBQ2hCLElBQUksQ0FBQ0MsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDQyxHQUFHLEdBQUc7SUFDZjtBQUNKO0FBQ0ExQyxNQUFNMkMsVUFBVSxDQUFDO0lBQ2IxQyxXQUFXMkMsUUFBUSxDQUFDO1FBQUVQLE1BQU07UUFBT0UsTUFBTXRDLFdBQVc0QyxhQUFhLENBQUNDLE9BQU87UUFBRUMsVUFBVTtJQUFLO0NBQzdGLEVBQUVoQixVQUFVaUIsU0FBUyxFQUFFLGVBQWUsS0FBSztBQUM1Q2hELE1BQU0yQyxVQUFVLENBQUM7SUFDYjFDLFdBQVcyQyxRQUFRLENBQUM7UUFBRVAsTUFBTTtRQUFXRSxNQUFNdEMsV0FBVzRDLGFBQWEsQ0FBQ0ksTUFBTTtRQUFFQyxVQUFVO1FBQU1ILFVBQVU7SUFBSztDQUNoSCxFQUFFaEIsVUFBVWlCLFNBQVMsRUFBRSxVQUFVLEtBQUs7QUFDdkNoRCxNQUFNMkMsVUFBVSxDQUFDO0lBQ2IxQyxXQUFXMkMsUUFBUSxDQUFDO1FBQUVMLE1BQU10QyxXQUFXNEMsYUFBYSxDQUFDSSxNQUFNO0lBQUM7Q0FDL0QsRUFBRWxCLFVBQVVpQixTQUFTLEVBQUUsT0FBTyxLQUFLO0FBQ3BDaEQsTUFBTTJDLFVBQVUsQ0FBQztJQUNiMUMsV0FBVzJDLFFBQVEsQ0FBQztRQUFFTCxNQUFNdEMsV0FBVzRDLGFBQWEsQ0FBQ0ksTUFBTTtRQUFFRixVQUFVO0lBQUs7Q0FDL0UsRUFBRWhCLFVBQVVpQixTQUFTLEVBQUUsT0FBTyxLQUFLO0FBRXBDLE1BQU1HLHFCQUFxQnBCO0lBQ3ZCQyxhQUFjO1FBQ1YsS0FBSyxJQUFJQztRQUNULElBQUksQ0FBQ1EsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDRixJQUFJLEdBQUc7SUFDaEI7QUFDSjtBQUVBLE1BQU1hLHNCQUFzQnJCO0FBQzVCO0FBRUEsTUFBTXNCLHFCQUFxQkY7SUFDdkIsSUFBSVQsTUFBTTtRQUNOLE9BQVEsSUFBSSxDQUFDTixTQUFTLENBQUNDLElBQUksQ0FBQ2lCLFdBQVc7WUFDbkMsS0FBSztnQkFDRCxPQUFPLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQ2xCLFNBQVMsQ0FBQ21CLE1BQU0sQ0FBQyxHQUFHLENBQUM7WUFDekMsS0FBSztnQkFDRCxPQUFPLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQ25CLFNBQVMsQ0FBQ21CLE1BQU0sQ0FBQyxHQUFHLENBQUM7WUFDekMsS0FBSztnQkFDRCxPQUFPLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQ25CLFNBQVMsQ0FBQ21CLE1BQU0sQ0FBQyxHQUFHLENBQUM7WUFDekMsS0FBSztnQkFDRCxPQUFPLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQ25CLFNBQVMsQ0FBQ21CLE1BQU0sQ0FBQyxFQUFFLENBQUM7WUFDeEMsS0FBSztnQkFDRCxPQUFPLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQ25CLFNBQVMsQ0FBQ21CLE1BQU0sQ0FBQyxJQUFJLENBQUM7WUFDMUMsS0FBSztnQkFDRCxPQUFPLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQ25CLFNBQVMsQ0FBQ21CLE1BQU0sQ0FBQyxHQUFHLENBQUM7WUFDekM7Z0JBQ0ksTUFBTSxJQUFJcEMsZ0JBQWdCcUMsY0FBYyxDQUFDO1FBQ2pEO0lBQ0o7SUFDQSxJQUFJZCxJQUFJbEIsS0FBSyxFQUFFLENBQ2Y7QUFDSjtBQUNBeEIsTUFBTTJDLFVBQVUsQ0FBQztJQUNiMUMsV0FBVzJDLFFBQVEsQ0FBQztRQUFFUCxNQUFNO1FBQUtvQixXQUFXbkM7SUFBdUI7Q0FDdEUsRUFBRStCLGFBQWFMLFNBQVMsRUFBRSxRQUFRLEtBQUs7QUFFeEMsTUFBTVUsYUFBYSxJQUFJQztBQUN2QixTQUFTQyxhQUFhQyxHQUFHO0lBQ3JCLE1BQU1DLE1BQU1KLFdBQVczQyxHQUFHLENBQUM4QztJQUMzQixJQUFJLENBQUNDLEtBQUs7UUFDTixNQUFNLElBQUkzQyxnQkFBZ0I0QyxjQUFjLENBQUM7SUFDN0M7SUFDQSxPQUFPRDtBQUNYO0FBQ0EsU0FBU0UsYUFBYXhDLEtBQUs7SUFDdkIsTUFBTXFDLE1BQU0xQyxnQkFBZ0JZLFNBQVMsQ0FBQ3ZCLE1BQU0sQ0FBQ2dCLE1BQU1ZLFNBQVMsRUFBRVosTUFBTWUsSUFBSSxFQUFFZixNQUFNYyxXQUFXLEVBQUVkLE1BQU1nQixNQUFNO0lBQ3pHakMsT0FBT1csTUFBTSxDQUFDMkM7SUFDZEgsV0FBV08sR0FBRyxDQUFDSixLQUFLckM7SUFDcEIsT0FBT3FDO0FBQ1g7QUFFQSxNQUFNSztJQUNGLGFBQWFDLFlBQVkvQixTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUN4RCxNQUFNUCxNQUFNLElBQUlSO1FBQ2hCUSxJQUFJekIsU0FBUyxHQUFHQTtRQUNoQnlCLElBQUl2QixXQUFXLEdBQUdBO1FBQ2xCdUIsSUFBSXJCLE1BQU0sR0FBRzRCO1FBQ2JQLElBQUkzQixJQUFJLEdBQUdwQyxPQUFPdUUsV0FBVyxDQUFDakMsVUFBVW1CLE1BQU0sSUFBSTtRQUNsRCxPQUFPTTtJQUNYO0lBQ0EsYUFBYVMsVUFBVUMsTUFBTSxFQUFFVixHQUFHLEVBQUU7UUFDaEMsSUFBSSxDQUFFQSxDQUFBQSxlQUFlUixZQUFXLEdBQUk7WUFDaEMsTUFBTSxJQUFJbUIsTUFBTTtRQUNwQjtRQUNBLE9BQVFELE9BQU9FLFdBQVc7WUFDdEIsS0FBSztnQkFDRCxPQUFPeEUsV0FBV3lFLGNBQWMsQ0FBQzdDLE1BQU0sQ0FBQ2dDO1lBQzVDLEtBQUs7Z0JBQ0QsT0FBTyxJQUFJYyxXQUFXZCxJQUFJM0IsSUFBSSxFQUFFMEMsTUFBTTtZQUMxQztnQkFDSSxNQUFNLElBQUl6RCxnQkFBZ0I0QyxjQUFjLENBQUM7UUFDakQ7SUFDSjtJQUNBLGFBQWFjLFVBQVVOLE1BQU0sRUFBRU8sT0FBTyxFQUFFMUMsU0FBUyxFQUFFRSxXQUFXLEVBQUU4QixTQUFTLEVBQUU7UUFDdkUsSUFBSVA7UUFDSixPQUFRVSxPQUFPRSxXQUFXO1lBQ3RCLEtBQUs7Z0JBQ0RaLE1BQU01RCxXQUFXOEUsVUFBVSxDQUFDeEQsUUFBUSxDQUFDdUQsU0FBUztvQkFBRUUsY0FBYzNCO2dCQUFhO2dCQUMzRTtZQUNKLEtBQUs7Z0JBQ0RRLE1BQU0sSUFBSVI7Z0JBQ1ZRLElBQUkzQixJQUFJLEdBQUdULE9BQU9DLElBQUksQ0FBQ29EO2dCQUN2QjtZQUNKO2dCQUNJLE1BQU0sSUFBSTNELGdCQUFnQjRDLGNBQWMsQ0FBQztRQUNqRDtRQUNBRixJQUFJekIsU0FBUyxHQUFHQTtRQUNoQnlCLElBQUl6QixTQUFTLENBQUNtQixNQUFNLEdBQUdNLElBQUkzQixJQUFJLENBQUNxQixNQUFNLElBQUk7UUFDMUNNLElBQUl2QixXQUFXLEdBQUdBO1FBQ2xCdUIsSUFBSXJCLE1BQU0sR0FBRzRCO1FBQ2IsT0FBUVAsSUFBSXpCLFNBQVMsQ0FBQ21CLE1BQU07WUFDeEIsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUNEO1lBQ0o7Z0JBQ0ksTUFBTSxJQUFJcEMsZ0JBQWdCNEMsY0FBYyxDQUFDO1FBQ2pEO1FBQ0EsT0FBT0Y7SUFDWDtJQUNBLGFBQWFvQixRQUFRN0MsU0FBUyxFQUFFeUIsR0FBRyxFQUFFM0IsSUFBSSxFQUFFO1FBQ3ZDLE9BQVFFLFVBQVVDLElBQUksQ0FBQ2lCLFdBQVc7WUFDOUIsS0FBSztnQkFDRCxPQUFPLElBQUksQ0FBQzRCLGFBQWEsQ0FBQzlDLFdBQVd5QixLQUFLcEMsT0FBT0MsSUFBSSxDQUFDUTtZQUMxRCxLQUFLO2dCQUNELE9BQU8sSUFBSSxDQUFDaUQsYUFBYSxDQUFDL0MsV0FBV3lCLEtBQUtwQyxPQUFPQyxJQUFJLENBQUNRO1lBQzFELEtBQUs7Z0JBQ0QsT0FBTyxJQUFJLENBQUNrRCxhQUFhLENBQUNoRCxXQUFXeUIsS0FBS3BDLE9BQU9DLElBQUksQ0FBQ1E7WUFDMUQsS0FBSztnQkFDRCxPQUFPLElBQUksQ0FBQ21ELFlBQVksQ0FBQ2pELFdBQVd5QixLQUFLcEMsT0FBT0MsSUFBSSxDQUFDUTtZQUN6RCxLQUFLO2dCQUNELE9BQU8sSUFBSSxDQUFDb0QsYUFBYSxDQUFDbEQsV0FBV3lCLEtBQUtwQyxPQUFPQyxJQUFJLENBQUNRO1lBQzFEO2dCQUNJLE1BQU0sSUFBSWYsZ0JBQWdCNEMsY0FBYyxDQUFDO1FBQ2pEO0lBQ0o7SUFDQSxhQUFhd0IsUUFBUW5ELFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUN2QyxJQUFJLENBQUUyQixDQUFBQSxlQUFlUixZQUFXLEdBQUk7WUFDaEMsTUFBTSxJQUFJbUIsTUFBTTtRQUNwQjtRQUNBLE9BQVFwQyxVQUFVQyxJQUFJLENBQUNpQixXQUFXO1lBQzlCLEtBQUs7Z0JBQ0QsT0FBTyxJQUFJLENBQUNrQyxhQUFhLENBQUNwRCxXQUFXeUIsS0FBS3BDLE9BQU9DLElBQUksQ0FBQ1E7WUFDMUQsS0FBSztnQkFDRCxPQUFPLElBQUksQ0FBQ3VELGFBQWEsQ0FBQ3JELFdBQVd5QixLQUFLcEMsT0FBT0MsSUFBSSxDQUFDUTtZQUMxRCxLQUFLO2dCQUNELE9BQU8sSUFBSSxDQUFDd0QsYUFBYSxDQUFDdEQsV0FBV3lCLEtBQUtwQyxPQUFPQyxJQUFJLENBQUNRO1lBQzFELEtBQUs7Z0JBQ0QsT0FBTyxJQUFJLENBQUN5RCxZQUFZLENBQUN2RCxXQUFXeUIsS0FBS3BDLE9BQU9DLElBQUksQ0FBQ1E7WUFDekQsS0FBSztnQkFDRCxPQUFPLElBQUksQ0FBQzBELGFBQWEsQ0FBQ3hELFdBQVd5QixLQUFLcEMsT0FBT0MsSUFBSSxDQUFDUTtZQUMxRDtnQkFDSSxNQUFNLElBQUlmLGdCQUFnQjRDLGNBQWMsQ0FBQztRQUNqRDtJQUNKO0lBQ0EsYUFBYW1CLGNBQWM5QyxTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDN0MsTUFBTTJELFNBQVMvRixPQUFPZ0csY0FBYyxDQUFDLENBQUMsSUFBSSxFQUFFakMsSUFBSXpCLFNBQVMsQ0FBQ21CLE1BQU0sQ0FBQyxJQUFJLENBQUMsRUFBRU0sSUFBSTNCLElBQUksRUFBRSxJQUFJeUMsV0FBV3ZDLFVBQVUyRCxFQUFFO1FBQzdHLElBQUlDLE1BQU1ILE9BQU9JLE1BQU0sQ0FBQy9EO1FBQ3hCOEQsTUFBTXZFLE9BQU95RSxNQUFNLENBQUM7WUFBQ0Y7WUFBS0gsT0FBT00sS0FBSztTQUFHO1FBQ3pDLE1BQU1yQyxNQUFNLElBQUlhLFdBQVdxQixLQUFLcEIsTUFBTTtRQUN0QyxPQUFPZDtJQUNYO0lBQ0EsYUFBYTBCLGNBQWNwRCxTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDN0MsTUFBTWtFLFdBQVd0RyxPQUFPdUcsZ0JBQWdCLENBQUMsQ0FBQyxJQUFJLEVBQUV4QyxJQUFJekIsU0FBUyxDQUFDbUIsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFTSxJQUFJM0IsSUFBSSxFQUFFLElBQUl5QyxXQUFXdkMsVUFBVTJELEVBQUU7UUFDakgsSUFBSU8sTUFBTUYsU0FBU0gsTUFBTSxDQUFDL0Q7UUFDMUJvRSxNQUFNN0UsT0FBT3lFLE1BQU0sQ0FBQztZQUFDSTtZQUFLRixTQUFTRCxLQUFLO1NBQUc7UUFDM0MsT0FBTyxJQUFJeEIsV0FBVzJCLEtBQUsxQixNQUFNO0lBQ3JDO0lBQ0EsYUFBYU8sY0FBYy9DLFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUM3QyxNQUFNMkQsU0FBUy9GLE9BQU9nRyxjQUFjLENBQUMsQ0FBQyxJQUFJLEVBQUVqQyxJQUFJekIsU0FBUyxDQUFDbUIsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFTSxJQUFJM0IsSUFBSSxFQUFFVCxPQUFPQyxJQUFJLENBQUNVLFVBQVVtRSxPQUFPO1FBQy9HLElBQUlQLE1BQU1ILE9BQU9JLE1BQU0sQ0FBQy9EO1FBQ3hCOEQsTUFBTXZFLE9BQU95RSxNQUFNLENBQUM7WUFBQ0Y7WUFBS0gsT0FBT00sS0FBSztTQUFHO1FBQ3pDLE1BQU1yQyxNQUFNLElBQUlhLFdBQVdxQixLQUFLcEIsTUFBTTtRQUN0QyxPQUFPZDtJQUNYO0lBQ0EsYUFBYTJCLGNBQWNyRCxTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDN0MsTUFBTWtFLFdBQVd0RyxPQUFPdUcsZ0JBQWdCLENBQUMsQ0FBQyxJQUFJLEVBQUV4QyxJQUFJekIsU0FBUyxDQUFDbUIsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFTSxJQUFJM0IsSUFBSSxFQUFFLElBQUl5QyxXQUFXdkMsVUFBVW1FLE9BQU87UUFDdEgsSUFBSUQsTUFBTUYsU0FBU0gsTUFBTSxDQUFDL0Q7UUFDMUJvRSxNQUFNN0UsT0FBT3lFLE1BQU0sQ0FBQztZQUFDSTtZQUFLRixTQUFTRCxLQUFLO1NBQUc7UUFDM0MsT0FBTyxJQUFJeEIsV0FBVzJCLEtBQUsxQixNQUFNO0lBQ3JDO0lBQ0EsYUFBYVEsY0FBY2hELFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUM3QyxNQUFNMkQsU0FBUy9GLE9BQU9nRyxjQUFjLENBQUMsQ0FBQyxJQUFJLEVBQUVqQyxJQUFJekIsU0FBUyxDQUFDbUIsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFTSxJQUFJM0IsSUFBSSxFQUFFVCxPQUFPQyxJQUFJLENBQUNVLFVBQVUyRCxFQUFFLEdBQUc7WUFDekdTLGVBQWUsQ0FBQ3BFLFVBQVVxRSxTQUFTLElBQUksR0FBRSxLQUFNO1FBQ25EO1FBQ0EsSUFBSXJFLFVBQVVzRSxjQUFjLEVBQUU7WUFDMUJiLE9BQU9jLE1BQU0sQ0FBQ2xGLE9BQU9DLElBQUksQ0FBQ1UsVUFBVXNFLGNBQWM7UUFDdEQ7UUFDQSxJQUFJVixNQUFNSCxPQUFPSSxNQUFNLENBQUMvRDtRQUN4QjhELE1BQU12RSxPQUFPeUUsTUFBTSxDQUFDO1lBQUNGO1lBQUtILE9BQU9NLEtBQUs7WUFBSU4sT0FBT2UsVUFBVTtTQUFHO1FBQzlELE1BQU05QyxNQUFNLElBQUlhLFdBQVdxQixLQUFLcEIsTUFBTTtRQUN0QyxPQUFPZDtJQUNYO0lBQ0EsYUFBYTRCLGNBQWN0RCxTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDN0MsTUFBTWtFLFdBQVd0RyxPQUFPdUcsZ0JBQWdCLENBQUMsQ0FBQyxJQUFJLEVBQUV4QyxJQUFJekIsU0FBUyxDQUFDbUIsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFTSxJQUFJM0IsSUFBSSxFQUFFLElBQUl5QyxXQUFXdkMsVUFBVTJELEVBQUU7UUFDakgsTUFBTVUsWUFBWSxDQUFDckUsVUFBVXFFLFNBQVMsSUFBSSxHQUFFLEtBQU07UUFDbEQsTUFBTVQsTUFBTTlELEtBQUsyRSxLQUFLLENBQUMsR0FBRzNFLEtBQUtxQixNQUFNLEdBQUdrRDtRQUN4QyxNQUFNSyxNQUFNNUUsS0FBSzJFLEtBQUssQ0FBQzNFLEtBQUtxQixNQUFNLEdBQUdrRDtRQUNyQyxJQUFJckUsVUFBVXNFLGNBQWMsRUFBRTtZQUMxQk4sU0FBU08sTUFBTSxDQUFDbEYsT0FBT0MsSUFBSSxDQUFDVSxVQUFVc0UsY0FBYztRQUN4RDtRQUNBTixTQUFTVyxVQUFVLENBQUNEO1FBQ3BCLElBQUlSLE1BQU1GLFNBQVNILE1BQU0sQ0FBQ0Q7UUFDMUJNLE1BQU03RSxPQUFPeUUsTUFBTSxDQUFDO1lBQUNJO1lBQUtGLFNBQVNELEtBQUs7U0FBRztRQUMzQyxPQUFPLElBQUl4QixXQUFXMkIsS0FBSzFCLE1BQU07SUFDckM7SUFDQSxhQUFhUyxhQUFhakQsU0FBUyxFQUFFeUIsR0FBRyxFQUFFM0IsSUFBSSxFQUFFO1FBQzVDLE1BQU0yRCxTQUFTL0YsT0FBT2dHLGNBQWMsQ0FBQyxDQUFDLE1BQU0sRUFBRWpDLElBQUl6QixTQUFTLENBQUNtQixNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUVNLElBQUkzQixJQUFJLEVBQUUsSUFBSSxDQUFDOEUsU0FBUztRQUNuRyxJQUFJaEIsTUFBTUgsT0FBT0ksTUFBTSxDQUFDL0Q7UUFDeEI4RCxNQUFNdkUsT0FBT3lFLE1BQU0sQ0FBQztZQUFDRjtZQUFLSCxPQUFPTSxLQUFLO1NBQUc7UUFDekMsT0FBTyxJQUFJeEIsV0FBV3FCLEtBQUtwQixNQUFNO0lBQ3JDO0lBQ0EsYUFBYWUsYUFBYXZELFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUM1QyxNQUFNa0UsV0FBV3RHLE9BQU91RyxnQkFBZ0IsQ0FBQyxDQUFDLE1BQU0sRUFBRXhDLElBQUl6QixTQUFTLENBQUNtQixNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUVNLElBQUkzQixJQUFJLEVBQUUsSUFBSSxDQUFDOEUsU0FBUztRQUN2RyxJQUFJVixNQUFNRixTQUFTSCxNQUFNLENBQUMvRDtRQUMxQm9FLE1BQU03RSxPQUFPeUUsTUFBTSxDQUFDO1lBQUNJO1lBQUtGLFNBQVNELEtBQUs7U0FBRztRQUMzQyxPQUFPLElBQUl4QixXQUFXMkIsS0FBSzFCLE1BQU07SUFDckM7SUFDQSxhQUFhVSxjQUFjbEQsU0FBUyxFQUFFeUIsR0FBRyxFQUFFM0IsSUFBSSxFQUFFO1FBQzdDLE1BQU0yRCxTQUFTL0YsT0FBT2dHLGNBQWMsQ0FBQyxDQUFDLElBQUksRUFBRWpDLElBQUl6QixTQUFTLENBQUNtQixNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUVNLElBQUkzQixJQUFJLEVBQUUsSUFBSXlDLFdBQVc7UUFDakcsSUFBSXFCLE1BQU1ILE9BQU9JLE1BQU0sQ0FBQy9EO1FBQ3hCOEQsTUFBTXZFLE9BQU95RSxNQUFNLENBQUM7WUFBQ0Y7WUFBS0gsT0FBT00sS0FBSztTQUFHO1FBQ3pDLE1BQU1yQyxNQUFNLElBQUlhLFdBQVdxQixLQUFLcEIsTUFBTTtRQUN0QyxPQUFPZDtJQUNYO0lBQ0EsYUFBYThCLGNBQWN4RCxTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDN0MsTUFBTWtFLFdBQVd0RyxPQUFPdUcsZ0JBQWdCLENBQUMsQ0FBQyxJQUFJLEVBQUV4QyxJQUFJekIsU0FBUyxDQUFDbUIsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFTSxJQUFJM0IsSUFBSSxFQUFFLElBQUl5QyxXQUFXO1FBQ3JHLElBQUkyQixNQUFNRixTQUFTSCxNQUFNLENBQUMvRDtRQUMxQm9FLE1BQU03RSxPQUFPeUUsTUFBTSxDQUFDO1lBQUNJO1lBQUtGLFNBQVNELEtBQUs7U0FBRztRQUMzQyxPQUFPLElBQUl4QixXQUFXMkIsS0FBSzFCLE1BQU07SUFDckM7QUFDSjtBQUNBVixVQUFVOEMsU0FBUyxHQUFHdkYsT0FBT0MsSUFBSSxDQUFDLG9CQUFvQjtBQUV0RCxNQUFNdUYsdUJBQXVCOUYsZ0JBQWdCOEYsY0FBYztJQUN2RCxNQUFNQyxjQUFjOUUsU0FBUyxFQUFFRSxXQUFXLEVBQUU4QixTQUFTLEVBQUU7UUFDbkQsTUFBTVAsTUFBTSxNQUFNSyxVQUFVQyxXQUFXLENBQUM7WUFDcEM5QixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNma0IsUUFBUW5CLFVBQVVtQixNQUFNO1FBQzVCLEdBQUdqQixhQUFhOEI7UUFDaEIsT0FBT0osYUFBYUg7SUFDeEI7SUFDQSxNQUFNc0QsVUFBVS9FLFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUNsQyxPQUFPZ0MsVUFBVWUsT0FBTyxDQUFDN0MsV0FBV3dCLGFBQWFDLE1BQU0sSUFBSWMsV0FBV3pDO0lBQzFFO0lBQ0EsTUFBTWtGLFVBQVVoRixTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDbEMsT0FBT2dDLFVBQVVxQixPQUFPLENBQUNuRCxXQUFXd0IsYUFBYUMsTUFBTSxJQUFJYyxXQUFXekM7SUFDMUU7SUFDQSxNQUFNbUYsWUFBWTlDLE1BQU0sRUFBRVYsR0FBRyxFQUFFO1FBQzNCLE9BQU9LLFVBQVVJLFNBQVMsQ0FBQ0MsUUFBUVgsYUFBYUM7SUFDcEQ7SUFDQSxNQUFNeUQsWUFBWS9DLE1BQU0sRUFBRU8sT0FBTyxFQUFFMUMsU0FBUyxFQUFFRSxXQUFXLEVBQUU4QixTQUFTLEVBQUU7UUFDbEUsTUFBTVAsTUFBTSxNQUFNSyxVQUFVVyxTQUFTLENBQUNOLFFBQVFPLFNBQVM7WUFBRXpDLE1BQU1ELFVBQVVDLElBQUk7UUFBQyxHQUFHQyxhQUFhOEI7UUFDOUYsT0FBT0osYUFBYUg7SUFDeEI7SUFDQTBELGVBQWUxRCxHQUFHLEVBQUUyRCxRQUFRLEVBQUU7UUFDMUIsS0FBSyxDQUFDRCxlQUFlMUQsS0FBSzJEO1FBQzFCLElBQUksQ0FBRTVELENBQUFBLGFBQWFDLGdCQUFnQlIsWUFBVyxHQUFJO1lBQzlDLE1BQU0sSUFBSW9FLFVBQVU7UUFDeEI7SUFDSjtBQUNKO0FBRUEsTUFBTUMsT0FBT2pHLE9BQU9DLElBQUksQ0FBQztJQUFDO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0NBQUU7QUFDekUsTUFBTWlHLEtBQUtsRyxPQUFPQyxJQUFJLENBQUM7SUFBQztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztDQUFJO0FBQ3pFLE1BQU1rRyxZQUFZO0FBQ2xCLFNBQVNDLGFBQWFqRCxNQUFNO0lBQ3hCLE1BQU1rRCxVQUFVckcsT0FBT1UsS0FBSyxDQUFDeUMsT0FBT3JCLE1BQU07SUFDMUMsTUFBTXdFLE9BQU9uRCxPQUFPckIsTUFBTSxHQUFHO0lBQzdCLElBQUssSUFBSXlFLFFBQVEsR0FBR0EsUUFBUUQsTUFBTUMsUUFBUztRQUN2Q0YsT0FBTyxDQUFDRSxNQUFNLEdBQUdwRCxNQUFNLENBQUNvRCxNQUFNLElBQUk7UUFDbEMsSUFBSXBELE1BQU0sQ0FBQ29ELFFBQVEsRUFBRSxHQUFHLE1BQU07WUFDMUJGLE9BQU8sQ0FBQ0UsTUFBTSxJQUFJO1FBQ3RCO0lBQ0o7SUFDQUYsT0FBTyxDQUFDQyxLQUFLLEdBQUduRCxNQUFNLENBQUNtRCxLQUFLLElBQUk7SUFDaEMsT0FBT0Q7QUFDWDtBQUNBLFNBQVNHLElBQUlDLENBQUMsRUFBRUMsQ0FBQztJQUNiLE1BQU01RSxTQUFTNkUsS0FBS0MsR0FBRyxDQUFDSCxFQUFFM0UsTUFBTSxFQUFFNEUsRUFBRTVFLE1BQU07SUFDMUMsTUFBTStFLFNBQVM3RyxPQUFPVSxLQUFLLENBQUNvQjtJQUM1QixJQUFLLElBQUl5RSxRQUFRLEdBQUdBLFFBQVF6RSxRQUFReUUsUUFBUztRQUN6Q00sTUFBTSxDQUFDTixNQUFNLEdBQUdFLENBQUMsQ0FBQ0YsTUFBTSxHQUFHRyxDQUFDLENBQUNILE1BQU07SUFDdkM7SUFDQSxPQUFPTTtBQUNYO0FBQ0EsU0FBU0MsSUFBSTFFLEdBQUcsRUFBRTJFLE9BQU87SUFDckIsTUFBTTNDLFNBQVN6RSxrQkFBa0IwRSxjQUFjLENBQUMsQ0FBQyxHQUFHLEVBQUVqQyxJQUFJTixNQUFNLElBQUksRUFBRSxDQUFDLEVBQUVNLEtBQUs2RDtJQUM5RSxNQUFNZSxTQUFTNUMsT0FBT0ksTUFBTSxDQUFDdUM7SUFDN0IzQyxPQUFPTSxLQUFLO0lBQ1osT0FBT3NDO0FBQ1g7QUFDQSxTQUFTQyxnQkFBZ0JGLE9BQU8sRUFBRUcsVUFBVTtJQUN4QyxNQUFNQyxRQUFRbkgsT0FBT1UsS0FBSyxDQUFDeUY7SUFDM0IsTUFBTWlCLFFBQVFGLGFBQWFmO0lBQzNCLE1BQU1rQixNQUFNRCxRQUFRakI7SUFDcEJZLFFBQVFPLElBQUksQ0FBQ0gsT0FBTyxHQUFHQyxPQUFPQztJQUM5QixPQUFPRjtBQUNYO0FBQ0EsU0FBU0ksc0JBQXNCUixPQUFPLEVBQUVHLFVBQVU7SUFDOUMsTUFBTUMsUUFBUW5ILE9BQU9VLEtBQUssQ0FBQ3lGO0lBQzNCLE1BQU1pQixRQUFRRixhQUFhZjtJQUMzQixNQUFNa0IsTUFBTU4sUUFBUWpGLE1BQU07SUFDMUJxRixNQUFNSyxJQUFJLENBQUM7SUFDWFQsUUFBUU8sSUFBSSxDQUFDSCxPQUFPLEdBQUdDLE9BQU9DO0lBQzlCRixLQUFLLENBQUNFLE1BQU1ELE1BQU0sR0FBRztJQUNyQixPQUFPRDtBQUNYO0FBQ0EsU0FBU00sZ0JBQWdCckYsR0FBRztJQUN4QixNQUFNc0YsSUFBSVosSUFBSTFFLEtBQUs2RDtJQUNuQixJQUFJMEIsVUFBVXZCLGFBQWFzQjtJQUMzQixJQUFJQSxDQUFDLENBQUMsRUFBRSxHQUFHLE1BQU07UUFDYkMsVUFBVW5CLElBQUltQixTQUFTekI7SUFDM0I7SUFDQSxJQUFJMEIsVUFBVXhCLGFBQWF1QjtJQUMzQixJQUFJQSxPQUFPLENBQUMsRUFBRSxHQUFHLE1BQU07UUFDbkJDLFVBQVVwQixJQUFJb0IsU0FBUzFCO0lBQzNCO0lBQ0EsT0FBTztRQUFFeUI7UUFBU0M7SUFBUTtBQUM5QjtBQUNBLFNBQVNDLFFBQVF6RixHQUFHLEVBQUUyRSxPQUFPO0lBQ3pCLE1BQU1lLFVBQVVMLGdCQUFnQnJGO0lBQ2hDLElBQUkyRixhQUFhcEIsS0FBS3FCLElBQUksQ0FBQ2pCLFFBQVFqRixNQUFNLEdBQUdxRTtJQUM1QyxJQUFJOEI7SUFDSixJQUFJQztJQUNKLElBQUlILGVBQWUsR0FBRztRQUNsQkEsYUFBYTtRQUNiRSx3QkFBd0I7SUFDNUIsT0FDSztRQUNEQSx3QkFBeUJsQixRQUFRakYsTUFBTSxHQUFHcUUsY0FBYztJQUM1RDtJQUNBLE1BQU1nQyxpQkFBaUJKLGFBQWE7SUFDcEMsSUFBSUUsdUJBQXVCO1FBQ3ZCQyxZQUFZMUIsSUFBSVMsZ0JBQWdCRixTQUFTb0IsaUJBQWlCTCxRQUFRSCxPQUFPO0lBQzdFLE9BQ0s7UUFDRE8sWUFBWTFCLElBQUllLHNCQUFzQlIsU0FBU29CLGlCQUFpQkwsUUFBUUYsT0FBTztJQUNuRjtJQUNBLElBQUlRLElBQUluQztJQUNSLElBQUlvQztJQUNKLElBQUssSUFBSTlCLFFBQVEsR0FBR0EsUUFBUTRCLGdCQUFnQjVCLFFBQVM7UUFDakQ4QixJQUFJN0IsSUFBSTRCLEdBQUduQixnQkFBZ0JGLFNBQVNSO1FBQ3BDNkIsSUFBSXRCLElBQUkxRSxLQUFLaUc7SUFDakI7SUFDQUEsSUFBSTdCLElBQUkwQixXQUFXRTtJQUNuQixPQUFPdEIsSUFBSTFFLEtBQUtpRztBQUNwQjtBQUNBLE1BQU1DLHdCQUF3QjVJLGdCQUFnQjRJLGVBQWU7SUFDekQsTUFBTTdDLGNBQWM5RSxTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUNuRCxNQUFNUCxNQUFNLE1BQU1LLFVBQVVDLFdBQVcsQ0FBQztZQUNwQzlCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZrQixRQUFRbkIsVUFBVW1CLE1BQU07UUFDNUIsR0FBR2pCLGFBQWE4QjtRQUNoQixPQUFPSixhQUFhSDtJQUN4QjtJQUNBLE1BQU1tRyxPQUFPNUgsU0FBUyxFQUFFeUIsR0FBRyxFQUFFM0IsSUFBSSxFQUFFO1FBQy9CLE1BQU11RyxTQUFTYSxRQUFRMUYsYUFBYUMsS0FBSzNCLElBQUksRUFBRVQsT0FBT0MsSUFBSSxDQUFDUTtRQUMzRCxPQUFPLElBQUl5QyxXQUFXOEQsUUFBUTdELE1BQU07SUFDeEM7SUFDQSxNQUFNcUYsU0FBUzdILFNBQVMsRUFBRXlCLEdBQUcsRUFBRXFHLFNBQVMsRUFBRWhJLElBQUksRUFBRTtRQUM1QyxNQUFNaUksYUFBYSxNQUFNLElBQUksQ0FBQ0MsSUFBSSxDQUFDaEksV0FBV3lCLEtBQUszQjtRQUNuRCxPQUFPVCxPQUFPQyxJQUFJLENBQUN3SSxXQUFXRyxPQUFPLENBQUM1SSxPQUFPQyxJQUFJLENBQUN5SSxpQkFBaUI7SUFDdkU7SUFDQSxNQUFNOUMsWUFBWTlDLE1BQU0sRUFBRVYsR0FBRyxFQUFFO1FBQzNCLE9BQU9LLFVBQVVJLFNBQVMsQ0FBQ0MsUUFBUVgsYUFBYUM7SUFDcEQ7SUFDQSxNQUFNeUQsWUFBWS9DLE1BQU0sRUFBRU8sT0FBTyxFQUFFMUMsU0FBUyxFQUFFRSxXQUFXLEVBQUU4QixTQUFTLEVBQUU7UUFDbEUsTUFBTU4sTUFBTSxNQUFNSSxVQUFVVyxTQUFTLENBQUNOLFFBQVFPLFNBQVM7WUFBRXpDLE1BQU1ELFVBQVVDLElBQUk7UUFBQyxHQUFHQyxhQUFhOEI7UUFDOUYsT0FBT0osYUFBYUY7SUFDeEI7SUFDQXlELGVBQWUxRCxHQUFHLEVBQUUyRCxRQUFRLEVBQUU7UUFDMUIsS0FBSyxDQUFDRCxlQUFlMUQsS0FBSzJEO1FBQzFCLElBQUksQ0FBRTVELENBQUFBLGFBQWFDLGdCQUFnQlIsWUFBVyxHQUFJO1lBQzlDLE1BQU0sSUFBSW9FLFVBQVU7UUFDeEI7SUFDSjtBQUNKO0FBRUEsTUFBTTZDLHVCQUF1Qm5KLGdCQUFnQm1KLGNBQWM7SUFDdkQsTUFBTXBELGNBQWM5RSxTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUNuRCxNQUFNUCxNQUFNLE1BQU1LLFVBQVVDLFdBQVcsQ0FBQztZQUNwQzlCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZrQixRQUFRbkIsVUFBVW1CLE1BQU07UUFDNUIsR0FBR2pCLGFBQWE4QjtRQUNoQixPQUFPSixhQUFhSDtJQUN4QjtJQUNBLE1BQU1zRCxVQUFVL0UsU0FBUyxFQUFFeUIsR0FBRyxFQUFFM0IsSUFBSSxFQUFFO1FBQ2xDLE9BQU9nQyxVQUFVZSxPQUFPLENBQUM3QyxXQUFXd0IsYUFBYUMsTUFBTSxJQUFJYyxXQUFXekM7SUFDMUU7SUFDQSxNQUFNa0YsVUFBVWhGLFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUNsQyxPQUFPZ0MsVUFBVXFCLE9BQU8sQ0FBQ25ELFdBQVd3QixhQUFhQyxNQUFNLElBQUljLFdBQVd6QztJQUMxRTtJQUNBLE1BQU1tRixZQUFZOUMsTUFBTSxFQUFFVixHQUFHLEVBQUU7UUFDM0IsT0FBT0ssVUFBVUksU0FBUyxDQUFDQyxRQUFRWCxhQUFhQztJQUNwRDtJQUNBLE1BQU15RCxZQUFZL0MsTUFBTSxFQUFFTyxPQUFPLEVBQUUxQyxTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUNsRSxNQUFNTixNQUFNLE1BQU1JLFVBQVVXLFNBQVMsQ0FBQ04sUUFBUU8sU0FBUztZQUFFekMsTUFBTUQsVUFBVUMsSUFBSTtRQUFDLEdBQUdDLGFBQWE4QjtRQUM5RixPQUFPSixhQUFhRjtJQUN4QjtJQUNBeUQsZUFBZTFELEdBQUcsRUFBRTJELFFBQVEsRUFBRTtRQUMxQixLQUFLLENBQUNELGVBQWUxRCxLQUFLMkQ7UUFDMUIsSUFBSSxDQUFFNUQsQ0FBQUEsYUFBYUMsZ0JBQWdCUixZQUFXLEdBQUk7WUFDOUMsTUFBTSxJQUFJb0UsVUFBVTtRQUN4QjtJQUNKO0FBQ0o7QUFFQSxNQUFNOEMsdUJBQXVCcEosZ0JBQWdCb0osY0FBYztJQUN2RCxNQUFNckQsY0FBYzlFLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ25ELE1BQU1QLE1BQU0sTUFBTUssVUFBVUMsV0FBVyxDQUFDO1lBQ3BDOUIsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZmtCLFFBQVFuQixVQUFVbUIsTUFBTTtRQUM1QixHQUFHakIsYUFBYThCO1FBQ2hCLE9BQU9KLGFBQWFIO0lBQ3hCO0lBQ0EsTUFBTXNELFVBQVUvRSxTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDbEMsT0FBT2dDLFVBQVVlLE9BQU8sQ0FBQzdDLFdBQVd3QixhQUFhQyxNQUFNLElBQUljLFdBQVd6QztJQUMxRTtJQUNBLE1BQU1rRixVQUFVaEYsU0FBUyxFQUFFeUIsR0FBRyxFQUFFM0IsSUFBSSxFQUFFO1FBQ2xDLE9BQU9nQyxVQUFVcUIsT0FBTyxDQUFDbkQsV0FBV3dCLGFBQWFDLE1BQU0sSUFBSWMsV0FBV3pDO0lBQzFFO0lBQ0EsTUFBTW1GLFlBQVk5QyxNQUFNLEVBQUVWLEdBQUcsRUFBRTtRQUMzQixPQUFPSyxVQUFVSSxTQUFTLENBQUNDLFFBQVFYLGFBQWFDO0lBQ3BEO0lBQ0EsTUFBTXlELFlBQVkvQyxNQUFNLEVBQUVPLE9BQU8sRUFBRTFDLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ2xFLE1BQU1OLE1BQU0sTUFBTUksVUFBVVcsU0FBUyxDQUFDTixRQUFRTyxTQUFTO1lBQUV6QyxNQUFNRCxVQUFVQyxJQUFJO1FBQUMsR0FBR0MsYUFBYThCO1FBQzlGLE9BQU9KLGFBQWFGO0lBQ3hCO0lBQ0F5RCxlQUFlMUQsR0FBRyxFQUFFMkQsUUFBUSxFQUFFO1FBQzFCLEtBQUssQ0FBQ0QsZUFBZTFELEtBQUsyRDtRQUMxQixJQUFJLENBQUU1RCxDQUFBQSxhQUFhQyxnQkFBZ0JSLFlBQVcsR0FBSTtZQUM5QyxNQUFNLElBQUlvRSxVQUFVO1FBQ3hCO0lBQ0o7QUFDSjtBQUVBLE1BQU0rQyxzQkFBc0JySixnQkFBZ0JxSixhQUFhO0lBQ3JELE1BQU10RCxjQUFjOUUsU0FBUyxFQUFFRSxXQUFXLEVBQUU4QixTQUFTLEVBQUU7UUFDbkQsTUFBTU4sTUFBTSxNQUFNSSxVQUFVQyxXQUFXLENBQUM7WUFDcEM5QixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNma0IsUUFBUW5CLFVBQVVtQixNQUFNO1FBQzVCLEdBQUdqQixhQUFhOEI7UUFDaEIsT0FBT0osYUFBYUY7SUFDeEI7SUFDQSxNQUFNdUQsWUFBWTlDLE1BQU0sRUFBRVYsR0FBRyxFQUFFO1FBQzNCLE9BQU9LLFVBQVVJLFNBQVMsQ0FBQ0MsUUFBUVgsYUFBYUM7SUFDcEQ7SUFDQSxNQUFNeUQsWUFBWS9DLE1BQU0sRUFBRU8sT0FBTyxFQUFFMUMsU0FBUyxFQUFFRSxXQUFXLEVBQUU4QixTQUFTLEVBQUU7UUFDbEUsTUFBTU4sTUFBTSxNQUFNSSxVQUFVVyxTQUFTLENBQUNOLFFBQVFPLFNBQVM7WUFBRXpDLE1BQU1ELFVBQVVDLElBQUk7UUFBQyxHQUFHQyxhQUFhOEI7UUFDOUYsT0FBT0osYUFBYUY7SUFDeEI7SUFDQSxNQUFNcUQsVUFBVS9FLFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUNsQyxPQUFPZ0MsVUFBVWUsT0FBTyxDQUFDN0MsV0FBV3dCLGFBQWFDLE1BQU0sSUFBSWMsV0FBV3pDO0lBQzFFO0lBQ0EsTUFBTWtGLFVBQVVoRixTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDbEMsT0FBT2dDLFVBQVVxQixPQUFPLENBQUNuRCxXQUFXd0IsYUFBYUMsTUFBTSxJQUFJYyxXQUFXekM7SUFDMUU7SUFDQXFGLGVBQWUxRCxHQUFHLEVBQUUyRCxRQUFRLEVBQUU7UUFDMUIsS0FBSyxDQUFDRCxlQUFlMUQsS0FBSzJEO1FBQzFCLElBQUksQ0FBRTVELENBQUFBLGFBQWFDLGdCQUFnQlIsWUFBVyxHQUFJO1lBQzlDLE1BQU0sSUFBSW9FLFVBQVU7UUFDeEI7SUFDSjtBQUNKO0FBRUEsTUFBTWdELHVCQUF1QnRKLGdCQUFnQnNKLGNBQWM7SUFDdkQsTUFBTXZELGNBQWM5RSxTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUNuRCxNQUFNUCxNQUFNLE1BQU1LLFVBQVVDLFdBQVcsQ0FBQztZQUNwQzlCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZrQixRQUFRbkIsVUFBVW1CLE1BQU07UUFDNUIsR0FBR2pCLGFBQWE4QjtRQUNoQixPQUFPSixhQUFhSDtJQUN4QjtJQUNBLE1BQU1zRCxVQUFVL0UsU0FBUyxFQUFFeUIsR0FBRyxFQUFFM0IsSUFBSSxFQUFFO1FBQ2xDLE9BQU9nQyxVQUFVZSxPQUFPLENBQUM3QyxXQUFXd0IsYUFBYUMsTUFBTSxJQUFJYyxXQUFXekM7SUFDMUU7SUFDQSxNQUFNa0YsVUFBVWhGLFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUNsQyxPQUFPZ0MsVUFBVXFCLE9BQU8sQ0FBQ25ELFdBQVd3QixhQUFhQyxNQUFNLElBQUljLFdBQVd6QztJQUMxRTtJQUNBLE1BQU1tRixZQUFZOUMsTUFBTSxFQUFFVixHQUFHLEVBQUU7UUFDM0IsT0FBT0ssVUFBVUksU0FBUyxDQUFDQyxRQUFRWCxhQUFhQztJQUNwRDtJQUNBLE1BQU15RCxZQUFZL0MsTUFBTSxFQUFFTyxPQUFPLEVBQUUxQyxTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUNsRSxNQUFNTixNQUFNLE1BQU1JLFVBQVVXLFNBQVMsQ0FBQ04sUUFBUU8sU0FBUztZQUFFekMsTUFBTUQsVUFBVUMsSUFBSTtRQUFDLEdBQUdDLGFBQWE4QjtRQUM5RixPQUFPSixhQUFhRjtJQUN4QjtJQUNBeUQsZUFBZTFELEdBQUcsRUFBRTJELFFBQVEsRUFBRTtRQUMxQixLQUFLLENBQUNELGVBQWUxRCxLQUFLMkQ7UUFDMUIsSUFBSSxDQUFFNUQsQ0FBQUEsYUFBYUMsZ0JBQWdCUixZQUFXLEdBQUk7WUFDOUMsTUFBTSxJQUFJb0UsVUFBVTtRQUN4QjtJQUNKO0FBQ0o7QUFFQSxNQUFNaUQscUJBQXFCdkg7SUFDdkIsSUFBSVQsTUFBTTtRQUNOLE9BQVEsSUFBSSxDQUFDTixTQUFTLENBQUNDLElBQUksQ0FBQ2lCLFdBQVc7WUFDbkMsS0FBSztnQkFDRCxPQUFPLENBQUMsT0FBTyxDQUFDO1lBQ3BCLEtBQUs7Z0JBQ0QsT0FBTyxDQUFDLFFBQVEsQ0FBQztZQUNyQjtnQkFDSSxNQUFNLElBQUluQyxnQkFBZ0JxQyxjQUFjLENBQUM7UUFDakQ7SUFDSjtJQUNBLElBQUlkLElBQUlsQixLQUFLLEVBQUUsQ0FDZjtBQUNKO0FBQ0F4QixNQUFNMkMsVUFBVSxDQUFDO0lBQ2IxQyxXQUFXMkMsUUFBUSxDQUFDO1FBQUVQLE1BQU07UUFBS29CLFdBQVduQztJQUF1QjtDQUN0RSxFQUFFb0osYUFBYTFILFNBQVMsRUFBRSxRQUFRLEtBQUs7QUFFeEMsTUFBTTJIO0lBQ0YsYUFBYXhHLFlBQVkvQixTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUN4RCxNQUFNUCxNQUFNLElBQUk2RztRQUNoQjdHLElBQUl6QixTQUFTLEdBQUdBO1FBQ2hCeUIsSUFBSXZCLFdBQVcsR0FBR0E7UUFDbEJ1QixJQUFJckIsTUFBTSxHQUFHNEI7UUFDYlAsSUFBSTNCLElBQUksR0FBR3BDLE9BQU91RSxXQUFXLENBQUNqQyxVQUFVbUIsTUFBTSxJQUFJO1FBQ2xELE9BQU9NO0lBQ1g7SUFDQSxhQUFhUyxVQUFVQyxNQUFNLEVBQUVWLEdBQUcsRUFBRTtRQUNoQyxPQUFRVSxPQUFPRSxXQUFXO1lBQ3RCLEtBQUs7Z0JBQ0QsT0FBT3hFLFdBQVd5RSxjQUFjLENBQUM3QyxNQUFNLENBQUNnQztZQUM1QyxLQUFLO2dCQUNELE9BQU8sSUFBSWMsV0FBV2QsSUFBSTNCLElBQUksRUFBRTBDLE1BQU07WUFDMUM7Z0JBQ0ksTUFBTSxJQUFJekQsZ0JBQWdCNEMsY0FBYyxDQUFDO1FBQ2pEO0lBQ0o7SUFDQSxhQUFhYyxVQUFVTixNQUFNLEVBQUVPLE9BQU8sRUFBRTFDLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ3ZFLElBQUlQO1FBQ0osT0FBUVUsT0FBT0UsV0FBVztZQUN0QixLQUFLO2dCQUNEWixNQUFNNUQsV0FBVzhFLFVBQVUsQ0FBQ3hELFFBQVEsQ0FBQ3VELFNBQVM7b0JBQUVFLGNBQWMwRjtnQkFBYTtnQkFDM0U7WUFDSixLQUFLO2dCQUNEN0csTUFBTSxJQUFJNkc7Z0JBQ1Y3RyxJQUFJM0IsSUFBSSxHQUFHVCxPQUFPQyxJQUFJLENBQUNvRDtnQkFDdkI7WUFDSjtnQkFDSSxNQUFNLElBQUkzRCxnQkFBZ0I0QyxjQUFjLENBQUM7UUFDakQ7UUFDQUYsSUFBSXpCLFNBQVMsR0FBR0E7UUFDaEJ5QixJQUFJdkIsV0FBVyxHQUFHQTtRQUNsQnVCLElBQUlyQixNQUFNLEdBQUc0QjtRQUNiLE9BQU9QO0lBQ1g7SUFDQSxhQUFhb0IsUUFBUTdDLFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUN2QyxPQUFRRSxVQUFVQyxJQUFJLENBQUNpQixXQUFXO1lBQzlCLEtBQUs7Z0JBQ0QsT0FBTyxJQUFJLENBQUNzSCxhQUFhLENBQUN4SSxXQUFXeUIsS0FBS3BDLE9BQU9DLElBQUksQ0FBQ1E7WUFDMUQsS0FBSztnQkFDRCxPQUFPLElBQUksQ0FBQzJJLGlCQUFpQixDQUFDekksV0FBV3lCLEtBQUtwQyxPQUFPQyxJQUFJLENBQUNRO1lBQzlEO2dCQUNJLE1BQU0sSUFBSWYsZ0JBQWdCNEMsY0FBYyxDQUFDO1FBQ2pEO0lBQ0o7SUFDQSxhQUFhd0IsUUFBUW5ELFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUN2QyxJQUFJLENBQUUyQixDQUFBQSxlQUFlNkcsWUFBVyxHQUFJO1lBQ2hDLE1BQU0sSUFBSWxHLE1BQU07UUFDcEI7UUFDQSxPQUFRcEMsVUFBVUMsSUFBSSxDQUFDaUIsV0FBVztZQUM5QixLQUFLO2dCQUNELE9BQU8sSUFBSSxDQUFDd0gsYUFBYSxDQUFDMUksV0FBV3lCLEtBQUtwQyxPQUFPQyxJQUFJLENBQUNRO1lBQzFELEtBQUs7Z0JBQ0QsT0FBTyxJQUFJLENBQUM2SSxpQkFBaUIsQ0FBQzNJLFdBQVd5QixLQUFLcEMsT0FBT0MsSUFBSSxDQUFDUTtZQUM5RDtnQkFDSSxNQUFNLElBQUlmLGdCQUFnQjRDLGNBQWMsQ0FBQztRQUNqRDtJQUNKO0lBQ0EsYUFBYTZHLGNBQWN4SSxTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDN0MsTUFBTTJELFNBQVMvRixPQUFPZ0csY0FBYyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUVqQyxJQUFJM0IsSUFBSSxFQUFFLElBQUl5QyxXQUFXdkMsVUFBVTJELEVBQUU7UUFDckYsSUFBSUMsTUFBTUgsT0FBT0ksTUFBTSxDQUFDL0Q7UUFDeEI4RCxNQUFNdkUsT0FBT3lFLE1BQU0sQ0FBQztZQUFDRjtZQUFLSCxPQUFPTSxLQUFLO1NBQUc7UUFDekMsTUFBTXJDLE1BQU0sSUFBSWEsV0FBV3FCLEtBQUtwQixNQUFNO1FBQ3RDLE9BQU9kO0lBQ1g7SUFDQSxhQUFhZ0gsY0FBYzFJLFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUM3QyxNQUFNa0UsV0FBV3RHLE9BQU91RyxnQkFBZ0IsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFeEMsSUFBSTNCLElBQUksRUFBRSxJQUFJeUMsV0FBV3ZDLFVBQVUyRCxFQUFFO1FBQ3pGLElBQUlPLE1BQU1GLFNBQVNILE1BQU0sQ0FBQy9EO1FBQzFCb0UsTUFBTTdFLE9BQU95RSxNQUFNLENBQUM7WUFBQ0k7WUFBS0YsU0FBU0QsS0FBSztTQUFHO1FBQzNDLE9BQU8sSUFBSXhCLFdBQVcyQixLQUFLMUIsTUFBTTtJQUNyQztJQUNBLGFBQWFpRyxrQkFBa0J6SSxTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDakQsTUFBTTJELFNBQVMvRixPQUFPZ0csY0FBYyxDQUFDLENBQUMsWUFBWSxDQUFDLEVBQUVqQyxJQUFJM0IsSUFBSSxFQUFFVCxPQUFPQyxJQUFJLENBQUNVLFVBQVUyRCxFQUFFO1FBQ3ZGLElBQUlDLE1BQU1ILE9BQU9JLE1BQU0sQ0FBQy9EO1FBQ3hCOEQsTUFBTXZFLE9BQU95RSxNQUFNLENBQUM7WUFBQ0Y7WUFBS0gsT0FBT00sS0FBSztTQUFHO1FBQ3pDLE1BQU1yQyxNQUFNLElBQUlhLFdBQVdxQixLQUFLcEIsTUFBTTtRQUN0QyxPQUFPZDtJQUNYO0lBQ0EsYUFBYWlILGtCQUFrQjNJLFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUNqRCxNQUFNa0UsV0FBV3RHLE9BQU91RyxnQkFBZ0IsQ0FBQyxDQUFDLFlBQVksQ0FBQyxFQUFFeEMsSUFBSTNCLElBQUksRUFBRSxJQUFJeUMsV0FBV3ZDLFVBQVUyRCxFQUFFO1FBQzlGLElBQUlPLE1BQU1GLFNBQVNILE1BQU0sQ0FBQy9EO1FBQzFCb0UsTUFBTTdFLE9BQU95RSxNQUFNLENBQUM7WUFBQ0k7WUFBS0YsU0FBU0QsS0FBSztTQUFHO1FBQzNDLE9BQU8sSUFBSXhCLFdBQVcyQixLQUFLMUIsTUFBTTtJQUNyQztBQUNKO0FBRUEsTUFBTW9HLHVCQUF1QjdKLGdCQUFnQjhKLFdBQVc7SUFDcERqSixhQUFjO1FBQ1YsS0FBSyxJQUFJQztRQUNULElBQUksQ0FBQ2lKLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQzlJLElBQUksR0FBRztJQUNoQjtJQUNBLE1BQU02RSxjQUFjOUUsU0FBUyxFQUFFRSxXQUFXLEVBQUU4QixTQUFTLEVBQUU7UUFDbkQsTUFBTVAsTUFBTSxNQUFNOEcsVUFBVXhHLFdBQVcsQ0FBQztZQUNwQzlCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZrQixRQUFRLElBQUksQ0FBQzJILFdBQVc7UUFDNUIsR0FBRzVJLGFBQWE4QjtRQUNoQixPQUFPSixhQUFhSDtJQUN4QjtJQUNBLE1BQU1zRCxVQUFVL0UsU0FBUyxFQUFFeUIsR0FBRyxFQUFFM0IsSUFBSSxFQUFFO1FBQ2xDLE9BQU95SSxVQUFVMUYsT0FBTyxDQUFDN0MsV0FBV3dCLGFBQWFDLE1BQU0sSUFBSWMsV0FBV3pDO0lBQzFFO0lBQ0EsTUFBTWtGLFVBQVVoRixTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDbEMsT0FBT3lJLFVBQVVwRixPQUFPLENBQUNuRCxXQUFXd0IsYUFBYUMsTUFBTSxJQUFJYyxXQUFXekM7SUFDMUU7SUFDQSxNQUFNbUYsWUFBWTlDLE1BQU0sRUFBRVYsR0FBRyxFQUFFO1FBQzNCLE9BQU84RyxVQUFVckcsU0FBUyxDQUFDQyxRQUFRWCxhQUFhQztJQUNwRDtJQUNBLE1BQU15RCxZQUFZL0MsTUFBTSxFQUFFTyxPQUFPLEVBQUUxQyxTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUNsRSxNQUFNUCxNQUFNLE1BQU04RyxVQUFVOUYsU0FBUyxDQUFDTixRQUFRTyxTQUFTO1lBQUV6QyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUFFa0IsUUFBUSxJQUFJLENBQUMySCxXQUFXO1FBQUMsR0FBRzVJLGFBQWE4QjtRQUNuSCxJQUFJUCxJQUFJM0IsSUFBSSxDQUFDcUIsTUFBTSxLQUFNLElBQUksQ0FBQzJILFdBQVcsSUFBSSxHQUFJO1lBQzdDLE1BQU0sSUFBSS9KLGdCQUFnQjRDLGNBQWMsQ0FBQztRQUM3QztRQUNBLE9BQU9DLGFBQWFIO0lBQ3hCO0lBQ0EwRCxlQUFlMUQsR0FBRyxFQUFFMkQsUUFBUSxFQUFFO1FBQzFCLEtBQUssQ0FBQ0QsZUFBZTFELEtBQUsyRDtRQUMxQixJQUFJLENBQUU1RCxDQUFBQSxhQUFhQyxnQkFBZ0I2RyxZQUFXLEdBQUk7WUFDOUMsTUFBTSxJQUFJakQsVUFBVTtRQUN4QjtJQUNKO0FBQ0o7QUFFQSxNQUFNMkQsMkJBQTJCakssZ0JBQWdCOEosV0FBVztJQUN4RGpKLGFBQWM7UUFDVixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDaUosV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDOUksSUFBSSxHQUFHO0lBQ2hCO0lBQ0EsTUFBTTZFLGNBQWM5RSxTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUNuRCxNQUFNUCxNQUFNLE1BQU04RyxVQUFVeEcsV0FBVyxDQUFDO1lBQ3BDOUIsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZmtCLFFBQVEsSUFBSSxDQUFDMkgsV0FBVztRQUM1QixHQUFHNUksYUFBYThCO1FBQ2hCLE9BQU9KLGFBQWFIO0lBQ3hCO0lBQ0EsTUFBTXNELFVBQVUvRSxTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDbEMsT0FBT3lJLFVBQVUxRixPQUFPLENBQUM3QyxXQUFXd0IsYUFBYUMsTUFBTSxJQUFJYyxXQUFXekM7SUFDMUU7SUFDQSxNQUFNa0YsVUFBVWhGLFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUNsQyxPQUFPeUksVUFBVXBGLE9BQU8sQ0FBQ25ELFdBQVd3QixhQUFhQyxNQUFNLElBQUljLFdBQVd6QztJQUMxRTtJQUNBLE1BQU1tRixZQUFZOUMsTUFBTSxFQUFFVixHQUFHLEVBQUU7UUFDM0IsT0FBTzhHLFVBQVVyRyxTQUFTLENBQUNDLFFBQVFYLGFBQWFDO0lBQ3BEO0lBQ0EsTUFBTXlELFlBQVkvQyxNQUFNLEVBQUVPLE9BQU8sRUFBRTFDLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ2xFLE1BQU1QLE1BQU0sTUFBTThHLFVBQVU5RixTQUFTLENBQUNOLFFBQVFPLFNBQVM7WUFBRXpDLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQUVrQixRQUFRLElBQUksQ0FBQzJILFdBQVc7UUFBQyxHQUFHNUksYUFBYThCO1FBQ25ILElBQUlQLElBQUkzQixJQUFJLENBQUNxQixNQUFNLEtBQU0sSUFBSSxDQUFDMkgsV0FBVyxJQUFJLEdBQUk7WUFDN0MsTUFBTSxJQUFJL0osZ0JBQWdCNEMsY0FBYyxDQUFDO1FBQzdDO1FBQ0EsT0FBT0MsYUFBYUg7SUFDeEI7SUFDQTBELGVBQWUxRCxHQUFHLEVBQUUyRCxRQUFRLEVBQUU7UUFDMUIsS0FBSyxDQUFDRCxlQUFlMUQsS0FBSzJEO1FBQzFCLElBQUksQ0FBRTVELENBQUFBLGFBQWFDLGdCQUFnQjZHLFlBQVcsR0FBSTtZQUM5QyxNQUFNLElBQUlqRCxVQUFVO1FBQ3hCO0lBQ0o7QUFDSjtBQUVBLFNBQVM0RCxnQkFBZ0JqSixTQUFTO0lBQzlCLE9BQVFBLFVBQVVDLElBQUksQ0FBQ2lCLFdBQVc7UUFDOUIsS0FBSztZQUFZO2dCQUNiLE1BQU1nSSxTQUFTLFNBQVNDLElBQUksQ0FBQ25KLFVBQVVvSixJQUFJLENBQUNuSixJQUFJLENBQUMsQ0FBQyxFQUFFO2dCQUNwRCxPQUFPLENBQUMsUUFBUSxFQUFFaUosV0FBVyxNQUFNLENBQUMsQ0FBQyxFQUFFQSxPQUFPLENBQUMsR0FBRyxHQUFHLENBQUM7WUFDMUQ7UUFDQSxLQUFLO1lBQ0QsT0FBTyxDQUFDLEVBQUUsRUFBRSxTQUFTQyxJQUFJLENBQUNuSixVQUFVb0osSUFBSSxDQUFDbkosSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDdkQsS0FBSztZQUNELE9BQU8sQ0FBQyxFQUFFLEVBQUUsU0FBU2tKLElBQUksQ0FBQ25KLFVBQVVvSixJQUFJLENBQUNuSixJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUN2RCxLQUFLO1lBQ0QsT0FBTyxDQUFDLEdBQUcsQ0FBQztRQUNoQjtZQUNJLE1BQU0sSUFBSWxCLGdCQUFnQjRDLGNBQWMsQ0FBQztJQUNqRDtBQUNKO0FBRUEsTUFBTTBILHNCQUFzQnJJO0lBQ3hCcEIsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUNNLElBQUksR0FBRztJQUNoQjtJQUNBbUosU0FBUztRQUNMLE1BQU1DLFVBQVV4TCxXQUFXeUwsU0FBUyxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDM0osSUFBSSxFQUFFZixnQkFBZ0IySyxJQUFJLENBQUNDLGNBQWM7UUFDekYsT0FBTzVMLFdBQVd5TCxTQUFTLENBQUNDLEtBQUssQ0FBQ0YsUUFBUUssVUFBVSxFQUFFN0ssZ0JBQWdCMkssSUFBSSxDQUFDTCxhQUFhO0lBQzVGO0lBQ0E1SixTQUFTO1FBQ0wsTUFBTWdDLE1BQU0sSUFBSSxDQUFDNkgsTUFBTTtRQUN2QixNQUFNTyxPQUFPO1lBQ1R4SixLQUFLO1lBQ0xDLEtBQUsySSxnQkFBZ0IsSUFBSSxDQUFDakosU0FBUztZQUNuQzhKLFNBQVMsSUFBSSxDQUFDMUosTUFBTTtZQUNwQjJKLEtBQUssSUFBSSxDQUFDN0osV0FBVztRQUN6QjtRQUNBLE9BQU8vQixPQUFPNkwsTUFBTSxDQUFDSCxNQUFNaE0sV0FBV3lFLGNBQWMsQ0FBQzdDLE1BQU0sQ0FBQ2dDO0lBQ2hFO0lBQ0F0QyxTQUFTMEssSUFBSSxFQUFFO1FBQ1gsTUFBTXBJLE1BQU01RCxXQUFXOEUsVUFBVSxDQUFDeEQsUUFBUSxDQUFDMEssTUFBTTtZQUFFakgsY0FBYzdELGdCQUFnQjJLLElBQUksQ0FBQ0wsYUFBYTtRQUFDO1FBQ3BHLE1BQU1FLFVBQVUsSUFBSXhLLGdCQUFnQjJLLElBQUksQ0FBQ0MsY0FBYztRQUN2REosUUFBUVUsbUJBQW1CLENBQUNqSyxTQUFTLEdBQUc7UUFDeEN1SixRQUFRVSxtQkFBbUIsQ0FBQ0MsVUFBVSxHQUFHO1FBQ3pDWCxRQUFRSyxVQUFVLEdBQUc3TCxXQUFXb00sYUFBYSxDQUFDQyxTQUFTLENBQUMzSTtRQUN4RCxJQUFJLENBQUMzQixJQUFJLEdBQUdULE9BQU9DLElBQUksQ0FBQ3ZCLFdBQVdvTSxhQUFhLENBQUNDLFNBQVMsQ0FBQ2I7SUFDL0Q7QUFDSjtBQUVBLE1BQU1jLHFCQUFxQnJKO0lBQ3ZCcEIsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUNNLElBQUksR0FBRztJQUNoQjtJQUNBbUosU0FBUztRQUNMLE1BQU1DLFVBQVV4TCxXQUFXeUwsU0FBUyxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDM0osSUFBSSxFQUFFZixnQkFBZ0IySyxJQUFJLENBQUNZLGFBQWE7UUFDeEYsT0FBT3ZNLFdBQVd5TCxTQUFTLENBQUNDLEtBQUssQ0FBQ0YsUUFBUWdCLFNBQVMsRUFBRXhMLGdCQUFnQjJLLElBQUksQ0FBQ1csWUFBWTtJQUMxRjtJQUNBNUssU0FBUztRQUNMLE1BQU1nQyxNQUFNLElBQUksQ0FBQzZILE1BQU07UUFDdkIsTUFBTU8sT0FBTztZQUNUeEosS0FBSztZQUNMQyxLQUFLMkksZ0JBQWdCLElBQUksQ0FBQ2pKLFNBQVM7WUFDbkM4SixTQUFTLElBQUksQ0FBQzFKLE1BQU07WUFDcEIySixLQUFLLElBQUksQ0FBQzdKLFdBQVc7UUFDekI7UUFDQSxPQUFPL0IsT0FBTzZMLE1BQU0sQ0FBQ0gsTUFBTWhNLFdBQVd5RSxjQUFjLENBQUM3QyxNQUFNLENBQUNnQztJQUNoRTtJQUNBdEMsU0FBUzBLLElBQUksRUFBRTtRQUNYLE1BQU1wSSxNQUFNNUQsV0FBVzhFLFVBQVUsQ0FBQ3hELFFBQVEsQ0FBQzBLLE1BQU07WUFBRWpILGNBQWM3RCxnQkFBZ0IySyxJQUFJLENBQUNXLFlBQVk7UUFBQztRQUNuRyxNQUFNZCxVQUFVLElBQUl4SyxnQkFBZ0IySyxJQUFJLENBQUNZLGFBQWE7UUFDdERmLFFBQVFpQixrQkFBa0IsQ0FBQ3hLLFNBQVMsR0FBRztRQUN2Q3VKLFFBQVFpQixrQkFBa0IsQ0FBQ04sVUFBVSxHQUFHO1FBQ3hDWCxRQUFRZ0IsU0FBUyxHQUFHeE0sV0FBV29NLGFBQWEsQ0FBQ0MsU0FBUyxDQUFDM0k7UUFDdkQsSUFBSSxDQUFDM0IsSUFBSSxHQUFHVCxPQUFPQyxJQUFJLENBQUN2QixXQUFXb00sYUFBYSxDQUFDQyxTQUFTLENBQUNiO0lBQy9EO0FBQ0o7QUFFQSxNQUFNa0I7SUFDRixhQUFhMUksWUFBWS9CLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ3hELE1BQU00SCxhQUFhLElBQUlQO1FBQ3ZCTyxXQUFXNUosU0FBUyxHQUFHQTtRQUN2QjRKLFdBQVcxSixXQUFXLEdBQUdBO1FBQ3pCMEosV0FBV3hKLE1BQU0sR0FBRzRCLFVBQVUwSSxNQUFNLENBQUMsQ0FBQ0MsUUFBVSxJQUFJLENBQUNDLGdCQUFnQixDQUFDQyxPQUFPLENBQUNGLFdBQVcsQ0FBQztRQUMxRixNQUFNSixZQUFZLElBQUlGO1FBQ3RCRSxVQUFVdkssU0FBUyxHQUFHQTtRQUN0QnVLLFVBQVVySyxXQUFXLEdBQUc7UUFDeEJxSyxVQUFVbkssTUFBTSxHQUFHNEIsVUFBVTBJLE1BQU0sQ0FBQyxDQUFDQyxRQUFVLElBQUksQ0FBQ0csZUFBZSxDQUFDRCxPQUFPLENBQUNGLFdBQVcsQ0FBQztRQUN4RixNQUFNSSxpQkFBaUIxTCxPQUFPeUUsTUFBTSxDQUFDO1lBQ2pDekUsT0FBT1UsS0FBSyxDQUFDLElBQUlDLFVBQVUrSyxjQUFjLENBQUNDLFVBQVUsRUFBRTtZQUN0RDNMLE9BQU9DLElBQUksQ0FBQ1UsVUFBVStLLGNBQWM7U0FDdkMsRUFBRUUsV0FBVyxDQUFDO1FBQ2YsTUFBTTVNLE9BQU9YLE9BQU93TixtQkFBbUIsQ0FBQyxPQUFPO1lBQzNDQyxlQUFlbkwsVUFBVW1MLGFBQWE7WUFDdENKO1lBQ0FLLG1CQUFtQjtnQkFDZmpKLFFBQVE7Z0JBQ1JoQyxNQUFNO1lBQ1Y7WUFDQWtMLG9CQUFvQjtnQkFDaEJsSixRQUFRO2dCQUNSaEMsTUFBTTtZQUNWO1FBQ0o7UUFDQXlKLFdBQVc5SixJQUFJLEdBQUd6QixLQUFLdUwsVUFBVTtRQUNqQ1csVUFBVXpLLElBQUksR0FBR3pCLEtBQUtrTSxTQUFTO1FBQy9CLE1BQU03SSxNQUFNO1lBQ1JrSTtZQUNBVztRQUNKO1FBQ0EsT0FBTzdJO0lBQ1g7SUFDQSxhQUFhUSxVQUFVQyxNQUFNLEVBQUVWLEdBQUcsRUFBRTtRQUNoQyxPQUFRVSxPQUFPRSxXQUFXO1lBQ3RCLEtBQUs7Z0JBQ0QsT0FBT3hFLFdBQVd5RSxjQUFjLENBQUM3QyxNQUFNLENBQUNnQztZQUM1QyxLQUFLO1lBQ0wsS0FBSztnQkFDRCxPQUFPLElBQUljLFdBQVdkLElBQUkzQixJQUFJLEVBQUUwQyxNQUFNO1lBQzFDO2dCQUNJLE1BQU0sSUFBSXpELGdCQUFnQjRDLGNBQWMsQ0FBQztRQUNqRDtJQUNKO0lBQ0EsYUFBYWMsVUFBVU4sTUFBTSxFQUFFTyxPQUFPLEVBQUUxQyxTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUN2RSxPQUFRRyxPQUFPRSxXQUFXO1lBQ3RCLEtBQUs7Z0JBQU87b0JBQ1IsTUFBTWlKLE1BQU01STtvQkFDWixJQUFJNEksSUFBSTlNLENBQUMsRUFBRTt3QkFDUCxNQUFNK00sU0FBUzFOLFdBQVc4RSxVQUFVLENBQUN4RCxRQUFRLENBQUN1RCxTQUFTOzRCQUFFRSxjQUFjN0QsZ0JBQWdCMkssSUFBSSxDQUFDTCxhQUFhO3dCQUFDO3dCQUMxRyxPQUFPLElBQUksQ0FBQ21DLGdCQUFnQixDQUFDRCxRQUFRdkwsV0FBV0UsYUFBYThCO29CQUNqRSxPQUNLO3dCQUNELE1BQU11SixTQUFTMU4sV0FBVzhFLFVBQVUsQ0FBQ3hELFFBQVEsQ0FBQ3VELFNBQVM7NEJBQUVFLGNBQWM3RCxnQkFBZ0IySyxJQUFJLENBQUNXLFlBQVk7d0JBQUM7d0JBQ3pHLE9BQU8sSUFBSSxDQUFDb0IsZUFBZSxDQUFDRixRQUFRdkwsV0FBV0UsYUFBYThCO29CQUNoRTtnQkFDSjtZQUNBLEtBQUs7Z0JBQVE7b0JBQ1QsTUFBTXVILFVBQVV4TCxXQUFXeUwsU0FBUyxDQUFDQyxLQUFLLENBQUMsSUFBSWxILFdBQVdHLFVBQVUzRCxnQkFBZ0IySyxJQUFJLENBQUNZLGFBQWE7b0JBQ3RHLE1BQU1pQixTQUFTeE4sV0FBV3lMLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDRixRQUFRZ0IsU0FBUyxFQUFFeEwsZ0JBQWdCMkssSUFBSSxDQUFDVyxZQUFZO29CQUM5RixPQUFPLElBQUksQ0FBQ29CLGVBQWUsQ0FBQ0YsUUFBUXZMLFdBQVdFLGFBQWE4QjtnQkFDaEU7WUFDQSxLQUFLO2dCQUFTO29CQUNWLE1BQU11SCxVQUFVeEwsV0FBV3lMLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDLElBQUlsSCxXQUFXRyxVQUFVM0QsZ0JBQWdCMkssSUFBSSxDQUFDQyxjQUFjO29CQUN2RyxNQUFNNEIsU0FBU3hOLFdBQVd5TCxTQUFTLENBQUNDLEtBQUssQ0FBQ0YsUUFBUUssVUFBVSxFQUFFN0ssZ0JBQWdCMkssSUFBSSxDQUFDTCxhQUFhO29CQUNoRyxPQUFPLElBQUksQ0FBQ21DLGdCQUFnQixDQUFDRCxRQUFRdkwsV0FBV0UsYUFBYThCO2dCQUNqRTtZQUNBO2dCQUNJLE1BQU0sSUFBSWpELGdCQUFnQjRDLGNBQWMsQ0FBQztRQUNqRDtJQUNKO0lBQ0EsYUFBYXFHLEtBQUtoSSxTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDcEMsT0FBUUUsVUFBVUMsSUFBSSxDQUFDaUIsV0FBVztZQUM5QixLQUFLO1lBQ0wsS0FBSztnQkFDRCxPQUFPLElBQUksQ0FBQ3dLLE9BQU8sQ0FBQzFMLFdBQVd5QixLQUFLM0I7WUFDeEM7Z0JBQ0ksTUFBTSxJQUFJZixnQkFBZ0I0QyxjQUFjLENBQUM7UUFDakQ7SUFDSjtJQUNBLGFBQWFnSyxPQUFPM0wsU0FBUyxFQUFFeUIsR0FBRyxFQUFFcUcsU0FBUyxFQUFFaEksSUFBSSxFQUFFO1FBQ2pELE9BQVFFLFVBQVVDLElBQUksQ0FBQ2lCLFdBQVc7WUFDOUIsS0FBSztZQUNMLEtBQUs7Z0JBQ0QsT0FBTyxJQUFJLENBQUMwSyxTQUFTLENBQUM1TCxXQUFXeUIsS0FBSzNCLE1BQU1nSTtZQUNoRDtnQkFDSSxNQUFNLElBQUkvSSxnQkFBZ0I0QyxjQUFjLENBQUM7UUFDakQ7SUFDSjtJQUNBLGFBQWFrQixRQUFRN0MsU0FBUyxFQUFFeUIsR0FBRyxFQUFFM0IsSUFBSSxFQUFFO1FBQ3ZDLE9BQVFFLFVBQVVDLElBQUksQ0FBQ2lCLFdBQVc7WUFDOUIsS0FBSztnQkFDRCxPQUFPLElBQUksQ0FBQzJLLFdBQVcsQ0FBQzdMLFdBQVd5QixLQUFLM0I7WUFDNUM7Z0JBQ0ksTUFBTSxJQUFJZixnQkFBZ0I0QyxjQUFjLENBQUM7UUFDakQ7SUFDSjtJQUNBLGFBQWF3QixRQUFRbkQsU0FBUyxFQUFFeUIsR0FBRyxFQUFFM0IsSUFBSSxFQUFFO1FBQ3ZDLE9BQVFFLFVBQVVDLElBQUksQ0FBQ2lCLFdBQVc7WUFDOUIsS0FBSztnQkFDRCxPQUFPLElBQUksQ0FBQzRLLFdBQVcsQ0FBQzlMLFdBQVd5QixLQUFLM0I7WUFDNUM7Z0JBQ0ksTUFBTSxJQUFJZixnQkFBZ0I0QyxjQUFjLENBQUM7UUFDakQ7SUFDSjtJQUNBLE9BQU82SixpQkFBaUJELE1BQU0sRUFBRXZMLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQy9ELE1BQU11SCxVQUFVLElBQUl4SyxnQkFBZ0IySyxJQUFJLENBQUNDLGNBQWM7UUFDdkRKLFFBQVFVLG1CQUFtQixDQUFDakssU0FBUyxHQUFHO1FBQ3hDdUosUUFBUVUsbUJBQW1CLENBQUNDLFVBQVUsR0FBRztRQUN6Q1gsUUFBUUssVUFBVSxHQUFHN0wsV0FBV29NLGFBQWEsQ0FBQ0MsU0FBUyxDQUFDbUI7UUFDeEQsTUFBTTlKLE1BQU0sSUFBSTRIO1FBQ2hCNUgsSUFBSTNCLElBQUksR0FBR1QsT0FBT0MsSUFBSSxDQUFDdkIsV0FBV29NLGFBQWEsQ0FBQ0MsU0FBUyxDQUFDYjtRQUMxRDlILElBQUl6QixTQUFTLEdBQUc3QixPQUFPNkwsTUFBTSxDQUFDLENBQUMsR0FBR2hLO1FBQ2xDeUIsSUFBSXpCLFNBQVMsQ0FBQytLLGNBQWMsR0FBRyxJQUFJeEksV0FBV2dKLE9BQU9SLGNBQWM7UUFDbkV0SixJQUFJekIsU0FBUyxDQUFDbUwsYUFBYSxHQUFHSSxPQUFPUSxPQUFPLENBQUNmLFVBQVUsSUFBSTtRQUMzRHZKLElBQUl2QixXQUFXLEdBQUdBO1FBQ2xCdUIsSUFBSXJCLE1BQU0sR0FBRzRCO1FBQ2IsT0FBT1A7SUFDWDtJQUNBLE9BQU9nSyxnQkFBZ0JGLE1BQU0sRUFBRXZMLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQzlELE1BQU11SCxVQUFVLElBQUl4SyxnQkFBZ0IySyxJQUFJLENBQUNZLGFBQWE7UUFDdERmLFFBQVFpQixrQkFBa0IsQ0FBQ3hLLFNBQVMsR0FBRztRQUN2Q3VKLFFBQVFpQixrQkFBa0IsQ0FBQ04sVUFBVSxHQUFHO1FBQ3hDWCxRQUFRZ0IsU0FBUyxHQUFHeE0sV0FBV29NLGFBQWEsQ0FBQ0MsU0FBUyxDQUFDbUI7UUFDdkQsTUFBTTlKLE1BQU0sSUFBSTRJO1FBQ2hCNUksSUFBSTNCLElBQUksR0FBR1QsT0FBT0MsSUFBSSxDQUFDdkIsV0FBV29NLGFBQWEsQ0FBQ0MsU0FBUyxDQUFDYjtRQUMxRDlILElBQUl6QixTQUFTLEdBQUc3QixPQUFPNkwsTUFBTSxDQUFDLENBQUMsR0FBR2hLO1FBQ2xDeUIsSUFBSXpCLFNBQVMsQ0FBQytLLGNBQWMsR0FBRyxJQUFJeEksV0FBV2dKLE9BQU9SLGNBQWM7UUFDbkV0SixJQUFJekIsU0FBUyxDQUFDbUwsYUFBYSxHQUFHSSxPQUFPUSxPQUFPLENBQUNmLFVBQVUsSUFBSTtRQUMzRHZKLElBQUl2QixXQUFXLEdBQUdBO1FBQ2xCdUIsSUFBSXJCLE1BQU0sR0FBRzRCO1FBQ2IsT0FBT1A7SUFDWDtJQUNBLE9BQU91SyxtQkFBbUIxTCxHQUFHLEVBQUU7UUFDM0IsT0FBUUEsSUFBSThJLElBQUksQ0FBQ25KLElBQUksQ0FBQ2lCLFdBQVc7WUFDN0IsS0FBSztnQkFDRCxPQUFPO1lBQ1gsS0FBSztnQkFDRCxPQUFPO1lBQ1gsS0FBSztnQkFDRCxPQUFPO1lBQ1gsS0FBSztnQkFDRCxPQUFPO1lBQ1gsS0FBSztnQkFDRCxPQUFPO1lBQ1gsS0FBSztnQkFDRCxPQUFPO1lBQ1gsS0FBSztnQkFDRCxPQUFPO1lBQ1g7Z0JBQ0ksTUFBTSxJQUFJbkMsZ0JBQWdCNEMsY0FBYyxDQUFDO1FBQ2pEO0lBQ0o7SUFDQSxPQUFPK0osUUFBUTFMLFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUNqQyxNQUFNbU0sWUFBWSxJQUFJLENBQUNELGtCQUFrQixDQUFDdkssSUFBSXpCLFNBQVM7UUFDdkQsTUFBTWtNLFNBQVN4TyxPQUFPeU8sVUFBVSxDQUFDRjtRQUNqQ0MsT0FBT3JJLE1BQU0sQ0FBQ3hFLE9BQU9DLElBQUksQ0FBQ1E7UUFDMUIsSUFBSSxDQUFDMkIsSUFBSTJLLEdBQUcsRUFBRTtZQUNWM0ssSUFBSTJLLEdBQUcsR0FBRyxDQUFDLDZCQUE2QixFQUFFM0ssSUFBSTNCLElBQUksQ0FBQ3VNLFFBQVEsQ0FBQyxVQUFVLDJCQUEyQixDQUFDO1FBQ3RHO1FBQ0EsTUFBTUMsVUFBVTtZQUNaN0ssS0FBS0EsSUFBSTJLLEdBQUc7UUFDaEI7UUFDQSxJQUFJcE0sVUFBVUMsSUFBSSxDQUFDaUIsV0FBVyxPQUFPLFdBQVc7WUFDNUNvTCxRQUFRQyxPQUFPLEdBQUc3TyxPQUFPOE8sU0FBUyxDQUFDQyxxQkFBcUI7WUFDeERILFFBQVFJLFVBQVUsR0FBRzFNLFVBQVUwTSxVQUFVO1FBQzdDO1FBQ0EsTUFBTTVFLFlBQVlvRSxPQUFPbEUsSUFBSSxDQUFDc0U7UUFDOUIsT0FBTyxJQUFJL0osV0FBV3VGLFdBQVd0RixNQUFNO0lBQzNDO0lBQ0EsT0FBT29KLFVBQVU1TCxTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUVnSSxTQUFTLEVBQUU7UUFDOUMsTUFBTW1FLFlBQVksSUFBSSxDQUFDRCxrQkFBa0IsQ0FBQ3ZLLElBQUl6QixTQUFTO1FBQ3ZELE1BQU1rTSxTQUFTeE8sT0FBT2lQLFlBQVksQ0FBQ1Y7UUFDbkNDLE9BQU9ySSxNQUFNLENBQUN4RSxPQUFPQyxJQUFJLENBQUNRO1FBQzFCLElBQUksQ0FBQzJCLElBQUkySyxHQUFHLEVBQUU7WUFDVjNLLElBQUkySyxHQUFHLEdBQUcsQ0FBQyw0QkFBNEIsRUFBRTNLLElBQUkzQixJQUFJLENBQUN1TSxRQUFRLENBQUMsVUFBVSwwQkFBMEIsQ0FBQztRQUNwRztRQUNBLE1BQU1DLFVBQVU7WUFDWjdLLEtBQUtBLElBQUkySyxHQUFHO1FBQ2hCO1FBQ0EsSUFBSXBNLFVBQVVDLElBQUksQ0FBQ2lCLFdBQVcsT0FBTyxXQUFXO1lBQzVDb0wsUUFBUUMsT0FBTyxHQUFHN08sT0FBTzhPLFNBQVMsQ0FBQ0MscUJBQXFCO1lBQ3hESCxRQUFRSSxVQUFVLEdBQUcxTSxVQUFVME0sVUFBVTtRQUM3QztRQUNBLE1BQU1FLEtBQUtWLE9BQU9QLE1BQU0sQ0FBQ1csU0FBU3hFO1FBQ2xDLE9BQU84RTtJQUNYO0lBQ0EsT0FBT2YsWUFBWTdMLFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUNyQyxNQUFNd00sVUFBVTtZQUNaN0ssS0FBSyxDQUFDLDRCQUE0QixFQUFFQSxJQUFJM0IsSUFBSSxDQUFDdU0sUUFBUSxDQUFDLFVBQVUsMEJBQTBCLENBQUM7WUFDM0ZFLFNBQVM3TyxPQUFPOE8sU0FBUyxDQUFDSyxzQkFBc0I7UUFDcEQ7UUFDQSxJQUFJN00sVUFBVThNLEtBQUs7UUFDbkIsT0FBTyxJQUFJdkssV0FBVzdFLE9BQU9xUCxhQUFhLENBQUNULFNBQVN4TSxPQUFPMEMsTUFBTTtJQUNyRTtJQUNBLE9BQU9zSixZQUFZOUwsU0FBUyxFQUFFeUIsR0FBRyxFQUFFM0IsSUFBSSxFQUFFO1FBQ3JDLE1BQU13TSxVQUFVO1lBQ1o3SyxLQUFLLENBQUMsNkJBQTZCLEVBQUVBLElBQUkzQixJQUFJLENBQUN1TSxRQUFRLENBQUMsVUFBVSwyQkFBMkIsQ0FBQztZQUM3RkUsU0FBUzdPLE9BQU84TyxTQUFTLENBQUNLLHNCQUFzQjtRQUNwRDtRQUNBLElBQUk3TSxVQUFVOE0sS0FBSztRQUNuQixPQUFPLElBQUl2SyxXQUFXN0UsT0FBT3NQLGNBQWMsQ0FBQ1YsU0FBU3hNLE9BQU8wQyxNQUFNO0lBQ3RFO0FBQ0o7QUFDQWlJLFVBQVVLLGVBQWUsR0FBRztJQUFDO0lBQVU7SUFBVztDQUFVO0FBQzVETCxVQUFVRyxnQkFBZ0IsR0FBRztJQUFDO0lBQVE7SUFBVztDQUFZO0FBRTdELE1BQU1xQyx1QkFBdUJsTyxnQkFBZ0JrTyxjQUFjO0lBQ3ZEck4sYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUNxTixjQUFjLEdBQUc7WUFDbEI7WUFBUztZQUFXO1lBQVc7WUFDL0I7WUFBWTtZQUNaO1lBQVk7WUFBWTtTQUMzQjtJQUNMO0lBQ0EsTUFBTXBJLGNBQWM5RSxTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUNuRCxNQUFNM0QsT0FBTyxNQUFNb00sVUFBVTFJLFdBQVcsQ0FBQztZQUNyQyxHQUFHL0IsU0FBUztZQUNaQyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtRQUNuQixHQUFHQyxhQUFhOEI7UUFDaEIsT0FBTztZQUNINEgsWUFBWWhJLGFBQWF2RCxLQUFLdUwsVUFBVTtZQUN4Q1csV0FBVzNJLGFBQWF2RCxLQUFLa00sU0FBUztRQUMxQztJQUNKO0lBQ0EsTUFBTTNDLE9BQU81SCxTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDL0IsT0FBTzJLLFVBQVV6QyxJQUFJLENBQUNoSSxXQUFXd0IsYUFBYUMsTUFBTSxJQUFJYyxXQUFXekM7SUFDdkU7SUFDQSxNQUFNK0gsU0FBUzdILFNBQVMsRUFBRXlCLEdBQUcsRUFBRXFHLFNBQVMsRUFBRWhJLElBQUksRUFBRTtRQUM1QyxPQUFPMkssVUFBVWtCLE1BQU0sQ0FBQzNMLFdBQVd3QixhQUFhQyxNQUFNLElBQUljLFdBQVd1RixZQUFZLElBQUl2RixXQUFXekM7SUFDcEc7SUFDQSxNQUFNbUYsWUFBWTlDLE1BQU0sRUFBRVYsR0FBRyxFQUFFO1FBQzNCLE9BQU9nSixVQUFVdkksU0FBUyxDQUFDQyxRQUFRWCxhQUFhQztJQUNwRDtJQUNBLE1BQU15RCxZQUFZL0MsTUFBTSxFQUFFTyxPQUFPLEVBQUUxQyxTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUNsRSxNQUFNUCxNQUFNLE1BQU1nSixVQUFVaEksU0FBUyxDQUFDTixRQUFRTyxTQUFTO1lBQUUsR0FBRzFDLFNBQVM7WUFBRUMsTUFBTSxJQUFJLENBQUNBLElBQUk7UUFBQyxHQUFHQyxhQUFhOEI7UUFDdkcsT0FBT0osYUFBYUg7SUFDeEI7SUFDQTBELGVBQWUxRCxHQUFHLEVBQUUyRCxRQUFRLEVBQUU7UUFDMUIsS0FBSyxDQUFDRCxlQUFlMUQsS0FBSzJEO1FBQzFCLE1BQU0rSCxjQUFjM0wsYUFBYUM7UUFDakMsSUFBSSxDQUFFMEwsQ0FBQUEsdUJBQXVCOUQsaUJBQWlCOEQsdUJBQXVCOUMsWUFBVyxHQUFJO1lBQ2hGLE1BQU0sSUFBSWhGLFVBQVU7UUFDeEI7SUFDSjtBQUNKO0FBRUEsTUFBTStILHVCQUF1QnJPLGdCQUFnQnFPLGNBQWM7SUFDdkR4TixhQUFjO1FBQ1YsS0FBSyxJQUFJQztRQUNULElBQUksQ0FBQ3FOLGNBQWMsR0FBRztZQUNsQjtZQUFTO1lBQVc7WUFBVztZQUMvQjtZQUFZO1lBQ1o7WUFBWTtZQUFZO1NBQzNCO0lBQ0w7SUFDQSxNQUFNcEksY0FBYzlFLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ25ELE1BQU0zRCxPQUFPLE1BQU1vTSxVQUFVMUksV0FBVyxDQUFDO1lBQ3JDLEdBQUcvQixTQUFTO1lBQ1pDLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1FBQ25CLEdBQUdDLGFBQWE4QjtRQUNoQixPQUFPO1lBQ0g0SCxZQUFZaEksYUFBYXZELEtBQUt1TCxVQUFVO1lBQ3hDVyxXQUFXM0ksYUFBYXZELEtBQUtrTSxTQUFTO1FBQzFDO0lBQ0o7SUFDQSxNQUFNM0MsT0FBTzVILFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUMvQixPQUFPMkssVUFBVXpDLElBQUksQ0FBQ2hJLFdBQVd3QixhQUFhQyxNQUFNLElBQUljLFdBQVd6QztJQUN2RTtJQUNBLE1BQU0rSCxTQUFTN0gsU0FBUyxFQUFFeUIsR0FBRyxFQUFFcUcsU0FBUyxFQUFFaEksSUFBSSxFQUFFO1FBQzVDLE9BQU8ySyxVQUFVa0IsTUFBTSxDQUFDM0wsV0FBV3dCLGFBQWFDLE1BQU0sSUFBSWMsV0FBV3VGLFlBQVksSUFBSXZGLFdBQVd6QztJQUNwRztJQUNBLE1BQU1tRixZQUFZOUMsTUFBTSxFQUFFVixHQUFHLEVBQUU7UUFDM0IsT0FBT2dKLFVBQVV2SSxTQUFTLENBQUNDLFFBQVFYLGFBQWFDO0lBQ3BEO0lBQ0EsTUFBTXlELFlBQVkvQyxNQUFNLEVBQUVPLE9BQU8sRUFBRTFDLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ2xFLE1BQU1QLE1BQU0sTUFBTWdKLFVBQVVoSSxTQUFTLENBQUNOLFFBQVFPLFNBQVM7WUFBRSxHQUFHMUMsU0FBUztZQUFFQyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtRQUFDLEdBQUdDLGFBQWE4QjtRQUN2RyxPQUFPSixhQUFhSDtJQUN4QjtJQUNBMEQsZUFBZTFELEdBQUcsRUFBRTJELFFBQVEsRUFBRTtRQUMxQixLQUFLLENBQUNELGVBQWUxRCxLQUFLMkQ7UUFDMUIsTUFBTStILGNBQWMzTCxhQUFhQztRQUNqQyxJQUFJLENBQUUwTCxDQUFBQSx1QkFBdUI5RCxpQkFBaUI4RCx1QkFBdUI5QyxZQUFXLEdBQUk7WUFDaEYsTUFBTSxJQUFJaEYsVUFBVTtRQUN4QjtJQUNKO0FBQ0o7QUFFQSxNQUFNZ0k7SUFDRixPQUFPQyxLQUFLdE4sU0FBUyxFQUFFO1FBQ25CLE9BQVFBLFVBQVVDLElBQUksQ0FBQ2lCLFdBQVc7WUFDOUIsS0FBSztnQkFDRCxPQUFPO1lBQ1gsS0FBSztZQUNMLEtBQUs7Z0JBQ0QsT0FBTztZQUNYLEtBQUs7WUFDTCxLQUFLO2dCQUNELE9BQU87WUFDWCxLQUFLO1lBQ0wsS0FBSztnQkFDRCxPQUFPO1lBQ1g7Z0JBQ0ksTUFBTSxJQUFJa0IsTUFBTTtRQUN4QjtJQUNKO0lBQ0EsT0FBT21MLGlCQUFpQnZOLFNBQVMsRUFBRTtRQUMvQixPQUFRQSxVQUFVQyxJQUFJLENBQUNpQixXQUFXO1lBQzlCLEtBQUs7Z0JBQ0QsT0FBTztZQUNYLEtBQUs7Z0JBQ0QsT0FBTztZQUNYLEtBQUs7Z0JBQ0QsT0FBTztZQUNYLEtBQUs7Z0JBQ0QsT0FBTztZQUNYLEtBQUs7Z0JBQ0QsT0FBTztZQUNYLEtBQUs7Z0JBQ0QsT0FBTztZQUNYLEtBQUs7Z0JBQ0QsT0FBTztZQUNYO2dCQUNJLE1BQU0sSUFBSWtCLE1BQU07UUFDeEI7SUFDSjtJQUNBLE9BQU9vTCxPQUFPeE4sU0FBUyxFQUFFRixJQUFJLEVBQUU7UUFDM0IsTUFBTTJOLFVBQVUsSUFBSSxDQUFDRixnQkFBZ0IsQ0FBQ3ZOO1FBQ3RDLE1BQU1vSixPQUFPMUwsT0FBT2dRLFVBQVUsQ0FBQ0QsU0FDMUI1SixNQUFNLENBQUN4RSxPQUFPQyxJQUFJLENBQUNRLE9BQU8wTixNQUFNO1FBQ3JDLE9BQU8sSUFBSWpMLFdBQVc2RyxNQUFNNUcsTUFBTTtJQUN0QztBQUNKO0FBRUEsTUFBTW1MLHdCQUF3QjVPLGdCQUFnQjRPLGVBQWU7SUFDekQsTUFBTTdJLGNBQWM5RSxTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUNuRCxNQUFNM0QsT0FBTyxNQUFNb00sVUFBVTFJLFdBQVcsQ0FBQztZQUNyQyxHQUFHL0IsU0FBUztZQUNaQyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtRQUNuQixHQUFHQyxhQUFhOEI7UUFDaEIsT0FBTztZQUNINEgsWUFBWWhJLGFBQWF2RCxLQUFLdUwsVUFBVTtZQUN4Q1csV0FBVzNJLGFBQWF2RCxLQUFLa00sU0FBUztRQUMxQztJQUNKO0lBQ0EsTUFBTXhGLFVBQVUvRSxTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDbEMsTUFBTXFOLGNBQWMzTCxhQUFhQztRQUNqQyxNQUFNbU0sV0FBVyxJQUFJckwsV0FBV3pDO1FBQ2hDLE1BQU0rTixVQUFVN0gsS0FBS3FCLElBQUksQ0FBQzhGLFlBQVluTixTQUFTLENBQUNtTCxhQUFhLElBQUk7UUFDakUsTUFBTTJDLFdBQVdULFVBQVVDLElBQUksQ0FBQ0gsWUFBWW5OLFNBQVMsQ0FBQ29KLElBQUksS0FBSztRQUMvRCxNQUFNMkUsYUFBYUgsU0FBUzVDLFVBQVU7UUFDdEMsTUFBTWdELFdBQVdILFVBQVVFLGFBQWEsSUFBSUQsV0FBVztRQUN2RCxJQUFJQyxhQUFhRixVQUFVLElBQUlDLFdBQVcsR0FBRztZQUN6QyxNQUFNLElBQUkxTCxNQUFNO1FBQ3BCO1FBQ0EsTUFBTWdFLFVBQVUsSUFBSTdELFdBQVdzTDtRQUMvQixNQUFNSSxPQUFPN0gsUUFBUThILFFBQVEsQ0FBQyxHQUFHSixXQUFXO1FBQzVDLE1BQU1LLFlBQVkvSCxRQUFROEgsUUFBUSxDQUFDSixXQUFXO1FBQzlDSyxVQUFVdE0sR0FBRyxDQUFDK0wsVUFBVUUsV0FBV0UsV0FBVztRQUM5QyxNQUFNSSxZQUFZMVEsT0FBT2dRLFVBQVUsQ0FBQ1AsWUFBWW5OLFNBQVMsQ0FBQ29KLElBQUksQ0FBQ25KLElBQUksQ0FBQ29PLE9BQU8sQ0FBQyxLQUFLLEtBQzVFeEssTUFBTSxDQUFDOUUsZ0JBQWdCdVAscUJBQXFCLENBQUNDLFlBQVksQ0FBQ3ZPLFVBQVU4TSxLQUFLLElBQUksSUFBSXZLLFdBQVcsS0FDNUZpTCxNQUFNO1FBQ1hXLFVBQVV0TSxHQUFHLENBQUN1TSxXQUFXO1FBQ3pCRCxTQUFTLENBQUNMLFdBQVdFLFNBQVMsR0FBRztRQUNqQ3RRLE9BQU84USxjQUFjLENBQUNQO1FBQ3RCLE1BQU1RLGdCQUFnQixJQUFJLENBQUNDLElBQUksQ0FBQ3ZCLFlBQVluTixTQUFTLENBQUNvSixJQUFJLEVBQUU2RSxNQUFNRSxVQUFVaE4sTUFBTTtRQUNsRixJQUFLLElBQUl3TixJQUFJLEdBQUdBLElBQUlSLFVBQVVoTixNQUFNLEVBQUV3TixJQUFLO1lBQ3ZDUixTQUFTLENBQUNRLEVBQUUsSUFBSUYsYUFBYSxDQUFDRSxFQUFFO1FBQ3BDO1FBQ0EsTUFBTUMsV0FBVyxJQUFJLENBQUNGLElBQUksQ0FBQ3ZCLFlBQVluTixTQUFTLENBQUNvSixJQUFJLEVBQUUrRSxXQUFXRixLQUFLOU0sTUFBTTtRQUM3RSxJQUFLLElBQUl3TixJQUFJLEdBQUdBLElBQUlWLEtBQUs5TSxNQUFNLEVBQUV3TixJQUFLO1lBQ2xDVixJQUFJLENBQUNVLEVBQUUsSUFBSUMsUUFBUSxDQUFDRCxFQUFFO1FBQzFCO1FBQ0EsSUFBSSxDQUFDeEIsWUFBWWYsR0FBRyxFQUFFO1lBQ2xCZSxZQUFZZixHQUFHLEdBQUcsQ0FBQyw0QkFBNEIsRUFBRWUsWUFBWXJOLElBQUksQ0FBQ3VNLFFBQVEsQ0FBQyxVQUFVLDBCQUEwQixDQUFDO1FBQ3BIO1FBQ0EsTUFBTXdDLFFBQVFuUixPQUFPcVAsYUFBYSxDQUFDO1lBQy9CdEwsS0FBSzBMLFlBQVlmLEdBQUc7WUFDcEJHLFNBQVM3TyxPQUFPOE8sU0FBUyxDQUFDc0MsY0FBYztRQUM1QyxHQUFHelAsT0FBT0MsSUFBSSxDQUFDOEc7UUFDZixPQUFPLElBQUk3RCxXQUFXc00sT0FBT3JNLE1BQU07SUFDdkM7SUFDQSxNQUFNd0MsVUFBVWhGLFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUNsQyxNQUFNcU4sY0FBYzNMLGFBQWFDO1FBQ2pDLE1BQU1vTSxVQUFVN0gsS0FBS3FCLElBQUksQ0FBQzhGLFlBQVluTixTQUFTLENBQUNtTCxhQUFhLElBQUk7UUFDakUsTUFBTTJDLFdBQVdULFVBQVVDLElBQUksQ0FBQ0gsWUFBWW5OLFNBQVMsQ0FBQ29KLElBQUksS0FBSztRQUMvRCxNQUFNMkUsYUFBYWpPLEtBQUtrTCxVQUFVO1FBQ2xDLElBQUkrQyxlQUFlRixTQUFTO1lBQ3hCLE1BQU0sSUFBSXpMLE1BQU07UUFDcEI7UUFDQSxJQUFJLENBQUMrSyxZQUFZZixHQUFHLEVBQUU7WUFDbEJlLFlBQVlmLEdBQUcsR0FBRyxDQUFDLDZCQUE2QixFQUFFZSxZQUFZck4sSUFBSSxDQUFDdU0sUUFBUSxDQUFDLFVBQVUsMkJBQTJCLENBQUM7UUFDdEg7UUFDQSxJQUFJd0MsUUFBUW5SLE9BQU9zUCxjQUFjLENBQUM7WUFDOUJ2TCxLQUFLMEwsWUFBWWYsR0FBRztZQUNwQkcsU0FBUzdPLE9BQU84TyxTQUFTLENBQUNzQyxjQUFjO1FBQzVDLEdBQUd6UCxPQUFPQyxJQUFJLENBQUNRO1FBQ2YsTUFBTWlQLElBQUlGLEtBQUssQ0FBQyxFQUFFO1FBQ2xCLE1BQU1aLE9BQU9ZLE1BQU1YLFFBQVEsQ0FBQyxHQUFHSixXQUFXO1FBQzFDLE1BQU1LLFlBQVlVLE1BQU1YLFFBQVEsQ0FBQ0osV0FBVztRQUM1QyxJQUFJaUIsTUFBTSxHQUFHO1lBQ1QsTUFBTSxJQUFJM00sTUFBTTtRQUNwQjtRQUNBLE1BQU13TSxXQUFXLElBQUksQ0FBQ0YsSUFBSSxDQUFDdkIsWUFBWW5OLFNBQVMsQ0FBQ29KLElBQUksRUFBRStFLFdBQVdGLEtBQUs5TSxNQUFNO1FBQzdFLElBQUssSUFBSXdOLElBQUksR0FBR0EsSUFBSVYsS0FBSzlNLE1BQU0sRUFBRXdOLElBQUs7WUFDbENWLElBQUksQ0FBQ1UsRUFBRSxJQUFJQyxRQUFRLENBQUNELEVBQUU7UUFDMUI7UUFDQSxNQUFNRixnQkFBZ0IsSUFBSSxDQUFDQyxJQUFJLENBQUN2QixZQUFZbk4sU0FBUyxDQUFDb0osSUFBSSxFQUFFNkUsTUFBTUUsVUFBVWhOLE1BQU07UUFDbEYsSUFBSyxJQUFJd04sSUFBSSxHQUFHQSxJQUFJUixVQUFVaE4sTUFBTSxFQUFFd04sSUFBSztZQUN2Q1IsU0FBUyxDQUFDUSxFQUFFLElBQUlGLGFBQWEsQ0FBQ0UsRUFBRTtRQUNwQztRQUNBLE1BQU1QLFlBQVkxUSxPQUFPZ1EsVUFBVSxDQUFDUCxZQUFZbk4sU0FBUyxDQUFDb0osSUFBSSxDQUFDbkosSUFBSSxDQUFDb08sT0FBTyxDQUFDLEtBQUssS0FDNUV4SyxNQUFNLENBQUM5RSxnQkFBZ0J1UCxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDdk8sVUFBVThNLEtBQUssSUFBSSxJQUFJdkssV0FBVyxLQUM1RmlMLE1BQU07UUFDWCxJQUFLLElBQUltQixJQUFJLEdBQUdBLElBQUliLFVBQVVhLElBQUs7WUFDL0IsSUFBSVAsU0FBUyxDQUFDTyxFQUFFLEtBQUtSLFNBQVMsQ0FBQ1EsRUFBRSxFQUFFO2dCQUMvQixNQUFNLElBQUl2TSxNQUFNO1lBQ3BCO1FBQ0o7UUFDQSxJQUFJNE0sUUFBUWxCO1FBQ1osTUFBT2tCLFFBQVFiLFVBQVVoTixNQUFNLEVBQUU2TixRQUFTO1lBQ3RDLE1BQU1DLE1BQU1kLFNBQVMsQ0FBQ2EsTUFBTTtZQUM1QixJQUFJQyxRQUFRLEdBQUc7Z0JBQ1g7WUFDSjtZQUNBLElBQUlBLFFBQVEsR0FBRztnQkFDWCxNQUFNLElBQUk3TSxNQUFNO1lBQ3BCO1FBQ0o7UUFDQSxJQUFJNE0sVUFBVWIsVUFBVWhOLE1BQU0sRUFBRTtZQUM1QixNQUFNLElBQUlpQixNQUFNO1FBQ3BCO1FBQ0F5TSxRQUFRVixVQUFVRCxRQUFRLENBQUNjLFFBQVE7UUFDbkMsT0FBTyxJQUFJek0sV0FBV3NNLE9BQU9yTSxNQUFNO0lBQ3ZDO0lBQ0EsTUFBTXlDLFlBQVk5QyxNQUFNLEVBQUVWLEdBQUcsRUFBRTtRQUMzQixPQUFPZ0osVUFBVXZJLFNBQVMsQ0FBQ0MsUUFBUVgsYUFBYUM7SUFDcEQ7SUFDQSxNQUFNeUQsWUFBWS9DLE1BQU0sRUFBRU8sT0FBTyxFQUFFMUMsU0FBUyxFQUFFRSxXQUFXLEVBQUU4QixTQUFTLEVBQUU7UUFDbEUsTUFBTVAsTUFBTSxNQUFNZ0osVUFBVWhJLFNBQVMsQ0FBQ04sUUFBUU8sU0FBUztZQUFFLEdBQUcxQyxTQUFTO1lBQUVDLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1FBQUMsR0FBR0MsYUFBYThCO1FBQ3ZHLE9BQU9KLGFBQWFIO0lBQ3hCO0lBQ0EwRCxlQUFlMUQsR0FBRyxFQUFFMkQsUUFBUSxFQUFFO1FBQzFCLEtBQUssQ0FBQ0QsZUFBZTFELEtBQUsyRDtRQUMxQixNQUFNK0gsY0FBYzNMLGFBQWFDO1FBQ2pDLElBQUksQ0FBRTBMLENBQUFBLHVCQUF1QjlELGlCQUFpQjhELHVCQUF1QjlDLFlBQVcsR0FBSTtZQUNoRixNQUFNLElBQUloRixVQUFVO1FBQ3hCO0lBQ0o7SUFDQXFKLEtBQUsxTyxTQUFTLEVBQUVpTyxJQUFJLEVBQUU5TSxTQUFTLENBQUMsRUFBRTtRQUM5QixNQUFNMk0sV0FBV1QsVUFBVUMsSUFBSSxDQUFDdE4sY0FBYztRQUM5QyxNQUFNa1AsT0FBTyxJQUFJM00sV0FBV3BCO1FBQzVCLE1BQU1nRCxVQUFVLElBQUk1QixXQUFXO1FBQy9CLE1BQU00TSxTQUFTbkosS0FBS3FCLElBQUksQ0FBQ2xHLFNBQVMyTTtRQUNsQyxJQUFLLElBQUlhLElBQUksR0FBR0EsSUFBSVEsUUFBUVIsSUFBSztZQUM3QnhLLE9BQU8sQ0FBQyxFQUFFLEdBQUd3SyxNQUFNO1lBQ25CeEssT0FBTyxDQUFDLEVBQUUsR0FBRyxNQUFPLEtBQU07WUFDMUJBLE9BQU8sQ0FBQyxFQUFFLEdBQUcsTUFBTyxJQUFLO1lBQ3pCQSxPQUFPLENBQUMsRUFBRSxHQUFHd0ssSUFBSTtZQUNqQixNQUFNUyxVQUFVRixLQUFLaEIsUUFBUSxDQUFDUyxJQUFJYjtZQUNsQyxJQUFJdUIsUUFBUTNSLE9BQU9nUSxVQUFVLENBQUMxTixVQUFVQyxJQUFJLENBQUNvTyxPQUFPLENBQUMsS0FBSyxLQUNyRHhLLE1BQU0sQ0FBQ29LLE1BQ1BwSyxNQUFNLENBQUNNLFNBQ1BxSixNQUFNO1lBQ1gsSUFBSTZCLE1BQU1sTyxNQUFNLEdBQUdpTyxRQUFRak8sTUFBTSxFQUFFO2dCQUMvQmtPLFFBQVFBLE1BQU1uQixRQUFRLENBQUMsR0FBR2tCLFFBQVFqTyxNQUFNO1lBQzVDO1lBQ0FpTyxRQUFRdk4sR0FBRyxDQUFDd047UUFDaEI7UUFDQSxPQUFPSDtJQUNYO0FBQ0o7QUFFQSxNQUFNSSxzQkFBc0J2USxnQkFBZ0J3USxjQUFjO0lBQ3REM1AsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUNJLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0csTUFBTSxHQUFHO1lBQ1ZtSyxXQUFXO2dCQUFDO2dCQUFXO2FBQVU7WUFDakNYLFlBQVk7Z0JBQUM7Z0JBQVc7YUFBWTtRQUN4QztJQUNKO0lBQ0EsTUFBTTlFLGNBQWM5RSxTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUNuRCxNQUFNM0QsT0FBTyxNQUFNb00sVUFBVTFJLFdBQVcsQ0FBQztZQUNyQyxHQUFHL0IsU0FBUztZQUNaQyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtRQUNuQixHQUFHQyxhQUFhOEI7UUFDaEIsT0FBTztZQUNINEgsWUFBWWhJLGFBQWF2RCxLQUFLdUwsVUFBVTtZQUN4Q1csV0FBVzNJLGFBQWF2RCxLQUFLa00sU0FBUztRQUMxQztJQUNKO0lBQ0FpRix1QkFBdUJ4UCxTQUFTLEVBQUU7UUFDOUIsSUFBSSxDQUFDeVAscUJBQXFCLENBQUN6UCxXQUFXO1FBQ3RDLElBQUksQ0FBRUEsQ0FBQUEsVUFBVStLLGNBQWMsSUFBSS9LLFVBQVUrSyxjQUFjLFlBQVl4SSxVQUFTLEdBQUk7WUFDL0UsTUFBTSxJQUFJOEMsVUFBVTtRQUN4QjtRQUNBLE1BQU0wRixpQkFBaUJqTixVQUFVeUIsT0FBTyxDQUFDbVEsUUFBUSxDQUFDMVAsVUFBVStLLGNBQWM7UUFDMUUsSUFBSSxDQUFFQSxDQUFBQSxtQkFBbUIsVUFBVUEsbUJBQW1CLE1BQUssR0FBSTtZQUMzRCxNQUFNLElBQUkxRixVQUFVO1FBQ3hCO1FBQ0EsSUFBSSxDQUFDb0sscUJBQXFCLENBQUN6UCxXQUFXO1FBQ3RDLE9BQVFBLFVBQVVtTCxhQUFhO1lBQzNCLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFDRDtZQUNKO2dCQUNJLE1BQU0sSUFBSTlGLFVBQVU7UUFDNUI7SUFDSjtJQUNBLE1BQU1OLFVBQVUvRSxTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDbEMsTUFBTXdNLFVBQVUsSUFBSSxDQUFDcUQsZUFBZSxDQUFDbE87UUFDckMsTUFBTW1DLE1BQU01RSxrQkFBa0IrTixhQUFhLENBQUNULFNBQVMsSUFBSS9KLFdBQVd6QztRQUNwRSxPQUFPLElBQUl5QyxXQUFXcUIsS0FBS3BCLE1BQU07SUFDckM7SUFDQSxNQUFNd0MsVUFBVWhGLFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUNsQyxNQUFNd00sVUFBVSxJQUFJLENBQUNxRCxlQUFlLENBQUNsTztRQUNyQyxNQUFNeUMsTUFBTWxGLGtCQUFrQmdPLGNBQWMsQ0FBQ1YsU0FBUyxJQUFJL0osV0FBV3pDO1FBQ3JFLE9BQU8sSUFBSXlDLFdBQVcyQixLQUFLMUIsTUFBTTtJQUNyQztJQUNBLE1BQU15QyxZQUFZOUMsTUFBTSxFQUFFVixHQUFHLEVBQUU7UUFDM0IsT0FBT2dKLFVBQVV2SSxTQUFTLENBQUNDLFFBQVFYLGFBQWFDO0lBQ3BEO0lBQ0EsTUFBTXlELFlBQVkvQyxNQUFNLEVBQUVPLE9BQU8sRUFBRTFDLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ2xFLE1BQU1QLE1BQU0sTUFBTWdKLFVBQVVoSSxTQUFTLENBQUNOLFFBQVFPLFNBQVM7WUFBRSxHQUFHMUMsU0FBUztZQUFFQyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtRQUFDLEdBQUdDLGFBQWE4QjtRQUN2RyxPQUFPSixhQUFhSDtJQUN4QjtJQUNBMEQsZUFBZTFELEdBQUcsRUFBRTJELFFBQVEsRUFBRTtRQUMxQixLQUFLLENBQUNELGVBQWUxRCxLQUFLMkQ7UUFDMUIsTUFBTStILGNBQWMzTCxhQUFhQztRQUNqQyxJQUFJLENBQUUwTCxDQUFBQSx1QkFBdUI5RCxpQkFBaUI4RCx1QkFBdUI5QyxZQUFXLEdBQUk7WUFDaEYsTUFBTSxJQUFJaEYsVUFBVTtRQUN4QjtJQUNKO0lBQ0FzSyxnQkFBZ0JsTyxHQUFHLEVBQUU7UUFDakIsTUFBTXRCLE9BQU9zQixJQUFJdEIsSUFBSSxDQUFDZSxXQUFXO1FBQ2pDLE9BQU87WUFDSE8sS0FBSyxDQUFDLFdBQVcsRUFBRXRCLEtBQUssV0FBVyxFQUFFcUIsYUFBYUMsS0FBSzNCLElBQUksQ0FBQ3VNLFFBQVEsQ0FBQyxVQUFVLFdBQVcsRUFBRWxNLEtBQUssU0FBUyxDQUFDO1lBQzNHb00sU0FBU3ZOLGtCQUFrQndOLFNBQVMsQ0FBQ29ELGlCQUFpQjtRQUMxRDtJQUNKO0FBQ0o7QUFFQSxNQUFNQyxZQUFZO0lBQ2QsdUJBQXVCO0lBQ3ZCLFNBQVM7SUFDVCxnQkFBZ0I7SUFDaEIsU0FBUztJQUNULGdCQUFnQjtJQUNoQixTQUFTO0lBQ1QsZ0JBQWdCO0lBQ2hCLFNBQVM7SUFDVCxtQkFBbUI7SUFDbkIsd0JBQXdCO0lBQ3hCLG1CQUFtQjtJQUNuQix3QkFBd0I7SUFDeEIsbUJBQW1CO0lBQ25CLHdCQUF3QjtJQUN4QixtQkFBbUI7SUFDbkIsd0JBQXdCO0lBQ3hCLG1CQUFtQjtJQUNuQix3QkFBd0I7SUFDeEIsbUJBQW1CO0lBQ25CLHdCQUF3QjtJQUN4QixtQkFBbUI7SUFDbkIsd0JBQXdCO0lBQ3hCLG1CQUFtQjtJQUNuQix3QkFBd0I7SUFDeEIsbUJBQW1CO0lBQ25CLHdCQUF3QjtJQUN4QixtQkFBbUI7SUFDbkIseUJBQXlCO0lBQ3pCLG1CQUFtQjtJQUNuQix5QkFBeUI7SUFDekIsbUJBQW1CO0lBQ25CLHlCQUF5QjtJQUN6QixtQkFBbUI7SUFDbkIseUJBQXlCO0lBQ3pCLG1CQUFtQjtJQUNuQix5QkFBeUI7QUFDN0I7QUFDQSxTQUFTQyxxQkFBcUJDLFVBQVU7SUFDcEMsTUFBTUMsTUFBTUgsU0FBUyxDQUFDRSxXQUFXO0lBQ2pDLElBQUksQ0FBQ0MsS0FBSztRQUNOLE1BQU0sSUFBSWpSLGdCQUFnQjRDLGNBQWMsQ0FBQyxDQUFDLHNDQUFzQyxFQUFFb08sV0FBVyxRQUFRLENBQUM7SUFDMUc7SUFDQSxPQUFPQztBQUNYO0FBRUEsTUFBTUMscUJBQXFCalA7SUFDdkJwQixhQUFjO1FBQ1YsS0FBSyxJQUFJQztRQUNULElBQUksQ0FBQ00sSUFBSSxHQUFHO0lBQ2hCO0lBQ0FtSixTQUFTO1FBQ0wsTUFBTUMsVUFBVXhMLFdBQVd5TCxTQUFTLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUMzSixJQUFJLEVBQUVmLGdCQUFnQjJLLElBQUksQ0FBQ0MsY0FBYztRQUN6RixPQUFPNUwsV0FBV3lMLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDRixRQUFRSyxVQUFVLEVBQUU3SyxnQkFBZ0IySyxJQUFJLENBQUN1RyxZQUFZO0lBQzNGO0lBQ0F4USxTQUFTO1FBQ0wsTUFBTWdDLE1BQU0sSUFBSSxDQUFDNkgsTUFBTTtRQUN2QixNQUFNTyxPQUFPO1lBQ1R4SixLQUFLO1lBQ0w2UCxLQUFLLElBQUksQ0FBQ2xRLFNBQVMsQ0FBQytQLFVBQVU7WUFDOUJqRyxTQUFTLElBQUksQ0FBQzFKLE1BQU07WUFDcEIySixLQUFLLElBQUksQ0FBQzdKLFdBQVc7UUFDekI7UUFDQSxPQUFPL0IsT0FBTzZMLE1BQU0sQ0FBQ0gsTUFBTWhNLFdBQVd5RSxjQUFjLENBQUM3QyxNQUFNLENBQUNnQztJQUNoRTtJQUNBdEMsU0FBUzBLLElBQUksRUFBRTtRQUNYLElBQUksQ0FBQ0EsS0FBS3FHLEdBQUcsRUFBRTtZQUNYLE1BQU0sSUFBSW5SLGdCQUFnQjRDLGNBQWMsQ0FBQyxDQUFDLDJEQUEyRCxDQUFDO1FBQzFHO1FBQ0EsTUFBTTRILFVBQVUsSUFBSXhLLGdCQUFnQjJLLElBQUksQ0FBQ0MsY0FBYztRQUN2REosUUFBUVUsbUJBQW1CLENBQUNqSyxTQUFTLEdBQUc7UUFDeEN1SixRQUFRVSxtQkFBbUIsQ0FBQ0MsVUFBVSxHQUFHbk0sV0FBV29NLGFBQWEsQ0FBQ0MsU0FBUyxDQUFDLElBQUlyTCxnQkFBZ0IySyxJQUFJLENBQUN5RyxnQkFBZ0IsQ0FBQ0wscUJBQXFCakcsS0FBS3FHLEdBQUc7UUFDbkosTUFBTXpPLE1BQU01RCxXQUFXOEUsVUFBVSxDQUFDeEQsUUFBUSxDQUFDMEssTUFBTTtZQUFFakgsY0FBYzdELGdCQUFnQjJLLElBQUksQ0FBQ3VHLFlBQVk7UUFBQztRQUNuRzFHLFFBQVFLLFVBQVUsR0FBRzdMLFdBQVdvTSxhQUFhLENBQUNDLFNBQVMsQ0FBQzNJO1FBQ3hELElBQUksQ0FBQzNCLElBQUksR0FBR1QsT0FBT0MsSUFBSSxDQUFDdkIsV0FBV29NLGFBQWEsQ0FBQ0MsU0FBUyxDQUFDYjtRQUMzRCxPQUFPLElBQUk7SUFDZjtBQUNKO0FBRUEsTUFBTTZHLG9CQUFvQnBQO0lBQ3RCcEIsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUNNLElBQUksR0FBRztJQUNoQjtJQUNBbUosU0FBUztRQUNMLE1BQU1DLFVBQVV4TCxXQUFXeUwsU0FBUyxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDM0osSUFBSSxFQUFFZixnQkFBZ0IySyxJQUFJLENBQUNZLGFBQWE7UUFDeEYsT0FBTyxJQUFJdkwsZ0JBQWdCMkssSUFBSSxDQUFDMEcsV0FBVyxDQUFDN0csUUFBUWdCLFNBQVM7SUFDakU7SUFDQTlLLFNBQVM7UUFDTCxNQUFNZ0MsTUFBTSxJQUFJLENBQUM2SCxNQUFNO1FBQ3ZCLE1BQU1PLE9BQU87WUFDVHhKLEtBQUs7WUFDTDZQLEtBQUssSUFBSSxDQUFDbFEsU0FBUyxDQUFDK1AsVUFBVTtZQUM5QmpHLFNBQVMsSUFBSSxDQUFDMUosTUFBTTtZQUNwQjJKLEtBQUssSUFBSSxDQUFDN0osV0FBVztRQUN6QjtRQUNBLE9BQU8vQixPQUFPNkwsTUFBTSxDQUFDSCxNQUFNaE0sV0FBV3lFLGNBQWMsQ0FBQzdDLE1BQU0sQ0FBQ2dDO0lBQ2hFO0lBQ0F0QyxTQUFTMEssSUFBSSxFQUFFO1FBQ1gsSUFBSSxDQUFDQSxLQUFLcUcsR0FBRyxFQUFFO1lBQ1gsTUFBTSxJQUFJblIsZ0JBQWdCNEMsY0FBYyxDQUFDLENBQUMsMkRBQTJELENBQUM7UUFDMUc7UUFDQSxNQUFNRixNQUFNNUQsV0FBVzhFLFVBQVUsQ0FBQ3hELFFBQVEsQ0FBQzBLLE1BQU07WUFBRWpILGNBQWM3RCxnQkFBZ0IySyxJQUFJLENBQUMwRyxXQUFXO1FBQUM7UUFDbEcsTUFBTTdHLFVBQVUsSUFBSXhLLGdCQUFnQjJLLElBQUksQ0FBQ1ksYUFBYTtRQUN0RGYsUUFBUWlCLGtCQUFrQixDQUFDeEssU0FBUyxHQUFHO1FBQ3ZDdUosUUFBUWlCLGtCQUFrQixDQUFDTixVQUFVLEdBQUduTSxXQUFXb00sYUFBYSxDQUFDQyxTQUFTLENBQUMsSUFBSXJMLGdCQUFnQjJLLElBQUksQ0FBQ3lHLGdCQUFnQixDQUFDTCxxQkFBcUJqRyxLQUFLcUcsR0FBRztRQUNsSjNHLFFBQVFnQixTQUFTLEdBQUd4TSxXQUFXb00sYUFBYSxDQUFDa0csS0FBSyxDQUFDNU8sS0FBSzZPLFFBQVE7UUFDaEUsSUFBSSxDQUFDeFEsSUFBSSxHQUFHVCxPQUFPQyxJQUFJLENBQUN2QixXQUFXb00sYUFBYSxDQUFDQyxTQUFTLENBQUNiO1FBQzNELE9BQU8sSUFBSTtJQUNmO0FBQ0o7QUFFQSxNQUFNZ0gscUJBQXFCeFIsZ0JBQWdCd1EsY0FBYztJQUNyRDNQLGFBQWM7UUFDVixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDSSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNHLE1BQU0sR0FBRyxFQUFFO0lBQ3BCO0lBQ0EsTUFBTW9RLFNBQVN4USxTQUFTLEVBQUVGLElBQUksRUFBRTtRQUM1QixPQUFPdU4sVUFBVUcsTUFBTSxDQUFDeE4sV0FBV0Y7SUFDdkM7QUFDSjtBQUVBLE1BQU0yUSx1QkFBdUIxUixnQkFBZ0J3USxjQUFjO0lBQ3ZEM1AsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUNJLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0csTUFBTSxHQUFHLEVBQUU7SUFDcEI7SUFDQSxNQUFNb1EsU0FBU3hRLFNBQVMsRUFBRUYsSUFBSSxFQUFFO1FBQzVCLE9BQU91TixVQUFVRyxNQUFNLENBQUN4TixXQUFXRjtJQUN2QztBQUNKO0FBRUEsTUFBTTRRLHVCQUF1QjNSLGdCQUFnQndRLGNBQWM7SUFDdkQzUCxhQUFjO1FBQ1YsS0FBSyxJQUFJQztRQUNULElBQUksQ0FBQ0ksSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRyxNQUFNLEdBQUcsRUFBRTtJQUNwQjtJQUNBLE1BQU1vUSxTQUFTeFEsU0FBUyxFQUFFRixJQUFJLEVBQUU7UUFDNUIsT0FBT3VOLFVBQVVHLE1BQU0sQ0FBQ3hOLFdBQVdGO0lBQ3ZDO0FBQ0o7QUFFQSxNQUFNNlEsdUJBQXVCNVIsZ0JBQWdCd1EsY0FBYztJQUN2RDNQLGFBQWM7UUFDVixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDSSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNHLE1BQU0sR0FBRyxFQUFFO0lBQ3BCO0lBQ0EsTUFBTW9RLFNBQVN4USxTQUFTLEVBQUVGLElBQUksRUFBRTtRQUM1QixPQUFPdU4sVUFBVUcsTUFBTSxDQUFDeE4sV0FBV0Y7SUFDdkM7QUFDSjtBQUVBLE1BQU04USx3QkFBd0I3UixnQkFBZ0J3USxjQUFjO0lBQ3hEM1AsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUNJLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0csTUFBTSxHQUFHLEVBQUU7SUFDcEI7SUFDQSxNQUFNb1EsU0FBU3hRLFNBQVMsRUFBRUYsSUFBSSxFQUFFO1FBQzVCLE9BQU91TixVQUFVRyxNQUFNLENBQUN4TixXQUFXRjtJQUN2QztBQUNKO0FBRUEsTUFBTStRLHdCQUF3QjlSLGdCQUFnQndRLGNBQWM7SUFDeEQzUCxhQUFjO1FBQ1YsS0FBSyxJQUFJQztRQUNULElBQUksQ0FBQ0ksSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRyxNQUFNLEdBQUcsRUFBRTtJQUNwQjtJQUNBLE1BQU1vUSxTQUFTeFEsU0FBUyxFQUFFRixJQUFJLEVBQUU7UUFDNUIsT0FBT3VOLFVBQVVHLE1BQU0sQ0FBQ3hOLFdBQVdGO0lBQ3ZDO0FBQ0o7QUFFQSxNQUFNZ1Isd0JBQXdCL1IsZ0JBQWdCd1EsY0FBYztJQUN4RDNQLGFBQWM7UUFDVixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDSSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNHLE1BQU0sR0FBRyxFQUFFO0lBQ3BCO0lBQ0EsTUFBTW9RLFNBQVN4USxTQUFTLEVBQUVGLElBQUksRUFBRTtRQUM1QixPQUFPdU4sVUFBVUcsTUFBTSxDQUFDeE4sV0FBV0Y7SUFDdkM7QUFDSjtBQUVBLE1BQU1pUjtJQUNGLGFBQWFoUCxZQUFZL0IsU0FBUyxFQUFFRSxXQUFXLEVBQUU4QixTQUFTLEVBQUU7UUFDeEQsTUFBTTRILGFBQWEsSUFBSXFHO1FBQ3ZCckcsV0FBVzVKLFNBQVMsR0FBR0E7UUFDdkI0SixXQUFXMUosV0FBVyxHQUFHQTtRQUN6QjBKLFdBQVd4SixNQUFNLEdBQUc0QixVQUFVMEksTUFBTSxDQUFDLENBQUNDLFFBQVUsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ0MsT0FBTyxDQUFDRixXQUFXLENBQUM7UUFDMUYsTUFBTUosWUFBWSxJQUFJNkY7UUFDdEI3RixVQUFVdkssU0FBUyxHQUFHQTtRQUN0QnVLLFVBQVVySyxXQUFXLEdBQUc7UUFDeEJxSyxVQUFVbkssTUFBTSxHQUFHNEIsVUFBVTBJLE1BQU0sQ0FBQyxDQUFDQyxRQUFVLElBQUksQ0FBQ0csZUFBZSxDQUFDRCxPQUFPLENBQUNGLFdBQVcsQ0FBQztRQUN4RixNQUFNdE0sT0FBT1gsT0FBT3dOLG1CQUFtQixDQUFDLE1BQU07WUFDMUM2RSxZQUFZLElBQUksQ0FBQ2lCLG9CQUFvQixDQUFDaFIsVUFBVStQLFVBQVU7WUFDMUQzRSxtQkFBbUI7Z0JBQ2ZqSixRQUFRO2dCQUNSaEMsTUFBTTtZQUNWO1lBQ0FrTCxvQkFBb0I7Z0JBQ2hCbEosUUFBUTtnQkFDUmhDLE1BQU07WUFDVjtRQUNKO1FBQ0F5SixXQUFXOUosSUFBSSxHQUFHekIsS0FBS3VMLFVBQVU7UUFDakNXLFVBQVV6SyxJQUFJLEdBQUd6QixLQUFLa00sU0FBUztRQUMvQixNQUFNN0ksTUFBTTtZQUNSa0k7WUFDQVc7UUFDSjtRQUNBLE9BQU83STtJQUNYO0lBQ0EsYUFBYXNHLEtBQUtoSSxTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDcEMsTUFBTW1NLFlBQVlvQixVQUFVRSxnQkFBZ0IsQ0FBQ3ZOLFVBQVVvSixJQUFJO1FBQzNELE1BQU04QyxTQUFTeE8sT0FBT3lPLFVBQVUsQ0FBQ0Y7UUFDakNDLE9BQU9ySSxNQUFNLENBQUN4RSxPQUFPQyxJQUFJLENBQUNRO1FBQzFCLElBQUksQ0FBQzJCLElBQUkySyxHQUFHLEVBQUU7WUFDVjNLLElBQUkySyxHQUFHLEdBQUcsQ0FBQyw2QkFBNkIsRUFBRTNLLElBQUkzQixJQUFJLENBQUN1TSxRQUFRLENBQUMsVUFBVSwyQkFBMkIsQ0FBQztRQUN0RztRQUNBLE1BQU1DLFVBQVU7WUFDWjdLLEtBQUtBLElBQUkySyxHQUFHO1FBQ2hCO1FBQ0EsTUFBTXRFLFlBQVlvRSxPQUFPbEUsSUFBSSxDQUFDc0U7UUFDOUIsTUFBTTJFLGNBQWNsVCxXQUFXeUwsU0FBUyxDQUFDQyxLQUFLLENBQUMzQixXQUFXL0ksZ0JBQWdCMkssSUFBSSxDQUFDd0gsY0FBYztRQUM3RixNQUFNQyxlQUFlcFMsZ0JBQWdCcVMsT0FBTyxDQUFDQyxlQUFlLENBQUNKLGFBQWFsUyxnQkFBZ0J1UyxRQUFRLENBQUMzUyxHQUFHLENBQUM4QyxJQUFJekIsU0FBUyxDQUFDK1AsVUFBVSxFQUFFekMsSUFBSTtRQUNySSxPQUFPNkQsYUFBYTNPLE1BQU07SUFDOUI7SUFDQSxhQUFhbUosT0FBTzNMLFNBQVMsRUFBRXlCLEdBQUcsRUFBRXFHLFNBQVMsRUFBRWhJLElBQUksRUFBRTtRQUNqRCxNQUFNbU0sWUFBWW9CLFVBQVVFLGdCQUFnQixDQUFDdk4sVUFBVW9KLElBQUk7UUFDM0QsTUFBTThDLFNBQVN4TyxPQUFPaVAsWUFBWSxDQUFDVjtRQUNuQ0MsT0FBT3JJLE1BQU0sQ0FBQ3hFLE9BQU9DLElBQUksQ0FBQ1E7UUFDMUIsSUFBSSxDQUFDMkIsSUFBSTJLLEdBQUcsRUFBRTtZQUNWM0ssSUFBSTJLLEdBQUcsR0FBRyxDQUFDLDRCQUE0QixFQUFFM0ssSUFBSTNCLElBQUksQ0FBQ3VNLFFBQVEsQ0FBQyxVQUFVLDBCQUEwQixDQUFDO1FBQ3BHO1FBQ0EsTUFBTUMsVUFBVTtZQUNaN0ssS0FBS0EsSUFBSTJLLEdBQUc7UUFDaEI7UUFDQSxNQUFNNkUsY0FBYyxJQUFJbFMsZ0JBQWdCMkssSUFBSSxDQUFDd0gsY0FBYztRQUMzRCxNQUFNbkIsYUFBYWhSLGdCQUFnQnVTLFFBQVEsQ0FBQzNTLEdBQUcsQ0FBQzhDLElBQUl6QixTQUFTLENBQUMrUCxVQUFVO1FBQ3hFLE1BQU13QixpQkFBaUJ4UyxnQkFBZ0JxUyxPQUFPLENBQUNJLGVBQWUsQ0FBQzFKLFdBQVdpSSxXQUFXekMsSUFBSTtRQUN6RjJELFlBQVlRLENBQUMsR0FBRzNULFVBQVV3USxxQkFBcUIsQ0FBQ29ELGFBQWEsQ0FBQ0gsZUFBZUUsQ0FBQztRQUM5RVIsWUFBWVUsQ0FBQyxHQUFHN1QsVUFBVXdRLHFCQUFxQixDQUFDb0QsYUFBYSxDQUFDSCxlQUFlSSxDQUFDO1FBQzlFLE1BQU1DLGlCQUFpQnZTLE9BQU9DLElBQUksQ0FBQ3ZCLFdBQVdvTSxhQUFhLENBQUNDLFNBQVMsQ0FBQzZHO1FBQ3RFLE1BQU1yRSxLQUFLVixPQUFPUCxNQUFNLENBQUNXLFNBQVNzRjtRQUNsQyxPQUFPaEY7SUFDWDtJQUNBLGFBQWFpRixXQUFXN1IsU0FBUyxFQUFFOFIsT0FBTyxFQUFFM1EsTUFBTSxFQUFFO1FBQ2hELE1BQU04SyxZQUFZLElBQUksQ0FBQytFLG9CQUFvQixDQUFDYyxRQUFROVIsU0FBUyxDQUFDK1AsVUFBVTtRQUN4RSxNQUFNZ0MsT0FBT3JVLE9BQU9zVSxVQUFVLENBQUMvRjtRQUMvQixNQUFNZ0csZ0JBQWdCbFUsV0FBV3lMLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDcUksUUFBUWhTLElBQUksRUFBRWYsZ0JBQWdCMkssSUFBSSxDQUFDQyxjQUFjO1FBQ2xHLE1BQU11SSxrQkFBa0JuVSxXQUFXeUwsU0FBUyxDQUFDQyxLQUFLLENBQUN3SSxjQUFjckksVUFBVSxFQUFFN0ssZ0JBQWdCMkssSUFBSSxDQUFDdUcsWUFBWTtRQUM5RzhCLEtBQUtJLGFBQWEsQ0FBQzlTLE9BQU9DLElBQUksQ0FBQzRTLGdCQUFnQnRJLFVBQVU7UUFDekQsTUFBTXdJLGVBQWVyVSxXQUFXeUwsU0FBUyxDQUFDQyxLQUFLLENBQUN6SixVQUFVcVMsTUFBTSxDQUFDdlMsSUFBSSxFQUFFZixnQkFBZ0IySyxJQUFJLENBQUNZLGFBQWE7UUFDekcsTUFBTWdJLE9BQU9QLEtBQUtRLGFBQWEsQ0FBQ2xULE9BQU9DLElBQUksQ0FBQzhTLGFBQWE3SCxTQUFTO1FBQ2xFLElBQUlwSixXQUFXLE1BQU07WUFDakIsT0FBT21SO1FBQ1g7UUFDQSxPQUFPLElBQUkvUCxXQUFXK1AsTUFBTTlQLE1BQU0sQ0FBQ2lDLEtBQUssQ0FBQyxHQUFHdEQsVUFBVTtJQUMxRDtJQUNBLGFBQWFlLFVBQVVDLE1BQU0sRUFBRVYsR0FBRyxFQUFFO1FBQ2hDLE9BQVFVLE9BQU9FLFdBQVc7WUFDdEIsS0FBSztnQkFDRCxPQUFPeEUsV0FBV3lFLGNBQWMsQ0FBQzdDLE1BQU0sQ0FBQ2dDO1lBQzVDLEtBQUs7WUFDTCxLQUFLO2dCQUNELE9BQU8sSUFBSWMsV0FBV2QsSUFBSTNCLElBQUksRUFBRTBDLE1BQU07WUFDMUMsS0FBSztnQkFBTztvQkFDUixNQUFNZ1EsZ0JBQWdCelUsV0FBV3lMLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDaEksSUFBSTNCLElBQUksRUFBRWYsZ0JBQWdCMkssSUFBSSxDQUFDWSxhQUFhO29CQUM3RixPQUFPa0ksY0FBY2pJLFNBQVM7Z0JBQ2xDO1lBQ0E7Z0JBQ0ksTUFBTSxJQUFJeEwsZ0JBQWdCNEMsY0FBYyxDQUFDO1FBQ2pEO0lBQ0o7SUFDQSxhQUFhYyxVQUFVTixNQUFNLEVBQUVPLE9BQU8sRUFBRTFDLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ3ZFLE9BQVFHLE9BQU9FLFdBQVc7WUFDdEIsS0FBSztnQkFBTztvQkFDUixNQUFNaUosTUFBTTVJO29CQUNaLElBQUk0SSxJQUFJOU0sQ0FBQyxFQUFFO3dCQUNQLE1BQU0rTSxTQUFTMU4sV0FBVzhFLFVBQVUsQ0FBQ3hELFFBQVEsQ0FBQ3VELFNBQVM7NEJBQUVFLGNBQWM3RCxnQkFBZ0IySyxJQUFJLENBQUN1RyxZQUFZO3dCQUFDO3dCQUN6RyxPQUFPLElBQUksQ0FBQ3pFLGdCQUFnQixDQUFDRCxRQUFRdkwsV0FBV0UsYUFBYThCO29CQUNqRSxPQUNLO3dCQUNELE1BQU11SixTQUFTMU4sV0FBVzhFLFVBQVUsQ0FBQ3hELFFBQVEsQ0FBQ3VELFNBQVM7NEJBQUVFLGNBQWM3RCxnQkFBZ0IySyxJQUFJLENBQUMwRyxXQUFXO3dCQUFDO3dCQUN4RyxPQUFPLElBQUksQ0FBQzNFLGVBQWUsQ0FBQ0YsUUFBUXZMLFdBQVdFLGFBQWE4QjtvQkFDaEU7Z0JBQ0o7WUFDQSxLQUFLO2dCQUFPO29CQUNSLE1BQU11SixTQUFTLElBQUl4TSxnQkFBZ0IySyxJQUFJLENBQUMwRyxXQUFXLENBQUMxTjtvQkFDcEQsT0FBTyxJQUFJLENBQUMrSSxlQUFlLENBQUNGLFFBQVF2TCxXQUFXRSxhQUFhOEI7Z0JBQ2hFO1lBQ0EsS0FBSztnQkFBUTtvQkFDVCxNQUFNdUgsVUFBVXhMLFdBQVd5TCxTQUFTLENBQUNDLEtBQUssQ0FBQyxJQUFJbEgsV0FBV0csVUFBVTNELGdCQUFnQjJLLElBQUksQ0FBQ1ksYUFBYTtvQkFDdEcsTUFBTWlCLFNBQVMsSUFBSXhNLGdCQUFnQjJLLElBQUksQ0FBQzBHLFdBQVcsQ0FBQzdHLFFBQVFnQixTQUFTO29CQUNyRSxJQUFJLENBQUNrSSxtQkFBbUIsQ0FBQ2xKLFFBQVFpQixrQkFBa0IsQ0FBQ04sVUFBVSxFQUFFbEssVUFBVStQLFVBQVU7b0JBQ3BGLE9BQU8sSUFBSSxDQUFDdEUsZUFBZSxDQUFDRixRQUFRdkwsV0FBV0UsYUFBYThCO2dCQUNoRTtZQUNBLEtBQUs7Z0JBQVM7b0JBQ1YsTUFBTXVILFVBQVV4TCxXQUFXeUwsU0FBUyxDQUFDQyxLQUFLLENBQUMsSUFBSWxILFdBQVdHLFVBQVUzRCxnQkFBZ0IySyxJQUFJLENBQUNDLGNBQWM7b0JBQ3ZHLE1BQU00QixTQUFTeE4sV0FBV3lMLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDRixRQUFRSyxVQUFVLEVBQUU3SyxnQkFBZ0IySyxJQUFJLENBQUN1RyxZQUFZO29CQUMvRixJQUFJLENBQUN3QyxtQkFBbUIsQ0FBQ2xKLFFBQVFVLG1CQUFtQixDQUFDQyxVQUFVLEVBQUVsSyxVQUFVK1AsVUFBVTtvQkFDckYsT0FBTyxJQUFJLENBQUN2RSxnQkFBZ0IsQ0FBQ0QsUUFBUXZMLFdBQVdFLGFBQWE4QjtnQkFDakU7WUFDQTtnQkFDSSxNQUFNLElBQUlqRCxnQkFBZ0I0QyxjQUFjLENBQUM7UUFDakQ7SUFDSjtJQUNBLE9BQU84USxvQkFBb0J2SSxVQUFVLEVBQUU2RixVQUFVLEVBQUU7UUFDL0MsSUFBSSxDQUFDN0YsWUFBWTtZQUNiLE1BQU0sSUFBSW5MLGdCQUFnQjJULFdBQVcsQ0FBQztRQUMxQztRQUNBLElBQUlDLHVCQUF1QjtRQUMzQixJQUFJO1lBQ0FBLHVCQUF1QjVVLFdBQVd5TCxTQUFTLENBQUNDLEtBQUssQ0FBQ1MsWUFBWW5MLGdCQUFnQjJLLElBQUksQ0FBQ3lHLGdCQUFnQixFQUFFL1EsS0FBSztRQUM5RyxFQUNBLE9BQU9uQixHQUFHO1lBQ04sTUFBTSxJQUFJYyxnQkFBZ0IyVCxXQUFXLENBQUM7UUFDMUM7UUFDQSxJQUFJNUMscUJBQXFCQyxnQkFBZ0I0QyxzQkFBc0I7WUFDM0QsTUFBTSxJQUFJNVQsZ0JBQWdCMlQsV0FBVyxDQUFDO1FBQzFDO0lBQ0o7SUFDQSxhQUFhbEgsaUJBQWlCRCxNQUFNLEVBQUV2TCxTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUNyRSxNQUFNdUgsVUFBVSxJQUFJeEssZ0JBQWdCMkssSUFBSSxDQUFDQyxjQUFjO1FBQ3ZESixRQUFRVSxtQkFBbUIsQ0FBQ2pLLFNBQVMsR0FBRztRQUN4Q3VKLFFBQVFVLG1CQUFtQixDQUFDQyxVQUFVLEdBQUduTSxXQUFXb00sYUFBYSxDQUFDQyxTQUFTLENBQUMsSUFBSXJMLGdCQUFnQjJLLElBQUksQ0FBQ3lHLGdCQUFnQixDQUFDTCxxQkFBcUI5UCxVQUFVK1AsVUFBVTtRQUMvSnhHLFFBQVFLLFVBQVUsR0FBRzdMLFdBQVdvTSxhQUFhLENBQUNDLFNBQVMsQ0FBQ21CO1FBQ3hELE1BQU05SixNQUFNLElBQUl3TztRQUNoQnhPLElBQUkzQixJQUFJLEdBQUdULE9BQU9DLElBQUksQ0FBQ3ZCLFdBQVdvTSxhQUFhLENBQUNDLFNBQVMsQ0FBQ2I7UUFDMUQ5SCxJQUFJekIsU0FBUyxHQUFHN0IsT0FBTzZMLE1BQU0sQ0FBQyxDQUFDLEdBQUdoSztRQUNsQ3lCLElBQUl2QixXQUFXLEdBQUdBO1FBQ2xCdUIsSUFBSXJCLE1BQU0sR0FBRzRCO1FBQ2IsT0FBT1A7SUFDWDtJQUNBLGFBQWFnSyxnQkFBZ0JGLE1BQU0sRUFBRXZMLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ3BFLE1BQU11SCxVQUFVLElBQUl4SyxnQkFBZ0IySyxJQUFJLENBQUNZLGFBQWE7UUFDdERmLFFBQVFpQixrQkFBa0IsQ0FBQ3hLLFNBQVMsR0FBRztRQUN2QyxNQUFNK1AsYUFBYUQscUJBQXFCOVAsVUFBVStQLFVBQVU7UUFDNUR4RyxRQUFRaUIsa0JBQWtCLENBQUNOLFVBQVUsR0FBR25NLFdBQVdvTSxhQUFhLENBQUNDLFNBQVMsQ0FBQyxJQUFJckwsZ0JBQWdCMkssSUFBSSxDQUFDeUcsZ0JBQWdCLENBQUNKO1FBQ3JIeEcsUUFBUWdCLFNBQVMsR0FBR2dCLE9BQU9uTSxLQUFLO1FBQ2hDLE1BQU1xQyxNQUFNLElBQUkyTztRQUNoQjNPLElBQUkzQixJQUFJLEdBQUdULE9BQU9DLElBQUksQ0FBQ3ZCLFdBQVdvTSxhQUFhLENBQUNDLFNBQVMsQ0FBQ2I7UUFDMUQ5SCxJQUFJekIsU0FBUyxHQUFHN0IsT0FBTzZMLE1BQU0sQ0FBQyxDQUFDLEdBQUdoSztRQUNsQ3lCLElBQUl2QixXQUFXLEdBQUdBO1FBQ2xCdUIsSUFBSXJCLE1BQU0sR0FBRzRCO1FBQ2IsT0FBT1A7SUFDWDtJQUNBLE9BQU91UCxxQkFBcUI0QixLQUFLLEVBQUU7UUFDL0IsT0FBUUEsTUFBTTFSLFdBQVc7WUFDckIsS0FBSztnQkFDRCxPQUFPO1lBQ1gsS0FBSztnQkFDRCxPQUFPO1lBQ1gsS0FBSztnQkFDRCxPQUFPO1lBQ1gsS0FBSztnQkFDRCxPQUFPO1lBQ1g7Z0JBQ0ksT0FBTzBSO1FBQ2Y7SUFDSjtBQUNKO0FBQ0E3QixTQUFTakcsZUFBZSxHQUFHO0lBQUM7Q0FBUztBQUNyQ2lHLFNBQVNuRyxnQkFBZ0IsR0FBRztJQUFDO0lBQVE7SUFBYTtDQUFhO0FBRS9ELE1BQU1pSSxzQkFBc0I5VCxnQkFBZ0I4VCxhQUFhO0lBQ3JEalQsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUNpVCxXQUFXLEdBQUcvVCxnQkFBZ0J1UyxRQUFRLENBQUN5QixLQUFLO1FBQ2pELElBQUksQ0FBQzdGLGNBQWMsR0FBRztZQUNsQjtZQUFTO1lBQVc7WUFBVztZQUMvQjtZQUFZO1lBQ1o7WUFBWTtZQUFZO1NBQzNCO0lBQ0w7SUFDQSxNQUFNcEksY0FBYzlFLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ25ELE1BQU0zRCxPQUFPLE1BQU0wUyxTQUFTaFAsV0FBVyxDQUFDO1lBQ3BDLEdBQUcvQixTQUFTO1lBQ1pDLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1FBQ25CLEdBQUdDLGFBQWE4QjtRQUNoQixPQUFPO1lBQ0g0SCxZQUFZaEksYUFBYXZELEtBQUt1TCxVQUFVO1lBQ3hDVyxXQUFXM0ksYUFBYXZELEtBQUtrTSxTQUFTO1FBQzFDO0lBQ0o7SUFDQSxNQUFNM0MsT0FBTzVILFNBQVMsRUFBRXlCLEdBQUcsRUFBRTNCLElBQUksRUFBRTtRQUMvQixPQUFPaVIsU0FBUy9JLElBQUksQ0FBQ2hJLFdBQVd3QixhQUFhQyxNQUFNLElBQUljLFdBQVd6QztJQUN0RTtJQUNBLE1BQU0rSCxTQUFTN0gsU0FBUyxFQUFFeUIsR0FBRyxFQUFFcUcsU0FBUyxFQUFFaEksSUFBSSxFQUFFO1FBQzVDLE9BQU9pUixTQUFTcEYsTUFBTSxDQUFDM0wsV0FBV3dCLGFBQWFDLE1BQU0sSUFBSWMsV0FBV3VGLFlBQVksSUFBSXZGLFdBQVd6QztJQUNuRztJQUNBLE1BQU1tRixZQUFZOUMsTUFBTSxFQUFFVixHQUFHLEVBQUU7UUFDM0IsT0FBT3NQLFNBQVM3TyxTQUFTLENBQUNDLFFBQVFYLGFBQWFDO0lBQ25EO0lBQ0EsTUFBTXlELFlBQVkvQyxNQUFNLEVBQUVPLE9BQU8sRUFBRTFDLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ2xFLE1BQU1QLE1BQU0sTUFBTXNQLFNBQVN0TyxTQUFTLENBQUNOLFFBQVFPLFNBQVM7WUFBRSxHQUFHMUMsU0FBUztZQUFFQyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtRQUFDLEdBQUdDLGFBQWE4QjtRQUN0RyxPQUFPSixhQUFhSDtJQUN4QjtJQUNBMEQsZUFBZTFELEdBQUcsRUFBRTJELFFBQVEsRUFBRTtRQUMxQixLQUFLLENBQUNELGVBQWUxRCxLQUFLMkQ7UUFDMUIsTUFBTStILGNBQWMzTCxhQUFhQztRQUNqQyxJQUFJLENBQUUwTCxDQUFBQSx1QkFBdUI4QyxnQkFBZ0I5Qyx1QkFBdUJpRCxXQUFVLEdBQUk7WUFDOUUsTUFBTSxJQUFJL0ssVUFBVTtRQUN4QjtJQUNKO0FBQ0o7QUFFQSxNQUFNMk4scUJBQXFCalUsZ0JBQWdCaVUsWUFBWTtJQUNuRHBULGFBQWM7UUFDVixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDaVQsV0FBVyxHQUFHL1QsZ0JBQWdCdVMsUUFBUSxDQUFDeUIsS0FBSztJQUNyRDtJQUNBLE1BQU1qTyxjQUFjOUUsU0FBUyxFQUFFRSxXQUFXLEVBQUU4QixTQUFTLEVBQUU7UUFDbkQsTUFBTTNELE9BQU8sTUFBTTBTLFNBQVNoUCxXQUFXLENBQUM7WUFDcEMsR0FBRy9CLFNBQVM7WUFDWkMsTUFBTSxJQUFJLENBQUNBLElBQUk7UUFDbkIsR0FBR0MsYUFBYThCO1FBQ2hCLE9BQU87WUFDSDRILFlBQVloSSxhQUFhdkQsS0FBS3VMLFVBQVU7WUFDeENXLFdBQVczSSxhQUFhdkQsS0FBS2tNLFNBQVM7UUFDMUM7SUFDSjtJQUNBLE1BQU10RixZQUFZOUMsTUFBTSxFQUFFVixHQUFHLEVBQUU7UUFDM0IsT0FBT3NQLFNBQVM3TyxTQUFTLENBQUNDLFFBQVFYLGFBQWFDO0lBQ25EO0lBQ0EsTUFBTXlELFlBQVkvQyxNQUFNLEVBQUVPLE9BQU8sRUFBRTFDLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ2xFLE1BQU1QLE1BQU0sTUFBTXNQLFNBQVN0TyxTQUFTLENBQUNOLFFBQVFPLFNBQVM7WUFBRSxHQUFHMUMsU0FBUztZQUFFQyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtRQUFDLEdBQUdDLGFBQWE4QjtRQUN0RyxPQUFPSixhQUFhSDtJQUN4QjtJQUNBMEQsZUFBZTFELEdBQUcsRUFBRTJELFFBQVEsRUFBRTtRQUMxQixLQUFLLENBQUNELGVBQWUxRCxLQUFLMkQ7UUFDMUIsTUFBTStILGNBQWMzTCxhQUFhQztRQUNqQyxJQUFJLENBQUUwTCxDQUFBQSx1QkFBdUI4QyxnQkFBZ0I5Qyx1QkFBdUJpRCxXQUFVLEdBQUk7WUFDOUUsTUFBTSxJQUFJL0ssVUFBVTtRQUN4QjtJQUNKO0lBQ0EsTUFBTTROLGFBQWFqVCxTQUFTLEVBQUU4UixPQUFPLEVBQUUzUSxNQUFNLEVBQUU7UUFDM0MsTUFBTW1SLE9BQU8sTUFBTXZCLFNBQVNjLFVBQVUsQ0FBQztZQUFFLEdBQUc3UixTQUFTO1lBQUVxUyxRQUFRN1EsYUFBYXhCLFVBQVVxUyxNQUFNO1FBQUUsR0FBRzdRLGFBQWFzUSxVQUFVM1E7UUFDeEgsT0FBT21SO0lBQ1g7QUFDSjtBQUVBLE1BQU1ZLFNBQVM7SUFDWCxDQUFDblUsZ0JBQWdCMkssSUFBSSxDQUFDeUosT0FBTyxDQUFDLEVBQUU7SUFDaEMsU0FBU3BVLGdCQUFnQjJLLElBQUksQ0FBQ3lKLE9BQU87SUFDckMsQ0FBQ3BVLGdCQUFnQjJLLElBQUksQ0FBQzBKLE1BQU0sQ0FBQyxFQUFFO0lBQy9CLFFBQVFyVSxnQkFBZ0IySyxJQUFJLENBQUMwSixNQUFNO0lBQ25DLENBQUNyVSxnQkFBZ0IySyxJQUFJLENBQUMySixTQUFTLENBQUMsRUFBRTtJQUNsQyxXQUFXdFUsZ0JBQWdCMkssSUFBSSxDQUFDMkosU0FBUztJQUN6QyxDQUFDdFUsZ0JBQWdCMkssSUFBSSxDQUFDNEosUUFBUSxDQUFDLEVBQUU7SUFDakMsVUFBVXZVLGdCQUFnQjJLLElBQUksQ0FBQzRKLFFBQVE7QUFDM0M7QUFDQSxTQUFTQyxtQkFBbUJ4RCxVQUFVO0lBQ2xDLE1BQU1DLE1BQU1rRCxNQUFNLENBQUNuRCxXQUFXMU4sV0FBVyxHQUFHO0lBQzVDLElBQUksQ0FBQzJOLEtBQUs7UUFDTixNQUFNLElBQUlqUixnQkFBZ0I0QyxjQUFjLENBQUMsQ0FBQyxzQ0FBc0MsRUFBRW9PLFdBQVcsUUFBUSxDQUFDO0lBQzFHO0lBQ0EsT0FBT0M7QUFDWDtBQUVBLE1BQU13RCxxQkFBcUJ4UztJQUN2QnBCLGFBQWM7UUFDVixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDTSxJQUFJLEdBQUc7SUFDaEI7SUFDQW1KLFNBQVM7UUFDTCxNQUFNQyxVQUFVeEwsV0FBV3lMLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDLElBQUksQ0FBQzNKLElBQUksRUFBRWYsZ0JBQWdCMkssSUFBSSxDQUFDQyxjQUFjO1FBQ3pGLE9BQU81TCxXQUFXeUwsU0FBUyxDQUFDQyxLQUFLLENBQUNGLFFBQVFLLFVBQVUsRUFBRTdLLGdCQUFnQjJLLElBQUksQ0FBQytKLGVBQWU7SUFDOUY7SUFDQWhVLFNBQVM7UUFDTCxNQUFNZ0MsTUFBTSxJQUFJLENBQUM2SCxNQUFNO1FBQ3ZCLE1BQU1PLE9BQU87WUFDVHhKLEtBQUs7WUFDTDZQLEtBQUssSUFBSSxDQUFDbFEsU0FBUyxDQUFDK1AsVUFBVTtZQUM5QmpHLFNBQVMsSUFBSSxDQUFDMUosTUFBTTtZQUNwQjJKLEtBQUssSUFBSSxDQUFDN0osV0FBVztRQUN6QjtRQUNBLE9BQU8vQixPQUFPNkwsTUFBTSxDQUFDSCxNQUFNaE0sV0FBV3lFLGNBQWMsQ0FBQzdDLE1BQU0sQ0FBQ2dDO0lBQ2hFO0lBQ0F0QyxTQUFTMEssSUFBSSxFQUFFO1FBQ1gsSUFBSSxDQUFDQSxLQUFLcUcsR0FBRyxFQUFFO1lBQ1gsTUFBTSxJQUFJblIsZ0JBQWdCNEMsY0FBYyxDQUFDLENBQUMsMkRBQTJELENBQUM7UUFDMUc7UUFDQSxNQUFNNEgsVUFBVSxJQUFJeEssZ0JBQWdCMkssSUFBSSxDQUFDQyxjQUFjO1FBQ3ZESixRQUFRVSxtQkFBbUIsQ0FBQ2pLLFNBQVMsR0FBR3VULG1CQUFtQjFKLEtBQUtxRyxHQUFHO1FBQ25FLE1BQU16TyxNQUFNNUQsV0FBVzhFLFVBQVUsQ0FBQ3hELFFBQVEsQ0FBQzBLLE1BQU07WUFBRWpILGNBQWM3RCxnQkFBZ0IySyxJQUFJLENBQUMrSixlQUFlO1FBQUM7UUFDdEdsSyxRQUFRSyxVQUFVLEdBQUc3TCxXQUFXb00sYUFBYSxDQUFDQyxTQUFTLENBQUMzSTtRQUN4RCxJQUFJLENBQUMzQixJQUFJLEdBQUdULE9BQU9DLElBQUksQ0FBQ3ZCLFdBQVdvTSxhQUFhLENBQUNDLFNBQVMsQ0FBQ2I7UUFDM0QsT0FBTyxJQUFJO0lBQ2Y7QUFDSjtBQUVBLE1BQU1tSyxvQkFBb0IxUztJQUN0QnBCLGFBQWM7UUFDVixLQUFLLElBQUlDO1FBQ1QsSUFBSSxDQUFDTSxJQUFJLEdBQUc7SUFDaEI7SUFDQW1KLFNBQVM7UUFDTCxNQUFNQyxVQUFVeEwsV0FBV3lMLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDLElBQUksQ0FBQzNKLElBQUksRUFBRWYsZ0JBQWdCMkssSUFBSSxDQUFDWSxhQUFhO1FBQ3hGLE9BQU9mLFFBQVFnQixTQUFTO0lBQzVCO0lBQ0E5SyxTQUFTO1FBQ0wsTUFBTWdDLE1BQU0sSUFBSSxDQUFDNkgsTUFBTTtRQUN2QixNQUFNTyxPQUFPO1lBQ1R4SixLQUFLO1lBQ0w2UCxLQUFLLElBQUksQ0FBQ2xRLFNBQVMsQ0FBQytQLFVBQVU7WUFDOUJqRyxTQUFTLElBQUksQ0FBQzFKLE1BQU07WUFDcEIySixLQUFLLElBQUksQ0FBQzdKLFdBQVc7UUFDekI7UUFDQSxPQUFPL0IsT0FBTzZMLE1BQU0sQ0FBQ0gsTUFBTTtZQUN2QnBDLEdBQUczSixVQUFVeUIsT0FBTyxDQUFDRyxXQUFXLENBQUMrQjtRQUNyQztJQUNKO0lBQ0F0QyxTQUFTMEssSUFBSSxFQUFFO1FBQ1gsSUFBSSxDQUFDQSxLQUFLcUcsR0FBRyxFQUFFO1lBQ1gsTUFBTSxJQUFJblIsZ0JBQWdCNEMsY0FBYyxDQUFDLENBQUMsMkRBQTJELENBQUM7UUFDMUc7UUFDQSxJQUFJLENBQUNrSSxLQUFLcEMsQ0FBQyxFQUFFO1lBQ1QsTUFBTSxJQUFJMUksZ0JBQWdCNEMsY0FBYyxDQUFDLENBQUMsc0RBQXNELENBQUM7UUFDckc7UUFDQSxNQUFNNEgsVUFBVSxJQUFJeEssZ0JBQWdCMkssSUFBSSxDQUFDWSxhQUFhO1FBQ3REZixRQUFRaUIsa0JBQWtCLENBQUN4SyxTQUFTLEdBQUd1VCxtQkFBbUIxSixLQUFLcUcsR0FBRztRQUNsRTNHLFFBQVFnQixTQUFTLEdBQUd6TSxVQUFVeUIsT0FBTyxDQUFDQyxhQUFhLENBQUNxSyxLQUFLcEMsQ0FBQztRQUMxRCxJQUFJLENBQUMzSCxJQUFJLEdBQUdULE9BQU9DLElBQUksQ0FBQ3ZCLFdBQVdvTSxhQUFhLENBQUNDLFNBQVMsQ0FBQ2I7UUFDM0QsT0FBTyxJQUFJO0lBQ2Y7QUFDSjtBQUVBLE1BQU1vSztJQUNGLGFBQWE1UixZQUFZL0IsU0FBUyxFQUFFRSxXQUFXLEVBQUU4QixTQUFTLEVBQUU7UUFDeEQsTUFBTTRILGFBQWEsSUFBSTRKO1FBQ3ZCNUosV0FBVzVKLFNBQVMsR0FBR0E7UUFDdkI0SixXQUFXMUosV0FBVyxHQUFHQTtRQUN6QjBKLFdBQVd4SixNQUFNLEdBQUc0QixVQUFVMEksTUFBTSxDQUFDLENBQUNDLFFBQVUsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ0MsT0FBTyxDQUFDRixXQUFXLENBQUM7UUFDMUYsTUFBTUosWUFBWSxJQUFJbUo7UUFDdEJuSixVQUFVdkssU0FBUyxHQUFHQTtRQUN0QnVLLFVBQVVySyxXQUFXLEdBQUc7UUFDeEJxSyxVQUFVbkssTUFBTSxHQUFHNEIsVUFBVTBJLE1BQU0sQ0FBQyxDQUFDQyxRQUFVLElBQUksQ0FBQ0csZUFBZSxDQUFDRCxPQUFPLENBQUNGLFdBQVcsQ0FBQztRQUN4RixNQUFNeEssT0FBT0gsVUFBVStQLFVBQVUsQ0FBQzFOLFdBQVc7UUFDN0MsTUFBTWhFLE9BQU9YLE9BQU93TixtQkFBbUIsQ0FBQy9LLE1BQU07WUFDMUNpTCxtQkFBbUI7Z0JBQ2ZqSixRQUFRO2dCQUNSaEMsTUFBTTtZQUNWO1lBQ0FrTCxvQkFBb0I7Z0JBQ2hCbEosUUFBUTtnQkFDUmhDLE1BQU07WUFDVjtRQUNKO1FBQ0F5SixXQUFXOUosSUFBSSxHQUFHekIsS0FBS3VMLFVBQVU7UUFDakNXLFVBQVV6SyxJQUFJLEdBQUd6QixLQUFLa00sU0FBUztRQUMvQixNQUFNN0ksTUFBTTtZQUNSa0k7WUFDQVc7UUFDSjtRQUNBLE9BQU83STtJQUNYO0lBQ0EsYUFBYXNHLEtBQUtoSSxTQUFTLEVBQUV5QixHQUFHLEVBQUUzQixJQUFJLEVBQUU7UUFDcEMsSUFBSSxDQUFDMkIsSUFBSTJLLEdBQUcsRUFBRTtZQUNWM0ssSUFBSTJLLEdBQUcsR0FBRyxDQUFDLDZCQUE2QixFQUFFM0ssSUFBSTNCLElBQUksQ0FBQ3VNLFFBQVEsQ0FBQyxVQUFVLDJCQUEyQixDQUFDO1FBQ3RHO1FBQ0EsTUFBTUMsVUFBVTtZQUNaN0ssS0FBS0EsSUFBSTJLLEdBQUc7UUFDaEI7UUFDQSxNQUFNdEUsWUFBWXBLLE9BQU9zSyxJQUFJLENBQUMsTUFBTTNJLE9BQU9DLElBQUksQ0FBQ1EsT0FBT3dNO1FBQ3ZELE9BQU92TixnQkFBZ0J1UCxxQkFBcUIsQ0FBQ29ELGFBQWEsQ0FBQzVKO0lBQy9EO0lBQ0EsYUFBYTZELE9BQU8zTCxTQUFTLEVBQUV5QixHQUFHLEVBQUVxRyxTQUFTLEVBQUVoSSxJQUFJLEVBQUU7UUFDakQsSUFBSSxDQUFDMkIsSUFBSTJLLEdBQUcsRUFBRTtZQUNWM0ssSUFBSTJLLEdBQUcsR0FBRyxDQUFDLDRCQUE0QixFQUFFM0ssSUFBSTNCLElBQUksQ0FBQ3VNLFFBQVEsQ0FBQyxVQUFVLDBCQUEwQixDQUFDO1FBQ3BHO1FBQ0EsTUFBTUMsVUFBVTtZQUNaN0ssS0FBS0EsSUFBSTJLLEdBQUc7UUFDaEI7UUFDQSxNQUFNUSxLQUFLbFAsT0FBT2lPLE1BQU0sQ0FBQyxNQUFNdE0sT0FBT0MsSUFBSSxDQUFDUSxPQUFPd00sU0FBU2pOLE9BQU9DLElBQUksQ0FBQ3dJO1FBQ3ZFLE9BQU84RTtJQUNYO0lBQ0EsYUFBYWlGLFdBQVc3UixTQUFTLEVBQUU4UixPQUFPLEVBQUUzUSxNQUFNLEVBQUU7UUFDaEQsTUFBTW9KLFlBQVk3TSxPQUFPa1csZUFBZSxDQUFDO1lBQ3JDblMsS0FBS3pCLFVBQVVxUyxNQUFNLENBQUN2UyxJQUFJO1lBQzFCcUMsUUFBUTtZQUNSaEMsTUFBTTtRQUNWO1FBQ0EsTUFBTXlKLGFBQWFsTSxPQUFPbVcsZ0JBQWdCLENBQUM7WUFDdkNwUyxLQUFLcVEsUUFBUWhTLElBQUk7WUFDakJxQyxRQUFRO1lBQ1JoQyxNQUFNO1FBQ1Y7UUFDQSxNQUFNbVMsT0FBTzVVLE9BQU9vVyxhQUFhLENBQUM7WUFDOUJ2SjtZQUNBWDtRQUNKO1FBQ0EsT0FBTyxJQUFJckgsV0FBVytQLE1BQU05UCxNQUFNLENBQUNpQyxLQUFLLENBQUMsR0FBR3RELFVBQVU7SUFDMUQ7SUFDQSxhQUFhZSxVQUFVQyxNQUFNLEVBQUVWLEdBQUcsRUFBRTtRQUNoQyxPQUFRVSxPQUFPRSxXQUFXO1lBQ3RCLEtBQUs7Z0JBQ0QsT0FBT3hFLFdBQVd5RSxjQUFjLENBQUM3QyxNQUFNLENBQUNnQztZQUM1QyxLQUFLO1lBQ0wsS0FBSztnQkFDRCxPQUFPLElBQUljLFdBQVdkLElBQUkzQixJQUFJLEVBQUUwQyxNQUFNO1lBQzFDLEtBQUs7Z0JBQU87b0JBQ1IsTUFBTWdRLGdCQUFnQnpVLFdBQVd5TCxTQUFTLENBQUNDLEtBQUssQ0FBQ2hJLElBQUkzQixJQUFJLEVBQUVmLGdCQUFnQjJLLElBQUksQ0FBQ1ksYUFBYTtvQkFDN0YsT0FBT2tJLGNBQWNqSSxTQUFTO2dCQUNsQztZQUNBO2dCQUNJLE1BQU0sSUFBSXhMLGdCQUFnQjRDLGNBQWMsQ0FBQztRQUNqRDtJQUNKO0lBQ0EsYUFBYWMsVUFBVU4sTUFBTSxFQUFFTyxPQUFPLEVBQUUxQyxTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUN2RSxPQUFRRyxPQUFPRSxXQUFXO1lBQ3RCLEtBQUs7Z0JBQU87b0JBQ1IsTUFBTWlKLE1BQU01STtvQkFDWixJQUFJNEksSUFBSTlNLENBQUMsRUFBRTt3QkFDUCxNQUFNK00sU0FBUzFOLFdBQVc4RSxVQUFVLENBQUN4RCxRQUFRLENBQUN1RCxTQUFTOzRCQUFFRSxjQUFjN0QsZ0JBQWdCMkssSUFBSSxDQUFDK0osZUFBZTt3QkFBQzt3QkFDNUcsT0FBTyxJQUFJLENBQUNqSSxnQkFBZ0IsQ0FBQ0QsUUFBUXZMLFdBQVdFLGFBQWE4QjtvQkFDakUsT0FDSzt3QkFDRCxJQUFJLENBQUNzSixJQUFJN0QsQ0FBQyxFQUFFOzRCQUNSLE1BQU0sSUFBSXBDLFVBQVU7d0JBQ3hCO3dCQUNBLE9BQU8sSUFBSSxDQUFDb0csZUFBZSxDQUFDM04sVUFBVXlCLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDOEwsSUFBSTdELENBQUMsR0FBR3pILFdBQVdFLGFBQWE4QjtvQkFDaEc7Z0JBQ0o7WUFDQSxLQUFLO2dCQUFPO29CQUNSLE9BQU8sSUFBSSxDQUFDeUosZUFBZSxDQUFDL0ksU0FBUzFDLFdBQVdFLGFBQWE4QjtnQkFDakU7WUFDQSxLQUFLO2dCQUFRO29CQUNULE1BQU11SCxVQUFVeEwsV0FBV3lMLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDLElBQUlsSCxXQUFXRyxVQUFVM0QsZ0JBQWdCMkssSUFBSSxDQUFDWSxhQUFhO29CQUN0RyxPQUFPLElBQUksQ0FBQ21CLGVBQWUsQ0FBQ2xDLFFBQVFnQixTQUFTLEVBQUV2SyxXQUFXRSxhQUFhOEI7Z0JBQzNFO1lBQ0EsS0FBSztnQkFBUztvQkFDVixNQUFNdUgsVUFBVXhMLFdBQVd5TCxTQUFTLENBQUNDLEtBQUssQ0FBQyxJQUFJbEgsV0FBV0csVUFBVTNELGdCQUFnQjJLLElBQUksQ0FBQ0MsY0FBYztvQkFDdkcsTUFBTTRCLFNBQVN4TixXQUFXeUwsU0FBUyxDQUFDQyxLQUFLLENBQUNGLFFBQVFLLFVBQVUsRUFBRTdLLGdCQUFnQjJLLElBQUksQ0FBQytKLGVBQWU7b0JBQ2xHLE9BQU8sSUFBSSxDQUFDakksZ0JBQWdCLENBQUNELFFBQVF2TCxXQUFXRSxhQUFhOEI7Z0JBQ2pFO1lBQ0E7Z0JBQ0ksTUFBTSxJQUFJakQsZ0JBQWdCNEMsY0FBYyxDQUFDO1FBQ2pEO0lBQ0o7SUFDQSxPQUFPNkosaUJBQWlCRCxNQUFNLEVBQUV2TCxTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUMvRCxNQUFNUCxNQUFNLElBQUkrUjtRQUNoQi9SLElBQUl0QyxRQUFRLENBQUM7WUFDVCtRLEtBQUtsUSxVQUFVK1AsVUFBVTtZQUN6QnZSLEdBQUdWLFVBQVV5QixPQUFPLENBQUNHLFdBQVcsQ0FBQzZMLE9BQU8vTSxDQUFDO1FBQzdDO1FBQ0FpRCxJQUFJekIsU0FBUyxHQUFHN0IsT0FBTzZMLE1BQU0sQ0FBQyxDQUFDLEdBQUdoSztRQUNsQ3lCLElBQUl2QixXQUFXLEdBQUdBO1FBQ2xCdUIsSUFBSXJCLE1BQU0sR0FBRzRCO1FBQ2IsT0FBT1A7SUFDWDtJQUNBLGFBQWFnSyxnQkFBZ0JGLE1BQU0sRUFBRXZMLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ3BFLE1BQU1QLE1BQU0sSUFBSWlTO1FBQ2hCalMsSUFBSXRDLFFBQVEsQ0FBQztZQUNUK1EsS0FBS2xRLFVBQVUrUCxVQUFVO1lBQ3pCdEksR0FBRzNKLFVBQVV5QixPQUFPLENBQUNHLFdBQVcsQ0FBQzZMO1FBQ3JDO1FBQ0E5SixJQUFJekIsU0FBUyxHQUFHN0IsT0FBTzZMLE1BQU0sQ0FBQyxDQUFDLEdBQUdoSztRQUNsQ3lCLElBQUl2QixXQUFXLEdBQUdBO1FBQ2xCdUIsSUFBSXJCLE1BQU0sR0FBRzRCO1FBQ2IsT0FBT1A7SUFDWDtBQUNKO0FBQ0FrUyxTQUFTN0ksZUFBZSxHQUFHO0lBQUM7Q0FBUztBQUNyQzZJLFNBQVMvSSxnQkFBZ0IsR0FBRztJQUFDO0lBQVE7SUFBYTtDQUFhO0FBRS9ELE1BQU1tSixzQkFBc0JoVixnQkFBZ0JnVixhQUFhO0lBQ3JELE1BQU1qUCxjQUFjOUUsU0FBUyxFQUFFRSxXQUFXLEVBQUU4QixTQUFTLEVBQUU7UUFDbkQsTUFBTTNELE9BQU8sTUFBTXNWLFNBQVM1UixXQUFXLENBQUM7WUFDcEM5QixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmOFAsWUFBWS9QLFVBQVUrUCxVQUFVLENBQUMxQixPQUFPLENBQUMsUUFBUTtRQUNyRCxHQUFHbk8sYUFBYThCO1FBQ2hCLE9BQU87WUFDSDRILFlBQVloSSxhQUFhdkQsS0FBS3VMLFVBQVU7WUFDeENXLFdBQVczSSxhQUFhdkQsS0FBS2tNLFNBQVM7UUFDMUM7SUFDSjtJQUNBLE1BQU0zQyxPQUFPNUgsU0FBUyxFQUFFeUIsR0FBRyxFQUFFM0IsSUFBSSxFQUFFO1FBQy9CLE9BQU82VCxTQUFTM0wsSUFBSSxDQUFDaEksV0FBV3dCLGFBQWFDLE1BQU0sSUFBSWMsV0FBV3pDO0lBQ3RFO0lBQ0EsTUFBTStILFNBQVM3SCxTQUFTLEVBQUV5QixHQUFHLEVBQUVxRyxTQUFTLEVBQUVoSSxJQUFJLEVBQUU7UUFDNUMsT0FBTzZULFNBQVNoSSxNQUFNLENBQUMzTCxXQUFXd0IsYUFBYUMsTUFBTSxJQUFJYyxXQUFXdUYsWUFBWSxJQUFJdkYsV0FBV3pDO0lBQ25HO0lBQ0EsTUFBTW1GLFlBQVk5QyxNQUFNLEVBQUVWLEdBQUcsRUFBRTtRQUMzQixPQUFPa1MsU0FBU3pSLFNBQVMsQ0FBQ0MsUUFBUVgsYUFBYUM7SUFDbkQ7SUFDQSxNQUFNeUQsWUFBWS9DLE1BQU0sRUFBRU8sT0FBTyxFQUFFMUMsU0FBUyxFQUFFRSxXQUFXLEVBQUU4QixTQUFTLEVBQUU7UUFDbEUsTUFBTVAsTUFBTSxNQUFNa1MsU0FBU2xSLFNBQVMsQ0FBQ04sUUFBUU8sU0FBUztZQUFFLEdBQUcxQyxTQUFTO1lBQUVDLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1FBQUMsR0FBR0MsYUFBYThCO1FBQ3RHLE9BQU9KLGFBQWFIO0lBQ3hCO0FBQ0o7QUFFQSxNQUFNdVMsdUJBQXVCalYsZ0JBQWdCaVYsY0FBYztJQUN2RCxNQUFNbFAsY0FBYzlFLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ25ELE1BQU0zRCxPQUFPLE1BQU1zVixTQUFTNVIsV0FBVyxDQUFDO1lBQ3BDOUIsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZjhQLFlBQVkvUCxVQUFVK1AsVUFBVSxDQUFDN08sV0FBVztRQUNoRCxHQUFHaEIsYUFBYThCO1FBQ2hCLE9BQU87WUFDSDRILFlBQVloSSxhQUFhdkQsS0FBS3VMLFVBQVU7WUFDeENXLFdBQVczSSxhQUFhdkQsS0FBS2tNLFNBQVM7UUFDMUM7SUFDSjtJQUNBLE1BQU0wSSxhQUFhalQsU0FBUyxFQUFFOFIsT0FBTyxFQUFFM1EsTUFBTSxFQUFFO1FBQzNDLE1BQU1tUixPQUFPLE1BQU1xQixTQUFTOUIsVUFBVSxDQUFDO1lBQUUsR0FBRzdSLFNBQVM7WUFBRXFTLFFBQVE3USxhQUFheEIsVUFBVXFTLE1BQU07UUFBRSxHQUFHN1EsYUFBYXNRLFVBQVUzUTtRQUN4SCxPQUFPbVI7SUFDWDtJQUNBLE1BQU1yTixZQUFZOUMsTUFBTSxFQUFFVixHQUFHLEVBQUU7UUFDM0IsT0FBT2tTLFNBQVN6UixTQUFTLENBQUNDLFFBQVFYLGFBQWFDO0lBQ25EO0lBQ0EsTUFBTXlELFlBQVkvQyxNQUFNLEVBQUVPLE9BQU8sRUFBRTFDLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ2xFLE1BQU1QLE1BQU0sTUFBTWtTLFNBQVNsUixTQUFTLENBQUNOLFFBQVFPLFNBQVM7WUFBRSxHQUFHMUMsU0FBUztZQUFFQyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtRQUFDLEdBQUdDLGFBQWE4QjtRQUN0RyxPQUFPSixhQUFhSDtJQUN4QjtBQUNKO0FBRUEsTUFBTXdTLHVCQUF1QnRVO0FBQzdCO0FBRUEsTUFBTXVVLHVCQUF1Qm5WLGdCQUFnQm1WLGNBQWM7SUFDdkQsTUFBTWpCLGFBQWFqVCxTQUFTLEVBQUU4UixPQUFPLEVBQUUzUSxNQUFNLEVBQUU7UUFDM0MsT0FBTyxJQUFJZ1QsUUFBUSxDQUFDQyxTQUFTQztZQUN6QixNQUFNQyxPQUFPdlYsZ0JBQWdCdVAscUJBQXFCLENBQUNvRCxhQUFhLENBQUMxUixVQUFVc1UsSUFBSTtZQUMvRSxNQUFNbEwsT0FBT3BKLFVBQVVvSixJQUFJLENBQUNuSixJQUFJLENBQUNvTyxPQUFPLENBQUMsS0FBSztZQUM5QzNRLE9BQU82VyxNQUFNLENBQUMvUyxhQUFhc1EsU0FBU2hTLElBQUksRUFBRVQsT0FBT0MsSUFBSSxDQUFDZ1YsT0FBT3RVLFVBQVV3VSxVQUFVLEVBQUVyVCxVQUFVLEdBQUdpSSxNQUFNLENBQUNxTCxLQUFLQztnQkFDeEcsSUFBSUQsS0FBSztvQkFDTEosT0FBT0k7Z0JBQ1gsT0FDSztvQkFDREwsUUFBUSxJQUFJN1IsV0FBV21TLGFBQWFsUyxNQUFNO2dCQUM5QztZQUNKO1FBQ0o7SUFDSjtJQUNBLE1BQU0wQyxZQUFZL0MsTUFBTSxFQUFFTyxPQUFPLEVBQUUxQyxTQUFTLEVBQUVFLFdBQVcsRUFBRThCLFNBQVMsRUFBRTtRQUNsRSxJQUFJRyxXQUFXLE9BQU87WUFDbEIsTUFBTVYsTUFBTSxJQUFJd1M7WUFDaEJ4UyxJQUFJM0IsSUFBSSxHQUFHVCxPQUFPQyxJQUFJLENBQUNvRDtZQUN2QmpCLElBQUl6QixTQUFTLEdBQUc7Z0JBQUVDLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQUM7WUFDbEN3QixJQUFJdkIsV0FBVyxHQUFHO1lBQ2xCdUIsSUFBSXJCLE1BQU0sR0FBRzRCO1lBQ2IsT0FBT0osYUFBYUg7UUFDeEI7UUFDQSxNQUFNLElBQUkxQyxnQkFBZ0I0QyxjQUFjLENBQUM7SUFDN0M7SUFDQXdELGVBQWUxRCxHQUFHLEVBQUUyRCxRQUFRLEVBQUU7UUFDMUIsS0FBSyxDQUFDRCxlQUFlMUQsS0FBSzJEO1FBQzFCLElBQUksQ0FBRTVELENBQUFBLGFBQWFDLGdCQUFnQndTLGNBQWEsR0FBSTtZQUNoRCxNQUFNLElBQUk1TyxVQUFVO1FBQ3hCO0lBQ0o7QUFDSjtBQUVBLE1BQU1zUCxzQkFBc0JoVjtJQUN4QixJQUFJVyxNQUFNO1FBQ04sTUFBTThJLE9BQU8sSUFBSSxDQUFDcEosU0FBUyxDQUFDb0osSUFBSSxDQUFDbkosSUFBSSxDQUFDaUIsV0FBVztRQUNqRCxPQUFPLENBQUMsRUFBRSxFQUFFa0ksS0FBS2lGLE9BQU8sQ0FBQyxRQUFRLElBQUksQ0FBQztJQUMxQztJQUNBLElBQUkvTixJQUFJbEIsS0FBSyxFQUFFLENBQ2Y7QUFDSjtBQUNBeEIsTUFBTTJDLFVBQVUsQ0FBQztJQUNiMUMsV0FBVzJDLFFBQVEsQ0FBQztRQUFFUCxNQUFNO1FBQUtvQixXQUFXbkM7SUFBdUI7Q0FDdEUsRUFBRXlWLGNBQWMvVCxTQUFTLEVBQUUsUUFBUSxLQUFLO0FBRXpDLE1BQU1nVSxxQkFBcUI3VixnQkFBZ0I2VixZQUFZO0lBQ25ELE1BQU05UCxjQUFjOUUsU0FBUyxFQUFFRSxXQUFXLEVBQUU4QixTQUFTLEVBQUU7UUFDbkQsTUFBTWIsU0FBUyxDQUFDbkIsVUFBVW1CLE1BQU0sSUFBSSxJQUFJLENBQUMwVCxnQkFBZ0IsQ0FBQzdVLFVBQVVvSixJQUFJLENBQUNuSixJQUFJLE1BQU0sS0FBSztRQUN4RixNQUFNd0IsTUFBTSxJQUFJa1Q7UUFDaEJsVCxJQUFJekIsU0FBUyxHQUFHO1lBQ1osR0FBR0EsU0FBUztZQUNabUI7WUFDQWxCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1FBQ25CO1FBQ0F3QixJQUFJdkIsV0FBVyxHQUFHQTtRQUNsQnVCLElBQUlyQixNQUFNLEdBQUc0QjtRQUNiUCxJQUFJM0IsSUFBSSxHQUFHcEMsT0FBT3VFLFdBQVcsQ0FBQ2QsVUFBVTtRQUN4QyxPQUFPUyxhQUFhSDtJQUN4QjtJQUNBLE1BQU1tRyxPQUFPNUgsU0FBUyxFQUFFeUIsR0FBRyxFQUFFM0IsSUFBSSxFQUFFO1FBQy9CLE1BQU1tTSxZQUFZb0IsVUFBVUUsZ0JBQWdCLENBQUM5TCxJQUFJekIsU0FBUyxDQUFDb0osSUFBSTtRQUMvRCxNQUFNMEwsT0FBT3BYLE9BQU9xWCxVQUFVLENBQUM5SSxXQUFXekssYUFBYUMsS0FBSzNCLElBQUksRUFDM0QrRCxNQUFNLENBQUN4RSxPQUFPQyxJQUFJLENBQUNRLE9BQU8wTixNQUFNO1FBQ3JDLE9BQU8sSUFBSWpMLFdBQVd1UyxNQUFNdFMsTUFBTTtJQUN0QztJQUNBLE1BQU1xRixTQUFTN0gsU0FBUyxFQUFFeUIsR0FBRyxFQUFFcUcsU0FBUyxFQUFFaEksSUFBSSxFQUFFO1FBQzVDLE1BQU1tTSxZQUFZb0IsVUFBVUUsZ0JBQWdCLENBQUM5TCxJQUFJekIsU0FBUyxDQUFDb0osSUFBSTtRQUMvRCxNQUFNMEwsT0FBT3BYLE9BQU9xWCxVQUFVLENBQUM5SSxXQUFXekssYUFBYUMsS0FBSzNCLElBQUksRUFDM0QrRCxNQUFNLENBQUN4RSxPQUFPQyxJQUFJLENBQUNRLE9BQU8wTixNQUFNO1FBQ3JDLE9BQU9zSCxLQUFLN00sT0FBTyxDQUFDNUksT0FBT0MsSUFBSSxDQUFDd0ksZ0JBQWdCO0lBQ3BEO0lBQ0EsTUFBTTVDLFlBQVkvQyxNQUFNLEVBQUVPLE9BQU8sRUFBRTFDLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ2xFLElBQUlQO1FBQ0osT0FBUVUsT0FBT0UsV0FBVztZQUN0QixLQUFLO2dCQUNEWixNQUFNNUQsV0FBVzhFLFVBQVUsQ0FBQ3hELFFBQVEsQ0FBQ3VELFNBQVM7b0JBQUVFLGNBQWMrUjtnQkFBYztnQkFDNUU7WUFDSixLQUFLO2dCQUNEbFQsTUFBTSxJQUFJa1Q7Z0JBQ1ZsVCxJQUFJM0IsSUFBSSxHQUFHVCxPQUFPQyxJQUFJLENBQUNvRDtnQkFDdkI7WUFDSjtnQkFDSSxNQUFNLElBQUkzRCxnQkFBZ0I0QyxjQUFjLENBQUM7UUFDakQ7UUFDQUYsSUFBSXpCLFNBQVMsR0FBRztZQUNab0osTUFBTTtnQkFBRW5KLE1BQU1ELFVBQVVvSixJQUFJLENBQUNuSixJQUFJO1lBQUM7WUFDbENBLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZrQixRQUFRTSxJQUFJM0IsSUFBSSxDQUFDcUIsTUFBTSxJQUFJO1FBQy9CO1FBQ0FNLElBQUl2QixXQUFXLEdBQUdBO1FBQ2xCdUIsSUFBSXJCLE1BQU0sR0FBRzRCO1FBQ2IsT0FBT0osYUFBYUg7SUFDeEI7SUFDQSxNQUFNd0QsWUFBWTlDLE1BQU0sRUFBRVYsR0FBRyxFQUFFO1FBQzNCLE9BQVFVLE9BQU9FLFdBQVc7WUFDdEIsS0FBSztnQkFDRCxPQUFPeEUsV0FBV3lFLGNBQWMsQ0FBQzdDLE1BQU0sQ0FBQytCLGFBQWFDO1lBQ3pELEtBQUs7Z0JBQ0QsT0FBTyxJQUFJYyxXQUFXZixhQUFhQyxLQUFLM0IsSUFBSSxFQUFFMEMsTUFBTTtZQUN4RDtnQkFDSSxNQUFNLElBQUl6RCxnQkFBZ0I0QyxjQUFjLENBQUM7UUFDakQ7SUFDSjtJQUNBd0QsZUFBZTFELEdBQUcsRUFBRTJELFFBQVEsRUFBRTtRQUMxQixLQUFLLENBQUNELGVBQWUxRCxLQUFLMkQ7UUFDMUIsSUFBSSxDQUFFNUQsQ0FBQUEsYUFBYUMsZ0JBQWdCa1QsYUFBWSxHQUFJO1lBQy9DLE1BQU0sSUFBSXRQLFVBQVU7UUFDeEI7SUFDSjtBQUNKO0FBRUEsTUFBTTJQLHNCQUFzQnJWO0FBQzVCO0FBRUEsTUFBTXNWLHFCQUFxQmxXLGdCQUFnQmtXLFlBQVk7SUFDbkQsTUFBTS9QLFlBQVkvQyxNQUFNLEVBQUVPLE9BQU8sRUFBRTFDLFNBQVMsRUFBRUUsV0FBVyxFQUFFOEIsU0FBUyxFQUFFO1FBQ2xFLElBQUlHLE9BQU9FLFdBQVcsT0FBTyxPQUFPO1lBQ2hDLE1BQU0sSUFBSXRELGdCQUFnQjRDLGNBQWMsQ0FBQztRQUM3QztRQUNBLE1BQU1GLE1BQU0sSUFBSXVUO1FBQ2hCdlQsSUFBSTNCLElBQUksR0FBR1QsT0FBT0MsSUFBSSxDQUFDb0Q7UUFDdkJqQixJQUFJekIsU0FBUyxHQUFHO1lBQUVDLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1FBQUM7UUFDbEN3QixJQUFJdkIsV0FBVyxHQUFHQTtRQUNsQnVCLElBQUlyQixNQUFNLEdBQUc0QjtRQUNiLE9BQU9KLGFBQWFIO0lBQ3hCO0lBQ0EsTUFBTXdSLGFBQWFpQyxNQUFNLEVBQUVwRCxPQUFPLEVBQUUzUSxNQUFNLEVBQUU7UUFDeEMsTUFBTWlJLE9BQU84TCxPQUFPOUwsSUFBSSxDQUFDbkosSUFBSSxDQUFDb08sT0FBTyxDQUFDLEtBQUs7UUFDM0MsTUFBTThHLGFBQWF6WCxPQUFPZ1EsVUFBVSxDQUFDdEUsTUFBTW9FLE1BQU0sR0FBR3JNLE1BQU07UUFDMUQsTUFBTTZKLGFBQWE3SixTQUFTO1FBQzVCLE1BQU1pVSxPQUFPNVgsS0FBSzhRLHFCQUFxQixDQUFDQyxZQUFZLENBQUMyRyxPQUFPRSxJQUFJO1FBQ2hFLE1BQU1DLE1BQU0zWCxPQUFPcVgsVUFBVSxDQUFDM0wsTUFBTTVMLEtBQUs4USxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDMkcsT0FBT1osSUFBSSxHQUNsRnpRLE1BQU0sQ0FBQ3JHLEtBQUs4USxxQkFBcUIsQ0FBQ0MsWUFBWSxDQUFDL00sYUFBYXNRLFNBQVNoUyxJQUFJLEdBQ3pFME4sTUFBTTtRQUNYLE1BQU04SCxTQUFTO1lBQUNqVyxPQUFPVSxLQUFLLENBQUM7U0FBRztRQUNoQyxNQUFNcUgsYUFBYXBCLEtBQUtxQixJQUFJLENBQUMyRCxhQUFhbUssY0FBYztRQUN4RCxJQUFLLElBQUl4RyxJQUFJLEdBQUdBLElBQUl2SCxZQUFZLEVBQUV1SCxFQUFHO1lBQ2pDMkcsT0FBT0MsSUFBSSxDQUFDN1gsT0FBT3FYLFVBQVUsQ0FBQzNMLE1BQU1pTSxLQUMvQnhSLE1BQU0sQ0FBQ3hFLE9BQU95RSxNQUFNLENBQUM7Z0JBQUN3UixNQUFNLENBQUMzRyxJQUFJLEVBQUU7Z0JBQUV5RztnQkFBTS9WLE9BQU9DLElBQUksQ0FBQztvQkFBQ3FQO2lCQUFFO2FBQUUsR0FDNURuQixNQUFNO1FBQ2Y7UUFDQSxPQUFPbk8sT0FBT3lFLE1BQU0sQ0FBQ3dSLFFBQVE3USxLQUFLLENBQUMsR0FBR3VHO0lBQzFDO0lBQ0E3RixlQUFlMUQsR0FBRyxFQUFFMkQsUUFBUSxFQUFFO1FBQzFCLEtBQUssQ0FBQ0QsZUFBZTFELEtBQUsyRDtRQUMxQixJQUFJLENBQUU1RCxDQUFBQSxhQUFhQyxnQkFBZ0J1VCxhQUFZLEdBQUk7WUFDL0MsTUFBTSxJQUFJM1AsVUFBVTtRQUN4QjtJQUNKO0FBQ0o7QUFFQSxNQUFNbVE7SUFDRixPQUFPaEksT0FBT3hOLFNBQVMsRUFBRUYsSUFBSSxFQUFFO1FBQzNCLE1BQU1zSixPQUFPMUwsT0FBT2dRLFVBQVUsQ0FBQzFOLFVBQVVDLElBQUksQ0FBQ29DLFdBQVcsSUFBSTtZQUFFb1QsY0FBY3pWLFVBQVVtQixNQUFNO1FBQUMsR0FDekYwQyxNQUFNLENBQUN4RSxPQUFPQyxJQUFJLENBQUNRLE9BQU8wTixNQUFNO1FBQ3JDLE9BQU8sSUFBSWpMLFdBQVc2RyxNQUFNNUcsTUFBTTtJQUN0QztBQUNKO0FBRUEsTUFBTWtULHlCQUF5QjNXLGdCQUFnQjJXLGdCQUFnQjtJQUMzRCxNQUFNbEYsU0FBU3hRLFNBQVMsRUFBRUYsSUFBSSxFQUFFO1FBQzVCLE9BQU8wVixZQUFZaEksTUFBTSxDQUFDeE4sV0FBV0Y7SUFDekM7QUFDSjtBQUVBLE1BQU02Vix5QkFBeUI1VyxnQkFBZ0I0VyxnQkFBZ0I7SUFDM0QsTUFBTW5GLFNBQVN4USxTQUFTLEVBQUVGLElBQUksRUFBRTtRQUM1QixPQUFPMFYsWUFBWWhJLE1BQU0sQ0FBQ3hOLFdBQVdGO0lBQ3pDO0FBQ0o7QUFFQSxNQUFNOFYscUJBQXFCN1csZ0JBQWdCNlcsWUFBWTtJQUNuRGhXLGFBQWM7UUFDVixJQUFJaVc7UUFDSixLQUFLO1FBQ0wsSUFBSSxDQUFDQyxTQUFTLENBQUNqVSxHQUFHLENBQUMsSUFBSWdEO1FBQ3ZCLElBQUksQ0FBQ2lSLFNBQVMsQ0FBQ2pVLEdBQUcsQ0FBQyxJQUFJcUc7UUFDdkIsSUFBSSxDQUFDNE4sU0FBUyxDQUFDalUsR0FBRyxDQUFDLElBQUlzRztRQUN2QixJQUFJLENBQUMyTixTQUFTLENBQUNqVSxHQUFHLENBQUMsSUFBSThGO1FBQ3ZCLElBQUksQ0FBQ21PLFNBQVMsQ0FBQ2pVLEdBQUcsQ0FBQyxJQUFJdUc7UUFDdkIsSUFBSSxDQUFDME4sU0FBUyxDQUFDalUsR0FBRyxDQUFDLElBQUl3RztRQUN2QixJQUFJLENBQUN5TixTQUFTLENBQUNqVSxHQUFHLENBQUMsSUFBSStHO1FBQ3ZCLElBQUksQ0FBQ2tOLFNBQVMsQ0FBQ2pVLEdBQUcsQ0FBQyxJQUFJbUg7UUFDdkIsSUFBSSxDQUFDOE0sU0FBUyxDQUFDalUsR0FBRyxDQUFDLElBQUlvTDtRQUN2QixJQUFJLENBQUM2SSxTQUFTLENBQUNqVSxHQUFHLENBQUMsSUFBSXVMO1FBQ3ZCLElBQUksQ0FBQzBJLFNBQVMsQ0FBQ2pVLEdBQUcsQ0FBQyxJQUFJOEw7UUFDdkIsSUFBSSxDQUFDbUksU0FBUyxDQUFDalUsR0FBRyxDQUFDLElBQUl5TjtRQUN2QixJQUFJLENBQUN3RyxTQUFTLENBQUNqVSxHQUFHLENBQUMsSUFBSWdSO1FBQ3ZCLElBQUksQ0FBQ2lELFNBQVMsQ0FBQ2pVLEdBQUcsQ0FBQyxJQUFJbVI7UUFDdkIsSUFBSSxDQUFDOEMsU0FBUyxDQUFDalUsR0FBRyxDQUFDLElBQUkwTztRQUN2QixJQUFJLENBQUN1RixTQUFTLENBQUNqVSxHQUFHLENBQUMsSUFBSTRPO1FBQ3ZCLElBQUksQ0FBQ3FGLFNBQVMsQ0FBQ2pVLEdBQUcsQ0FBQyxJQUFJNk87UUFDdkIsSUFBSSxDQUFDb0YsU0FBUyxDQUFDalUsR0FBRyxDQUFDLElBQUk4TztRQUN2QixJQUFJLENBQUNtRixTQUFTLENBQUNqVSxHQUFHLENBQUMsSUFBSXFTO1FBQ3ZCLElBQUksQ0FBQzRCLFNBQVMsQ0FBQ2pVLEdBQUcsQ0FBQyxJQUFJK1M7UUFDdkIsSUFBSSxDQUFDa0IsU0FBUyxDQUFDalUsR0FBRyxDQUFDLElBQUlvVDtRQUN2QixNQUFNYyxtQkFBbUIsQ0FBQ0YsS0FBSyxVQUFVMU0sSUFBSSxDQUFDbEssbUJBQW1CK1csT0FBTyxPQUFPLFFBQVFILE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsRUFBRSxDQUFDLEVBQUU7UUFDckgsSUFBSUUsb0JBQW9CRSxTQUFTRixrQkFBa0IsT0FBTyxJQUFJO1lBQzFELElBQUksQ0FBQ0QsU0FBUyxDQUFDalUsR0FBRyxDQUFDLElBQUk2VDtZQUN2QixJQUFJLENBQUNJLFNBQVMsQ0FBQ2pVLEdBQUcsQ0FBQyxJQUFJOFQ7UUFDM0I7UUFDQSxNQUFNTyxTQUFTbFgsa0JBQWtCbVgsU0FBUztRQUMxQyxJQUFJRCxPQUFPRSxRQUFRLENBQUMsYUFBYTtZQUM3QixJQUFJLENBQUNOLFNBQVMsQ0FBQ2pVLEdBQUcsQ0FBQyxJQUFJK087UUFDM0I7UUFDQSxJQUFJc0YsT0FBT0UsUUFBUSxDQUFDLGFBQWE7WUFDN0IsSUFBSSxDQUFDTixTQUFTLENBQUNqVSxHQUFHLENBQUMsSUFBSWdQO1FBQzNCO1FBQ0EsSUFBSXFGLE9BQU9FLFFBQVEsQ0FBQyxhQUFhO1lBQzdCLElBQUksQ0FBQ04sU0FBUyxDQUFDalUsR0FBRyxDQUFDLElBQUlpUDtRQUMzQjtRQUNBLElBQUlpRixvQkFBb0JFLFNBQVNGLGtCQUFrQixPQUFPLElBQUk7WUFDMUQsSUFBSSxDQUFDRCxTQUFTLENBQUNqVSxHQUFHLENBQUMsSUFBSWtTO1lBQ3ZCLElBQUksQ0FBQytCLFNBQVMsQ0FBQ2pVLEdBQUcsQ0FBQyxJQUFJbVM7UUFDM0I7SUFDSjtBQUNKO0FBRUEsTUFBTXFDLGVBQWV0WCxnQkFBZ0JzWCxNQUFNO0lBQ3ZDelcsYUFBYztRQUNWLEtBQUssSUFBSUM7UUFDVCxJQUFJLENBQUN5VyxNQUFNLEdBQUcsSUFBSVY7SUFDdEI7SUFDQVcsZ0JBQWdCQyxLQUFLLEVBQUU7UUFDbkIsSUFBSSxDQUFDQyxZQUFZQyxNQUFNLENBQUNGLFFBQVE7WUFDNUIsTUFBTSxJQUFJblIsVUFBVTtRQUN4QjtRQUNBLE1BQU03QyxTQUFTbkQsT0FBT0MsSUFBSSxDQUFDa1gsTUFBTWhVLE1BQU0sRUFBRWdVLE1BQU1HLFVBQVUsRUFBRUgsTUFBTXhMLFVBQVU7UUFDM0V0TixPQUFPOFEsY0FBYyxDQUFDaE07UUFDdEIsT0FBT2dVO0lBQ1g7QUFDSjtBQUVBclksNkNBQTRDO0lBQzFDUyxZQUFZO0lBQ1pELEtBQUs7UUFBYyxPQUFPbkIsS0FBS21DLFNBQVM7SUFBRTtBQUM1QyxDQUFDLEVBQUM7QUFDRmlYLGNBQWMsR0FBR1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1tYWtldHBsYWNlLWFkbWluLy4vbm9kZV9tb2R1bGVzL0BwZWN1bGlhci93ZWJjcnlwdG8vYnVpbGQvd2ViY3J5cHRvLmpzP2QwMzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gQ29weXJpZ2h0IChjKSBQZWN1bGlhciBWZW50dXJlcywgTExDXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnd2ViY3J5cHRvLWNvcmUnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBwcm9jZXNzID0gcmVxdWlyZSgncHJvY2VzcycpO1xudmFyIHRzbGliID0gcmVxdWlyZSgndHNsaWInKTtcbnZhciBqc29uU2NoZW1hID0gcmVxdWlyZSgnQHBlY3VsaWFyL2pzb24tc2NoZW1hJyk7XG52YXIgcHZ0c3V0aWxzID0gcmVxdWlyZSgncHZ0c3V0aWxzJyk7XG52YXIgYXNuMVNjaGVtYSA9IHJlcXVpcmUoJ0BwZWN1bGlhci9hc24xLXNjaGVtYScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoZSkge1xuICB2YXIgbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmIChlKSB7XG4gICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xuICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVba107IH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbi5kZWZhdWx0ID0gZTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBjb3JlX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0KGNvcmUpO1xudmFyIGNyeXB0b19fbmFtZXNwYWNlID0gLyojX19QVVJFX18qL19pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChjcnlwdG8pO1xudmFyIHByb2Nlc3NfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZURlZmF1bHQocHJvY2Vzcyk7XG5cbmNvbnN0IEpzb25CYXNlNjRVcmxDb252ZXJ0ZXIgPSB7XHJcbiAgICBmcm9tSlNPTjogKHZhbHVlKSA9PiBCdWZmZXIuZnJvbShwdnRzdXRpbHMuQ29udmVydC5Gcm9tQmFzZTY0VXJsKHZhbHVlKSksXHJcbiAgICB0b0pTT046ICh2YWx1ZSkgPT4gcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwodmFsdWUpLFxyXG59O1xuXG5jbGFzcyBDcnlwdG9LZXkgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuQ3J5cHRvS2V5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZmVyLmFsbG9jKDApO1xyXG4gICAgICAgIHRoaXMuYWxnb3JpdGhtID0geyBuYW1lOiBcIlwiIH07XHJcbiAgICAgICAgdGhpcy5leHRyYWN0YWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwic2VjcmV0XCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmt0eSA9IFwib2N0XCI7XHJcbiAgICAgICAgdGhpcy5hbGcgPSBcIlwiO1xyXG4gICAgfVxyXG59XHJcbnRzbGliLl9fZGVjb3JhdGUoW1xyXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwiZXh0XCIsIHR5cGU6IGpzb25TY2hlbWEuSnNvblByb3BUeXBlcy5Cb29sZWFuLCBvcHRpb25hbDogdHJ1ZSB9KVxyXG5dLCBDcnlwdG9LZXkucHJvdG90eXBlLCBcImV4dHJhY3RhYmxlXCIsIHZvaWQgMCk7XHJcbnRzbGliLl9fZGVjb3JhdGUoW1xyXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwia2V5X29wc1wiLCB0eXBlOiBqc29uU2NoZW1hLkpzb25Qcm9wVHlwZXMuU3RyaW5nLCByZXBlYXRlZDogdHJ1ZSwgb3B0aW9uYWw6IHRydWUgfSlcclxuXSwgQ3J5cHRvS2V5LnByb3RvdHlwZSwgXCJ1c2FnZXNcIiwgdm9pZCAwKTtcclxudHNsaWIuX19kZWNvcmF0ZShbXHJcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgdHlwZToganNvblNjaGVtYS5Kc29uUHJvcFR5cGVzLlN0cmluZyB9KVxyXG5dLCBDcnlwdG9LZXkucHJvdG90eXBlLCBcImt0eVwiLCB2b2lkIDApO1xyXG50c2xpYi5fX2RlY29yYXRlKFtcclxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyB0eXBlOiBqc29uU2NoZW1hLkpzb25Qcm9wVHlwZXMuU3RyaW5nLCBvcHRpb25hbDogdHJ1ZSB9KVxyXG5dLCBDcnlwdG9LZXkucHJvdG90eXBlLCBcImFsZ1wiLCB2b2lkIDApO1xuXG5jbGFzcyBTeW1tZXRyaWNLZXkgZXh0ZW5kcyBDcnlwdG9LZXkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmt0eSA9IFwib2N0XCI7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJzZWNyZXRcIjtcclxuICAgIH1cclxufVxuXG5jbGFzcyBBc3ltbWV0cmljS2V5IGV4dGVuZHMgQ3J5cHRvS2V5IHtcclxufVxuXG5jbGFzcyBBZXNDcnlwdG9LZXkgZXh0ZW5kcyBTeW1tZXRyaWNLZXkge1xyXG4gICAgZ2V0IGFsZygpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBBJHt0aGlzLmFsZ29yaXRobS5sZW5ndGh9Q0JDYDtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1DVFJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBgQSR7dGhpcy5hbGdvcml0aG0ubGVuZ3RofUNUUmA7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtR0NNXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYEEke3RoaXMuYWxnb3JpdGhtLmxlbmd0aH1HQ01gO1xyXG4gICAgICAgICAgICBjYXNlIFwiQUVTLUtXXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYEEke3RoaXMuYWxnb3JpdGhtLmxlbmd0aH1LV2A7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtQ01BQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGBBJHt0aGlzLmFsZ29yaXRobS5sZW5ndGh9Q01BQ2A7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtRUNCXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYEEke3RoaXMuYWxnb3JpdGhtLmxlbmd0aH1FQ0JgO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5BbGdvcml0aG1FcnJvcihcIlVuc3VwcG9ydGVkIGFsZ29yaXRobSBuYW1lXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNldCBhbGcodmFsdWUpIHtcclxuICAgIH1cclxufVxyXG50c2xpYi5fX2RlY29yYXRlKFtcclxuICAgIGpzb25TY2hlbWEuSnNvblByb3AoeyBuYW1lOiBcImtcIiwgY29udmVydGVyOiBKc29uQmFzZTY0VXJsQ29udmVydGVyIH0pXHJcbl0sIEFlc0NyeXB0b0tleS5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuXG5jb25zdCBrZXlTdG9yYWdlID0gbmV3IFdlYWtNYXAoKTtcclxuZnVuY3Rpb24gZ2V0Q3J5cHRvS2V5KGtleSkge1xyXG4gICAgY29uc3QgcmVzID0ga2V5U3RvcmFnZS5nZXQoa2V5KTtcclxuICAgIGlmICghcmVzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcIkNhbm5vdCBnZXQgQ3J5cHRvS2V5IGZyb20gc2VjdXJlIHN0b3JhZ2VcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIHNldENyeXB0b0tleSh2YWx1ZSkge1xyXG4gICAgY29uc3Qga2V5ID0gY29yZV9fbmFtZXNwYWNlLkNyeXB0b0tleS5jcmVhdGUodmFsdWUuYWxnb3JpdGhtLCB2YWx1ZS50eXBlLCB2YWx1ZS5leHRyYWN0YWJsZSwgdmFsdWUudXNhZ2VzKTtcclxuICAgIE9iamVjdC5mcmVlemUoa2V5KTtcclxuICAgIGtleVN0b3JhZ2Uuc2V0KGtleSwgdmFsdWUpO1xyXG4gICAgcmV0dXJuIGtleTtcclxufVxuXG5jbGFzcyBBZXNDcnlwdG8ge1xyXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBBZXNDcnlwdG9LZXkoKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAga2V5LmRhdGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoYWxnb3JpdGhtLmxlbmd0aCA+PiAzKTtcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIGlmICghKGtleSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwia2V5OiBJcyBub3QgQWVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpO1xyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoa2V5LmRhdGEpLmJ1ZmZlcjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycgb3IgJ3JhdydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGxldCBrZXk7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oa2V5RGF0YSwgeyB0YXJnZXRTY2hlbWE6IEFlc0NyeXB0b0tleSB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBuZXcgQWVzQ3J5cHRvS2V5KCk7XHJcbiAgICAgICAgICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGtleURhdGEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snIG9yICdyYXcnXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xyXG4gICAgICAgIGtleS5hbGdvcml0aG0ubGVuZ3RoID0ga2V5LmRhdGEubGVuZ3RoIDw8IDM7XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICBzd2l0Y2ggKGtleS5hbGdvcml0aG0ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTI4OlxyXG4gICAgICAgICAgICBjYXNlIDE5MjpcclxuICAgICAgICAgICAgY2FzZSAyNTY6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJrZXlEYXRhOiBJcyB3cm9uZyBrZXkgbGVuZ3RoXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRBZXNDQkMoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1DVFJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRBZXNDVFIoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1HQ01cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRBZXNHQ00oYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1LV1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jcnlwdEFlc0tXKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtRUNCXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0QWVzRUNCKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGlmICghKGtleSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwia2V5OiBJcyBub3QgQWVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRBZXNDQkMoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1DVFJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRBZXNDVFIoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1HQ01cIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHRBZXNHQ00oYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkFFUy1LV1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdEFlc0tXKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJBRVMtRUNCXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0QWVzRUNCKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdEFlc0NCQyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWNiY2AsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheShhbGdvcml0aG0uaXYpKTtcclxuICAgICAgICBsZXQgZW5jID0gY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBlbmMgPSBCdWZmZXIuY29uY2F0KFtlbmMsIGNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0QWVzQ0JDKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWNiY2AsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheShhbGdvcml0aG0uaXYpKTtcclxuICAgICAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGRlYyA9IEJ1ZmZlci5jb25jYXQoW2RlYywgZGVjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0QWVzQ1RSKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tY3RyYCwga2V5LmRhdGEsIEJ1ZmZlci5mcm9tKGFsZ29yaXRobS5jb3VudGVyKSk7XHJcbiAgICAgICAgbGV0IGVuYyA9IGNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZW5jID0gQnVmZmVyLmNvbmNhdChbZW5jLCBjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGVuYykuYnVmZmVyO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdEFlc0NUUihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1jdHJgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLmNvdW50ZXIpKTtcclxuICAgICAgICBsZXQgZGVjID0gZGVjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGRlYyA9IEJ1ZmZlci5jb25jYXQoW2RlYywgZGVjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0QWVzR0NNKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGBhZXMtJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0tZ2NtYCwga2V5LmRhdGEsIEJ1ZmZlci5mcm9tKGFsZ29yaXRobS5pdiksIHtcclxuICAgICAgICAgICAgYXV0aFRhZ0xlbmd0aDogKGFsZ29yaXRobS50YWdMZW5ndGggfHwgMTI4KSA+PiAzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChhbGdvcml0aG0uYWRkaXRpb25hbERhdGEpIHtcclxuICAgICAgICAgICAgY2lwaGVyLnNldEFBRChCdWZmZXIuZnJvbShhbGdvcml0aG0uYWRkaXRpb25hbERhdGEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGVuYyA9IGNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZW5jID0gQnVmZmVyLmNvbmNhdChbZW5jLCBjaXBoZXIuZmluYWwoKSwgY2lwaGVyLmdldEF1dGhUYWcoKV0pO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGVuYykuYnVmZmVyO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdEFlc0dDTShhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1nY21gLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLml2KSk7XHJcbiAgICAgICAgY29uc3QgdGFnTGVuZ3RoID0gKGFsZ29yaXRobS50YWdMZW5ndGggfHwgMTI4KSA+PiAzO1xyXG4gICAgICAgIGNvbnN0IGVuYyA9IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSB0YWdMZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IHRhZyA9IGRhdGEuc2xpY2UoZGF0YS5sZW5ndGggLSB0YWdMZW5ndGgpO1xyXG4gICAgICAgIGlmIChhbGdvcml0aG0uYWRkaXRpb25hbERhdGEpIHtcclxuICAgICAgICAgICAgZGVjaXBoZXIuc2V0QUFEKEJ1ZmZlci5mcm9tKGFsZ29yaXRobS5hZGRpdGlvbmFsRGF0YSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWNpcGhlci5zZXRBdXRoVGFnKHRhZyk7XHJcbiAgICAgICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShlbmMpO1xyXG4gICAgICAgIGRlYyA9IEJ1ZmZlci5jb25jYXQoW2RlYywgZGVjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShkZWMpLmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0QWVzS1coYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoYGlkLWFlcyR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LXdyYXBgLCBrZXkuZGF0YSwgdGhpcy5BRVNfS1dfSVYpO1xyXG4gICAgICAgIGxldCBlbmMgPSBjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGVuYyA9IEJ1ZmZlci5jb25jYXQoW2VuYywgY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdEFlc0tXKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihgaWQtYWVzJHtrZXkuYWxnb3JpdGhtLmxlbmd0aH0td3JhcGAsIGtleS5kYXRhLCB0aGlzLkFFU19LV19JVik7XHJcbiAgICAgICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBkZWMgPSBCdWZmZXIuY29uY2F0KFtkZWMsIGRlY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdEFlc0VDQihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihgYWVzLSR7a2V5LmFsZ29yaXRobS5sZW5ndGh9LWVjYmAsIGtleS5kYXRhLCBuZXcgVWludDhBcnJheSgwKSk7XHJcbiAgICAgICAgbGV0IGVuYyA9IGNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZW5jID0gQnVmZmVyLmNvbmNhdChbZW5jLCBjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGVuYykuYnVmZmVyO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdEFlc0VDQihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoYGFlcy0ke2tleS5hbGdvcml0aG0ubGVuZ3RofS1lY2JgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoMCkpO1xyXG4gICAgICAgIGxldCBkZWMgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZGVjID0gQnVmZmVyLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xyXG4gICAgfVxyXG59XHJcbkFlc0NyeXB0by5BRVNfS1dfSVYgPSBCdWZmZXIuZnJvbShcIkE2QTZBNkE2QTZBNkE2QTZcIiwgXCJoZXhcIik7XG5cbmNsYXNzIEFlc0NiY1Byb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkFlc0NiY1Byb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgQWVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IGFsZ29yaXRobS5sZW5ndGgsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5lbmNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZGVjcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBBZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIEFlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY29uc3QgemVybyA9IEJ1ZmZlci5mcm9tKFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSk7XHJcbmNvbnN0IHJiID0gQnVmZmVyLmZyb20oWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEzNV0pO1xyXG5jb25zdCBibG9ja1NpemUgPSAxNjtcclxuZnVuY3Rpb24gYml0U2hpZnRMZWZ0KGJ1ZmZlcikge1xyXG4gICAgY29uc3Qgc2hpZnRlZCA9IEJ1ZmZlci5hbGxvYyhidWZmZXIubGVuZ3RoKTtcclxuICAgIGNvbnN0IGxhc3QgPSBidWZmZXIubGVuZ3RoIC0gMTtcclxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsYXN0OyBpbmRleCsrKSB7XHJcbiAgICAgICAgc2hpZnRlZFtpbmRleF0gPSBidWZmZXJbaW5kZXhdIDw8IDE7XHJcbiAgICAgICAgaWYgKGJ1ZmZlcltpbmRleCArIDFdICYgMHg4MCkge1xyXG4gICAgICAgICAgICBzaGlmdGVkW2luZGV4XSArPSAweDAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNoaWZ0ZWRbbGFzdF0gPSBidWZmZXJbbGFzdF0gPDwgMTtcclxuICAgIHJldHVybiBzaGlmdGVkO1xyXG59XHJcbmZ1bmN0aW9uIHhvcihhLCBiKSB7XHJcbiAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xyXG4gICAgY29uc3Qgb3V0cHV0ID0gQnVmZmVyLmFsbG9jKGxlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgb3V0cHV0W2luZGV4XSA9IGFbaW5kZXhdIF4gYltpbmRleF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59XHJcbmZ1bmN0aW9uIGFlcyhrZXksIG1lc3NhZ2UpIHtcclxuICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0b19fbmFtZXNwYWNlLmNyZWF0ZUNpcGhlcml2KGBhZXMke2tleS5sZW5ndGggPDwgM31gLCBrZXksIHplcm8pO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gY2lwaGVyLnVwZGF0ZShtZXNzYWdlKTtcclxuICAgIGNpcGhlci5maW5hbCgpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5mdW5jdGlvbiBnZXRNZXNzYWdlQmxvY2sobWVzc2FnZSwgYmxvY2tJbmRleCkge1xyXG4gICAgY29uc3QgYmxvY2sgPSBCdWZmZXIuYWxsb2MoYmxvY2tTaXplKTtcclxuICAgIGNvbnN0IHN0YXJ0ID0gYmxvY2tJbmRleCAqIGJsb2NrU2l6ZTtcclxuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgYmxvY2tTaXplO1xyXG4gICAgbWVzc2FnZS5jb3B5KGJsb2NrLCAwLCBzdGFydCwgZW5kKTtcclxuICAgIHJldHVybiBibG9jaztcclxufVxyXG5mdW5jdGlvbiBnZXRQYWRkZWRNZXNzYWdlQmxvY2sobWVzc2FnZSwgYmxvY2tJbmRleCkge1xyXG4gICAgY29uc3QgYmxvY2sgPSBCdWZmZXIuYWxsb2MoYmxvY2tTaXplKTtcclxuICAgIGNvbnN0IHN0YXJ0ID0gYmxvY2tJbmRleCAqIGJsb2NrU2l6ZTtcclxuICAgIGNvbnN0IGVuZCA9IG1lc3NhZ2UubGVuZ3RoO1xyXG4gICAgYmxvY2suZmlsbCgwKTtcclxuICAgIG1lc3NhZ2UuY29weShibG9jaywgMCwgc3RhcnQsIGVuZCk7XHJcbiAgICBibG9ja1tlbmQgLSBzdGFydF0gPSAweDgwO1xyXG4gICAgcmV0dXJuIGJsb2NrO1xyXG59XHJcbmZ1bmN0aW9uIGdlbmVyYXRlU3Via2V5cyhrZXkpIHtcclxuICAgIGNvbnN0IGwgPSBhZXMoa2V5LCB6ZXJvKTtcclxuICAgIGxldCBzdWJrZXkxID0gYml0U2hpZnRMZWZ0KGwpO1xyXG4gICAgaWYgKGxbMF0gJiAweDgwKSB7XHJcbiAgICAgICAgc3Via2V5MSA9IHhvcihzdWJrZXkxLCByYik7XHJcbiAgICB9XHJcbiAgICBsZXQgc3Via2V5MiA9IGJpdFNoaWZ0TGVmdChzdWJrZXkxKTtcclxuICAgIGlmIChzdWJrZXkxWzBdICYgMHg4MCkge1xyXG4gICAgICAgIHN1YmtleTIgPSB4b3Ioc3Via2V5MiwgcmIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgc3Via2V5MSwgc3Via2V5MiB9O1xyXG59XHJcbmZ1bmN0aW9uIGFlc0NtYWMoa2V5LCBtZXNzYWdlKSB7XHJcbiAgICBjb25zdCBzdWJrZXlzID0gZ2VuZXJhdGVTdWJrZXlzKGtleSk7XHJcbiAgICBsZXQgYmxvY2tDb3VudCA9IE1hdGguY2VpbChtZXNzYWdlLmxlbmd0aCAvIGJsb2NrU2l6ZSk7XHJcbiAgICBsZXQgbGFzdEJsb2NrQ29tcGxldGVGbGFnO1xyXG4gICAgbGV0IGxhc3RCbG9jaztcclxuICAgIGlmIChibG9ja0NvdW50ID09PSAwKSB7XHJcbiAgICAgICAgYmxvY2tDb3VudCA9IDE7XHJcbiAgICAgICAgbGFzdEJsb2NrQ29tcGxldGVGbGFnID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsYXN0QmxvY2tDb21wbGV0ZUZsYWcgPSAobWVzc2FnZS5sZW5ndGggJSBibG9ja1NpemUgPT09IDApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGFzdEJsb2NrSW5kZXggPSBibG9ja0NvdW50IC0gMTtcclxuICAgIGlmIChsYXN0QmxvY2tDb21wbGV0ZUZsYWcpIHtcclxuICAgICAgICBsYXN0QmxvY2sgPSB4b3IoZ2V0TWVzc2FnZUJsb2NrKG1lc3NhZ2UsIGxhc3RCbG9ja0luZGV4KSwgc3Via2V5cy5zdWJrZXkxKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxhc3RCbG9jayA9IHhvcihnZXRQYWRkZWRNZXNzYWdlQmxvY2sobWVzc2FnZSwgbGFzdEJsb2NrSW5kZXgpLCBzdWJrZXlzLnN1YmtleTIpO1xyXG4gICAgfVxyXG4gICAgbGV0IHggPSB6ZXJvO1xyXG4gICAgbGV0IHk7XHJcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGFzdEJsb2NrSW5kZXg7IGluZGV4KyspIHtcclxuICAgICAgICB5ID0geG9yKHgsIGdldE1lc3NhZ2VCbG9jayhtZXNzYWdlLCBpbmRleCkpO1xyXG4gICAgICAgIHggPSBhZXMoa2V5LCB5KTtcclxuICAgIH1cclxuICAgIHkgPSB4b3IobGFzdEJsb2NrLCB4KTtcclxuICAgIHJldHVybiBhZXMoa2V5LCB5KTtcclxufVxyXG5jbGFzcyBBZXNDbWFjUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuQWVzQ21hY1Byb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgQWVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IGFsZ29yaXRobS5sZW5ndGgsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25TaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYWVzQ21hYyhnZXRDcnlwdG9LZXkoa2V5KS5kYXRhLCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25WZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZTIgPSBhd2FpdCB0aGlzLnNpZ24oYWxnb3JpdGhtLCBrZXksIGRhdGEpO1xyXG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzaWduYXR1cmUpLmNvbXBhcmUoQnVmZmVyLmZyb20oc2lnbmF0dXJlMikpID09PSAwO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgQWVzQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgbmFtZTogYWxnb3JpdGhtLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShyZXMpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEFlc0N0clByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkFlc0N0clByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgQWVzQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgICAgICBsZW5ndGg6IGFsZ29yaXRobS5sZW5ndGgsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5lbmNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZGVjcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBBZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KHJlcyk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBBZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIEFlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgQWVzR2NtUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuQWVzR2NtUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmVuY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5kZWNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IEFlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IGFsZ29yaXRobS5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkocmVzKTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IGEgQWVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBBZXNLd1Byb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkFlc0t3UHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBBZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDogYWxnb3JpdGhtLmxlbmd0aCxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KHJlcyk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBBZXNDcnlwdG8uaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgeyBuYW1lOiBhbGdvcml0aG0ubmFtZSB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KHJlcyk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmVuY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEFlc0NyeXB0by5kZWNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEFlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IGEgQWVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5jbGFzcyBBZXNFY2JQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5BZXNFY2JQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEFlc0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiBhbGdvcml0aG0ubGVuZ3RoLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBBZXNDcnlwdG8uZW5jcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmRlY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gQWVzQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgQWVzQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgbmFtZTogYWxnb3JpdGhtLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShyZXMpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgQWVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBBZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIERlc0NyeXB0b0tleSBleHRlbmRzIFN5bW1ldHJpY0tleSB7XHJcbiAgICBnZXQgYWxnKCkge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5hbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJERVMtQ0JDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYERFUy1DQkNgO1xyXG4gICAgICAgICAgICBjYXNlIFwiREVTLUVERTMtQ0JDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYDNERVMtQ0JDYDtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuQWxnb3JpdGhtRXJyb3IoXCJVbnN1cHBvcnRlZCBhbGdvcml0aG0gbmFtZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXQgYWxnKHZhbHVlKSB7XHJcbiAgICB9XHJcbn1cclxudHNsaWIuX19kZWNvcmF0ZShbXHJcbiAgICBqc29uU2NoZW1hLkpzb25Qcm9wKHsgbmFtZTogXCJrXCIsIGNvbnZlcnRlcjogSnNvbkJhc2U2NFVybENvbnZlcnRlciB9KVxyXG5dLCBEZXNDcnlwdG9LZXkucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcblxuY2xhc3MgRGVzQ3J5cHRvIHtcclxuICAgIHN0YXRpYyBhc3luYyBnZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgRGVzQ3J5cHRvS2V5KCk7XHJcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IGFsZ29yaXRobTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIGtleS5kYXRhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGFsZ29yaXRobS5sZW5ndGggPj4gMyk7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBleHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpO1xyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoa2V5LmRhdGEpLmJ1ZmZlcjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycgb3IgJ3JhdydcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGxldCBrZXk7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oa2V5RGF0YSwgeyB0YXJnZXRTY2hlbWE6IERlc0NyeXB0b0tleSB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBuZXcgRGVzQ3J5cHRvS2V5KCk7XHJcbiAgICAgICAgICAgICAgICBrZXkuZGF0YSA9IEJ1ZmZlci5mcm9tKGtleURhdGEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snIG9yICdyYXcnXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIGtleTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJERVMtQ0JDXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNyeXB0RGVzQ0JDKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJERVMtRURFMy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHREZXNFREUzQ0JDKGFsZ29yaXRobSwga2V5LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGlmICghKGtleSBpbnN0YW5jZW9mIERlc0NyeXB0b0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwia2V5OiBJcyBub3QgRGVzQ3J5cHRvS2V5XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIkRFUy1DQkNcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY3J5cHREZXNDQkMoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgY2FzZSBcIkRFUy1FREUzLUNCQ1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdERlc0VERTNDQkMoYWxnb3JpdGhtLCBrZXksIEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBlbmNyeXB0RGVzQ0JDKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGBkZXMtY2JjYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KGFsZ29yaXRobS5pdikpO1xyXG4gICAgICAgIGxldCBlbmMgPSBjaXBoZXIudXBkYXRlKGRhdGEpO1xyXG4gICAgICAgIGVuYyA9IEJ1ZmZlci5jb25jYXQoW2VuYywgY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShlbmMpLmJ1ZmZlcjtcclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGRlY3J5cHREZXNDQkMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBkZXMtY2JjYCwga2V5LmRhdGEsIG5ldyBVaW50OEFycmF5KGFsZ29yaXRobS5pdikpO1xyXG4gICAgICAgIGxldCBkZWMgPSBkZWNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZGVjID0gQnVmZmVyLmNvbmNhdChbZGVjLCBkZWNpcGhlci5maW5hbCgpXSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGVuY3J5cHREZXNFREUzQ0JDKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KGBkZXMtZWRlMy1jYmNgLCBrZXkuZGF0YSwgQnVmZmVyLmZyb20oYWxnb3JpdGhtLml2KSk7XHJcbiAgICAgICAgbGV0IGVuYyA9IGNpcGhlci51cGRhdGUoZGF0YSk7XHJcbiAgICAgICAgZW5jID0gQnVmZmVyLmNvbmNhdChbZW5jLCBjaXBoZXIuZmluYWwoKV0pO1xyXG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGVuYykuYnVmZmVyO1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVjcnlwdERlc0VERTNDQkMoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KGBkZXMtZWRlMy1jYmNgLCBrZXkuZGF0YSwgbmV3IFVpbnQ4QXJyYXkoYWxnb3JpdGhtLml2KSk7XHJcbiAgICAgICAgbGV0IGRlYyA9IGRlY2lwaGVyLnVwZGF0ZShkYXRhKTtcclxuICAgICAgICBkZWMgPSBCdWZmZXIuY29uY2F0KFtkZWMsIGRlY2lwaGVyLmZpbmFsKCldKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGVjKS5idWZmZXI7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRGVzQ2JjUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuRGVzUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmtleVNpemVCaXRzID0gNjQ7XHJcbiAgICAgICAgdGhpcy5pdlNpemUgPSA4O1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiREVTLUNCQ1wiO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBEZXNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgICAgIGxlbmd0aDogdGhpcy5rZXlTaXplQml0cyxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gRGVzQ3J5cHRvLmVuY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIERlc0NyeXB0by5kZWNyeXB0KGFsZ29yaXRobSwgZ2V0Q3J5cHRvS2V5KGtleSksIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIERlc0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IERlc0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IG5hbWU6IHRoaXMubmFtZSwgbGVuZ3RoOiB0aGlzLmtleVNpemVCaXRzIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIGlmIChrZXkuZGF0YS5sZW5ndGggIT09ICh0aGlzLmtleVNpemVCaXRzID4+IDMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJrZXlEYXRhOiBXcm9uZyBrZXkgc2l6ZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgRGVzQ3J5cHRvS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgYSBEZXNDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIERlc0VkZTNDYmNQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5EZXNQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMua2V5U2l6ZUJpdHMgPSAxOTI7XHJcbiAgICAgICAgdGhpcy5pdlNpemUgPSA4O1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiREVTLUVERTMtQ0JDXCI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IERlc0NyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLmtleVNpemVCaXRzLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBEZXNDcnlwdG8uZW5jcnlwdChhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gRGVzQ3J5cHRvLmRlY3J5cHQoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gRGVzQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgRGVzQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgbmFtZTogdGhpcy5uYW1lLCBsZW5ndGg6IHRoaXMua2V5U2l6ZUJpdHMgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgaWYgKGtleS5kYXRhLmxlbmd0aCAhPT0gKHRoaXMua2V5U2l6ZUJpdHMgPj4gMykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImtleURhdGE6IFdyb25nIGtleSBzaXplXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKSB7XHJcbiAgICAgICAgc3VwZXIuY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSk7XHJcbiAgICAgICAgaWYgKCEoZ2V0Q3J5cHRvS2V5KGtleSkgaW5zdGFuY2VvZiBEZXNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBhIERlc0NyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gZ2V0SndrQWxnb3JpdGhtKGFsZ29yaXRobSkge1xyXG4gICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgY2FzZSBcIlJTQS1PQUVQXCI6IHtcclxuICAgICAgICAgICAgY29uc3QgbWRTaXplID0gLyhcXGQrKSQvLmV4ZWMoYWxnb3JpdGhtLmhhc2gubmFtZSlbMV07XHJcbiAgICAgICAgICAgIHJldHVybiBgUlNBLU9BRVAke21kU2l6ZSAhPT0gXCIxXCIgPyBgLSR7bWRTaXplfWAgOiBcIlwifWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJSU0FTU0EtUEtDUzEtVjFfNVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gYFJTJHsvKFxcZCspJC8uZXhlYyhhbGdvcml0aG0uaGFzaC5uYW1lKVsxXX1gO1xyXG4gICAgICAgIGNhc2UgXCJSU0EtUFNTXCI6XHJcbiAgICAgICAgICAgIHJldHVybiBgUFMkey8oXFxkKykkLy5leGVjKGFsZ29yaXRobS5oYXNoLm5hbWUpWzFdfWA7XHJcbiAgICAgICAgY2FzZSBcIlJTQS1QS0NTMVwiOlxyXG4gICAgICAgICAgICByZXR1cm4gYFJTMWA7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUnNhUHJpdmF0ZUtleSBleHRlbmRzIEFzeW1tZXRyaWNLZXkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInByaXZhdGVcIjtcclxuICAgIH1cclxuICAgIGdldEtleSgpIHtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UodGhpcy5kYXRhLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbyk7XHJcbiAgICAgICAgcmV0dXJuIGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHJpdmF0ZUtleSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUnNhUHJpdmF0ZUtleSk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcclxuICAgICAgICBjb25zdCBqc29uID0ge1xyXG4gICAgICAgICAgICBrdHk6IFwiUlNBXCIsXHJcbiAgICAgICAgICAgIGFsZzogZ2V0SndrQWxnb3JpdGhtKHRoaXMuYWxnb3JpdGhtKSxcclxuICAgICAgICAgICAga2V5X29wczogdGhpcy51c2FnZXMsXHJcbiAgICAgICAgICAgIGV4dDogdGhpcy5leHRyYWN0YWJsZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGpzb24sIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSkpO1xyXG4gICAgfVxyXG4gICAgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihqc29uLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuUnNhUHJpdmF0ZUtleSB9KTtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMTM1NDkuMS4xLjFcIjtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IG51bGw7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5ID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXkpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFJzYVB1YmxpY0tleSBleHRlbmRzIEFzeW1tZXRyaWNLZXkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInB1YmxpY1wiO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5KCkge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZSh0aGlzLmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgIHJldHVybiBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXlJbmZvLnB1YmxpY0tleSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUnNhUHVibGljS2V5KTtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleSgpO1xyXG4gICAgICAgIGNvbnN0IGpzb24gPSB7XHJcbiAgICAgICAgICAgIGt0eTogXCJSU0FcIixcclxuICAgICAgICAgICAgYWxnOiBnZXRKd2tBbGdvcml0aG0odGhpcy5hbGdvcml0aG0pLFxyXG4gICAgICAgICAgICBrZXlfb3BzOiB0aGlzLnVzYWdlcyxcclxuICAgICAgICAgICAgZXh0OiB0aGlzLmV4dHJhY3RhYmxlLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oanNvbiwganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KSk7XHJcbiAgICB9XHJcbiAgICBmcm9tSlNPTihqc29uKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGpzb24sIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQdWJsaWNLZXkgfSk7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjExMzU0OS4xLjEuMVwiO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMgPSBudWxsO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5ID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXkpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5SW5mbykpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFJzYUNyeXB0byB7XHJcbiAgICBzdGF0aWMgYXN5bmMgZ2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IG5ldyBSc2FQcml2YXRlS2V5KCk7XHJcbiAgICAgICAgcHJpdmF0ZUtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAgcHJpdmF0ZUtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIHByaXZhdGVLZXkudXNhZ2VzID0ga2V5VXNhZ2VzLmZpbHRlcigodXNhZ2UpID0+IHRoaXMucHJpdmF0ZUtleVVzYWdlcy5pbmRleE9mKHVzYWdlKSAhPT0gLTEpO1xyXG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IG5ldyBSc2FQdWJsaWNLZXkoKTtcclxuICAgICAgICBwdWJsaWNLZXkuYWxnb3JpdGhtID0gYWxnb3JpdGhtO1xyXG4gICAgICAgIHB1YmxpY0tleS5leHRyYWN0YWJsZSA9IHRydWU7XHJcbiAgICAgICAgcHVibGljS2V5LnVzYWdlcyA9IGtleVVzYWdlcy5maWx0ZXIoKHVzYWdlKSA9PiB0aGlzLnB1YmxpY0tleVVzYWdlcy5pbmRleE9mKHVzYWdlKSAhPT0gLTEpO1xyXG4gICAgICAgIGNvbnN0IHB1YmxpY0V4cG9uZW50ID0gQnVmZmVyLmNvbmNhdChbXHJcbiAgICAgICAgICAgIEJ1ZmZlci5hbGxvYyg0IC0gYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50LmJ5dGVMZW5ndGgsIDApLFxyXG4gICAgICAgICAgICBCdWZmZXIuZnJvbShhbGdvcml0aG0ucHVibGljRXhwb25lbnQpLFxyXG4gICAgICAgIF0pLnJlYWRJbnQzMkJFKDApO1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBjcnlwdG8uZ2VuZXJhdGVLZXlQYWlyU3luYyhcInJzYVwiLCB7XHJcbiAgICAgICAgICAgIG1vZHVsdXNMZW5ndGg6IGFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoLFxyXG4gICAgICAgICAgICBwdWJsaWNFeHBvbmVudCxcclxuICAgICAgICAgICAgcHVibGljS2V5RW5jb2Rpbmc6IHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJkZXJcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwic3BraVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcml2YXRlS2V5RW5jb2Rpbmc6IHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJkZXJcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwicGtjczhcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBwcml2YXRlS2V5LmRhdGEgPSBrZXlzLnByaXZhdGVLZXk7XHJcbiAgICAgICAgcHVibGljS2V5LmRhdGEgPSBrZXlzLnB1YmxpY0tleTtcclxuICAgICAgICBjb25zdCByZXMgPSB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KTtcclxuICAgICAgICAgICAgY2FzZSBcInBrY3M4XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJzcGtpXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoa2V5LmRhdGEpLmJ1ZmZlcjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycsICdwa2NzOCcgb3IgJ3Nwa2knXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgandrID0ga2V5RGF0YTtcclxuICAgICAgICAgICAgICAgIGlmIChqd2suZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuUnNhUHJpdmF0ZUtleSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuUnNhUHVibGljS2V5IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFB1YmxpY0tleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcInNwa2lcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKG5ldyBVaW50OEFycmF5KGtleURhdGEpLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleUluZm8ucHVibGljS2V5LCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Sc2FQdWJsaWNLZXkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKG5ldyBVaW50OEFycmF5KGtleURhdGEpLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXlJbmZvLnByaXZhdGVLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLlJzYVByaXZhdGVLZXkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJmb3JtYXQ6IE11c3QgYmUgJ2p3aycsICdwa2NzOCcgb3IgJ3Nwa2knXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBzaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJSU0EtUFNTXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJSU0FTU0EtUEtDUzEtVjFfNVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnblJzYShhbGdvcml0aG0sIGtleSwgZGF0YSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgdmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlJTQS1QU1NcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlJTQVNTQS1QS0NTMS1WMV81XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJpZnlTU0EoYWxnb3JpdGhtLCBrZXksIGRhdGEsIHNpZ25hdHVyZSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtOiBJcyBub3QgcmVjb2duaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiUlNBLU9BRVBcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY3J5cHRPQUVQKGFsZ29yaXRobSwga2V5LCBkYXRhKTtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoXCJhbGdvcml0aG06IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZWNyeXB0KGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJSU0EtT0FFUFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdE9BRVAoYWxnb3JpdGhtLCBrZXksIGRhdGEpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImFsZ29yaXRobTogSXMgbm90IHJlY29nbml6ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMTM1NDkuMS4xLjFcIjtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IG51bGw7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5ID0gYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShhc25LZXkpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBSc2FQcml2YXRlS2V5KCk7XHJcbiAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gT2JqZWN0LmFzc2lnbih7fSwgYWxnb3JpdGhtKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50ID0gbmV3IFVpbnQ4QXJyYXkoYXNuS2V5LnB1YmxpY0V4cG9uZW50KTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggPSBhc25LZXkubW9kdWx1cy5ieXRlTGVuZ3RoIDw8IDM7XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGltcG9ydFB1YmxpY0tleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IFwiMS4yLjg0MC4xMTM1NDkuMS4xLjFcIjtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5wYXJhbWV0ZXJzID0gbnVsbDtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleSA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoYXNuS2V5KTtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgUnNhUHVibGljS2V5KCk7XHJcbiAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gT2JqZWN0LmFzc2lnbih7fSwgYWxnb3JpdGhtKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50ID0gbmV3IFVpbnQ4QXJyYXkoYXNuS2V5LnB1YmxpY0V4cG9uZW50KTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggPSBhc25LZXkubW9kdWx1cy5ieXRlTGVuZ3RoIDw8IDM7XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldENyeXB0b0FsZ29yaXRobShhbGcpIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZy5oYXNoLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTFcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIlJTQS1TSEExXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMjU2XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBMjU2XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMzg0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBMzg0XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtNTEyXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJSU0EtU0hBNTEyXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTI1NlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUlNBLVNIQTMtMjU2XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTM4NFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUlNBLVNIQTMtMzg0XCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTUxMlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiUlNBLVNIQTMtNTEyXCI7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiYWxnb3JpdGhtLmhhc2g6IElzIG5vdCByZWNvZ25pemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBzaWduUnNhKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gdGhpcy5nZXRDcnlwdG9BbGdvcml0aG0oa2V5LmFsZ29yaXRobSk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gY3J5cHRvLmNyZWF0ZVNpZ24oY3J5cHRvQWxnKTtcclxuICAgICAgICBzaWduZXIudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKTtcclxuICAgICAgICBpZiAoIWtleS5wZW0pIHtcclxuICAgICAgICAgICAga2V5LnBlbSA9IGAtLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBrZXk6IGtleS5wZW0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSA9PT0gXCJSU0EtUFNTXCIpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5wYWRkaW5nID0gY3J5cHRvLmNvbnN0YW50cy5SU0FfUEtDUzFfUFNTX1BBRERJTkc7XHJcbiAgICAgICAgICAgIG9wdGlvbnMuc2FsdExlbmd0aCA9IGFsZ29yaXRobS5zYWx0TGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduZXIuc2lnbihvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdmVyaWZ5U1NBKGFsZ29yaXRobSwga2V5LCBkYXRhLCBzaWduYXR1cmUpIHtcclxuICAgICAgICBjb25zdCBjcnlwdG9BbGcgPSB0aGlzLmdldENyeXB0b0FsZ29yaXRobShrZXkuYWxnb3JpdGhtKTtcclxuICAgICAgICBjb25zdCBzaWduZXIgPSBjcnlwdG8uY3JlYXRlVmVyaWZ5KGNyeXB0b0FsZyk7XHJcbiAgICAgICAgc2lnbmVyLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgaWYgKCFrZXkucGVtKSB7XHJcbiAgICAgICAgICAgIGtleS5wZW0gPSBgLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleToga2V5LnBlbSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChhbGdvcml0aG0ubmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIlJTQS1QU1NcIikge1xyXG4gICAgICAgICAgICBvcHRpb25zLnBhZGRpbmcgPSBjcnlwdG8uY29uc3RhbnRzLlJTQV9QS0NTMV9QU1NfUEFERElORztcclxuICAgICAgICAgICAgb3B0aW9ucy5zYWx0TGVuZ3RoID0gYWxnb3JpdGhtLnNhbHRMZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9rID0gc2lnbmVyLnZlcmlmeShvcHRpb25zLCBzaWduYXR1cmUpO1xyXG4gICAgICAgIHJldHVybiBvaztcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbmNyeXB0T0FFUChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleTogYC0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1gLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9QS0NTMV9PQUVQX1BBRERJTkcsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoYWxnb3JpdGhtLmxhYmVsKSA7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNyeXB0by5wdWJsaWNFbmNyeXB0KG9wdGlvbnMsIGRhdGEpKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZGVjcnlwdE9BRVAoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBrZXk6IGAtLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cXG4ke2tleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS1gLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiBjcnlwdG8uY29uc3RhbnRzLlJTQV9QS0NTMV9PQUVQX1BBRERJTkcsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoYWxnb3JpdGhtLmxhYmVsKSA7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNyeXB0by5wcml2YXRlRGVjcnlwdChvcHRpb25zLCBkYXRhKSkuYnVmZmVyO1xyXG4gICAgfVxyXG59XHJcblJzYUNyeXB0by5wdWJsaWNLZXlVc2FnZXMgPSBbXCJ2ZXJpZnlcIiwgXCJlbmNyeXB0XCIsIFwid3JhcEtleVwiXTtcclxuUnNhQ3J5cHRvLnByaXZhdGVLZXlVc2FnZXMgPSBbXCJzaWduXCIsIFwiZGVjcnlwdFwiLCBcInVud3JhcEtleVwiXTtcblxuY2xhc3MgUnNhU3NhUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUnNhU3NhUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmhhc2hBbGdvcml0aG1zID0gW1xyXG4gICAgICAgICAgICBcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCIsXHJcbiAgICAgICAgICAgIFwic2hha2UxMjhcIiwgXCJzaGFrZTI1NlwiLFxyXG4gICAgICAgICAgICBcIlNIQTMtMjU2XCIsIFwiU0hBMy0zODRcIiwgXCJTSEEzLTUxMlwiXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IFJzYUNyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uU2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8uc2lnbihhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFJzYUNyeXB0by52ZXJpZnkoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgUnNhQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgaWYgKCEoaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQcml2YXRlS2V5IHx8IGludGVybmFsS2V5IGluc3RhbmNlb2YgUnNhUHVibGljS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgUlNBIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUnNhUHNzUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUnNhUHNzUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmhhc2hBbGdvcml0aG1zID0gW1xyXG4gICAgICAgICAgICBcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCIsXHJcbiAgICAgICAgICAgIFwic2hha2UxMjhcIiwgXCJzaGFrZTI1NlwiLFxyXG4gICAgICAgICAgICBcIlNIQTMtMjU2XCIsIFwiU0hBMy0zODRcIiwgXCJTSEEzLTUxMlwiXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IFJzYUNyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uU2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBSc2FDcnlwdG8uc2lnbihhbGdvcml0aG0sIGdldENyeXB0b0tleShrZXkpLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvblZlcmlmeShhbGdvcml0aG0sIGtleSwgc2lnbmF0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFJzYUNyeXB0by52ZXJpZnkoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgUnNhQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgaWYgKCEoaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQcml2YXRlS2V5IHx8IGludGVybmFsS2V5IGluc3RhbmNlb2YgUnNhUHVibGljS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgUlNBIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hhQ3J5cHRvIHtcclxuICAgIHN0YXRpYyBzaXplKGFsZ29yaXRobSkge1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm5hbWUudG9VcHBlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTFcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiAxNjA7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMjU2XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTI1NlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDI1NjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0zODRcIjpcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMzg0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMzg0O1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTUxMlwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiU0hBMy01MTJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiA1MTI7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbmFtZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0QWxnb3JpdGhtTmFtZShhbGdvcml0aG0pIHtcclxuICAgICAgICBzd2l0Y2ggKGFsZ29yaXRobS5uYW1lLnRvVXBwZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0xXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGExXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEtMjU2XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGEyNTZcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQS0zODRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTM4NFwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBLTUxMlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2hhNTEyXCI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJTSEEzLTI1NlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2hhMy0yNTZcIjtcclxuICAgICAgICAgICAgY2FzZSBcIlNIQTMtMzg0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzaGEzLTM4NFwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiU0hBMy01MTJcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNoYTMtNTEyXCI7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbmFtZVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGhhc2hBbGcgPSB0aGlzLmdldEFsZ29yaXRobU5hbWUoYWxnb3JpdGhtKTtcclxuICAgICAgICBjb25zdCBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goaGFzaEFsZylcclxuICAgICAgICAgICAgLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSkuZGlnZXN0KCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGhhc2gpLmJ1ZmZlcjtcclxuICAgIH1cclxufVxuXG5jbGFzcyBSc2FPYWVwUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUnNhT2FlcFByb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IFJzYUNyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIC4uLmFsZ29yaXRobSxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IHNldENyeXB0b0tleShrZXlzLnByaXZhdGVLZXkpLFxyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNldENyeXB0b0tleShrZXlzLnB1YmxpY0tleSksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRW5jcnlwdChhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgVWludDhBcnJheShkYXRhKTtcclxuICAgICAgICBjb25zdCBrZXlTaXplID0gTWF0aC5jZWlsKGludGVybmFsS2V5LmFsZ29yaXRobS5tb2R1bHVzTGVuZ3RoID4+IDMpO1xyXG4gICAgICAgIGNvbnN0IGhhc2hTaXplID0gU2hhQ3J5cHRvLnNpemUoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLmhhc2gpID4+IDM7XHJcbiAgICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IGRhdGFWaWV3LmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgY29uc3QgcHNMZW5ndGggPSBrZXlTaXplIC0gZGF0YUxlbmd0aCAtIDIgKiBoYXNoU2l6ZSAtIDI7XHJcbiAgICAgICAgaWYgKGRhdGFMZW5ndGggPiBrZXlTaXplIC0gMiAqIGhhc2hTaXplIC0gMikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIHRvbyBsYXJnZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KGtleVNpemUpO1xyXG4gICAgICAgIGNvbnN0IHNlZWQgPSBtZXNzYWdlLnN1YmFycmF5KDEsIGhhc2hTaXplICsgMSk7XHJcbiAgICAgICAgY29uc3QgZGF0YUJsb2NrID0gbWVzc2FnZS5zdWJhcnJheShoYXNoU2l6ZSArIDEpO1xyXG4gICAgICAgIGRhdGFCbG9jay5zZXQoZGF0YVZpZXcsIGhhc2hTaXplICsgcHNMZW5ndGggKyAxKTtcclxuICAgICAgICBjb25zdCBsYWJlbEhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaChpbnRlcm5hbEtleS5hbGdvcml0aG0uaGFzaC5uYW1lLnJlcGxhY2UoXCItXCIsIFwiXCIpKVxyXG4gICAgICAgICAgICAudXBkYXRlKGNvcmVfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KGFsZ29yaXRobS5sYWJlbCB8fCBuZXcgVWludDhBcnJheSgwKSkpXHJcbiAgICAgICAgICAgIC5kaWdlc3QoKTtcclxuICAgICAgICBkYXRhQmxvY2suc2V0KGxhYmVsSGFzaCwgMCk7XHJcbiAgICAgICAgZGF0YUJsb2NrW2hhc2hTaXplICsgcHNMZW5ndGhdID0gMTtcclxuICAgICAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMoc2VlZCk7XHJcbiAgICAgICAgY29uc3QgZGF0YUJsb2NrTWFzayA9IHRoaXMubWdmMShpbnRlcm5hbEtleS5hbGdvcml0aG0uaGFzaCwgc2VlZCwgZGF0YUJsb2NrLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhQmxvY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGF0YUJsb2NrW2ldIF49IGRhdGFCbG9ja01hc2tbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlZWRNYXNrID0gdGhpcy5tZ2YxKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoLCBkYXRhQmxvY2ssIHNlZWQubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VlZFtpXSBePSBzZWVkTWFza1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpbnRlcm5hbEtleS5wZW0pIHtcclxuICAgICAgICAgICAgaW50ZXJuYWxLZXkucGVtID0gYC0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXFxuJHtpbnRlcm5hbEtleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBrY3MwID0gY3J5cHRvLnB1YmxpY0VuY3J5cHQoe1xyXG4gICAgICAgICAgICBrZXk6IGludGVybmFsS2V5LnBlbSxcclxuICAgICAgICAgICAgcGFkZGluZzogY3J5cHRvLmNvbnN0YW50cy5SU0FfTk9fUEFERElORyxcclxuICAgICAgICB9LCBCdWZmZXIuZnJvbShtZXNzYWdlKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHBrY3MwKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBpbnRlcm5hbEtleSA9IGdldENyeXB0b0tleShrZXkpO1xyXG4gICAgICAgIGNvbnN0IGtleVNpemUgPSBNYXRoLmNlaWwoaW50ZXJuYWxLZXkuYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGggPj4gMyk7XHJcbiAgICAgICAgY29uc3QgaGFzaFNpemUgPSBTaGFDcnlwdG8uc2l6ZShpbnRlcm5hbEtleS5hbGdvcml0aG0uaGFzaCkgPj4gMztcclxuICAgICAgICBjb25zdCBkYXRhTGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgIGlmIChkYXRhTGVuZ3RoICE9PSBrZXlTaXplKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCBkYXRhXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWludGVybmFsS2V5LnBlbSkge1xyXG4gICAgICAgICAgICBpbnRlcm5hbEtleS5wZW0gPSBgLS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tXFxuJHtpbnRlcm5hbEtleS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcGtjczAgPSBjcnlwdG8ucHJpdmF0ZURlY3J5cHQoe1xyXG4gICAgICAgICAgICBrZXk6IGludGVybmFsS2V5LnBlbSxcclxuICAgICAgICAgICAgcGFkZGluZzogY3J5cHRvLmNvbnN0YW50cy5SU0FfTk9fUEFERElORyxcclxuICAgICAgICB9LCBCdWZmZXIuZnJvbShkYXRhKSk7XHJcbiAgICAgICAgY29uc3QgeiA9IHBrY3MwWzBdO1xyXG4gICAgICAgIGNvbnN0IHNlZWQgPSBwa2NzMC5zdWJhcnJheSgxLCBoYXNoU2l6ZSArIDEpO1xyXG4gICAgICAgIGNvbnN0IGRhdGFCbG9jayA9IHBrY3MwLnN1YmFycmF5KGhhc2hTaXplICsgMSk7XHJcbiAgICAgICAgaWYgKHogIT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjcnlwdGlvbiBmYWlsZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlZWRNYXNrID0gdGhpcy5tZ2YxKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoLCBkYXRhQmxvY2ssIHNlZWQubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VlZFtpXSBePSBzZWVkTWFza1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGF0YUJsb2NrTWFzayA9IHRoaXMubWdmMShpbnRlcm5hbEtleS5hbGdvcml0aG0uaGFzaCwgc2VlZCwgZGF0YUJsb2NrLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhQmxvY2subGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGF0YUJsb2NrW2ldIF49IGRhdGFCbG9ja01hc2tbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxhYmVsSGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKGludGVybmFsS2V5LmFsZ29yaXRobS5oYXNoLm5hbWUucmVwbGFjZShcIi1cIiwgXCJcIikpXHJcbiAgICAgICAgICAgIC51cGRhdGUoY29yZV9fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoYWxnb3JpdGhtLmxhYmVsIHx8IG5ldyBVaW50OEFycmF5KDApKSlcclxuICAgICAgICAgICAgLmRpZ2VzdCgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFzaFNpemU7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAobGFiZWxIYXNoW2ldICE9PSBkYXRhQmxvY2tbaV0pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlY3J5cHRpb24gZmFpbGVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBwc0VuZCA9IGhhc2hTaXplO1xyXG4gICAgICAgIGZvciAoOyBwc0VuZCA8IGRhdGFCbG9jay5sZW5ndGg7IHBzRW5kKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcHN6ID0gZGF0YUJsb2NrW3BzRW5kXTtcclxuICAgICAgICAgICAgaWYgKHBzeiA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBzeiAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVjcnlwdGlvbiBmYWlsZWRcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBzRW5kID09PSBkYXRhQmxvY2subGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlY3J5cHRpb24gZmFpbGVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwa2NzMCA9IGRhdGFCbG9jay5zdWJhcnJheShwc0VuZCArIDEpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShwa2NzMCkuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgUnNhQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgaWYgKCEoaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQcml2YXRlS2V5IHx8IGludGVybmFsS2V5IGluc3RhbmNlb2YgUnNhUHVibGljS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgUlNBIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtZ2YxKGFsZ29yaXRobSwgc2VlZCwgbGVuZ3RoID0gMCkge1xyXG4gICAgICAgIGNvbnN0IGhhc2hTaXplID0gU2hhQ3J5cHRvLnNpemUoYWxnb3JpdGhtKSA+PiAzO1xyXG4gICAgICAgIGNvbnN0IG1hc2sgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGNvdW50ZXIgPSBuZXcgVWludDhBcnJheSg0KTtcclxuICAgICAgICBjb25zdCBjaHVua3MgPSBNYXRoLmNlaWwobGVuZ3RoIC8gaGFzaFNpemUpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzOyBpKyspIHtcclxuICAgICAgICAgICAgY291bnRlclswXSA9IGkgPj4+IDI0O1xyXG4gICAgICAgICAgICBjb3VudGVyWzFdID0gKGkgPj4+IDE2KSAmIDI1NTtcclxuICAgICAgICAgICAgY291bnRlclsyXSA9IChpID4+PiA4KSAmIDI1NTtcclxuICAgICAgICAgICAgY291bnRlclszXSA9IGkgJiAyNTU7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1Ym1hc2sgPSBtYXNrLnN1YmFycmF5KGkgKiBoYXNoU2l6ZSk7XHJcbiAgICAgICAgICAgIGxldCBjaHVuayA9IGNyeXB0by5jcmVhdGVIYXNoKGFsZ29yaXRobS5uYW1lLnJlcGxhY2UoXCItXCIsIFwiXCIpKVxyXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShzZWVkKVxyXG4gICAgICAgICAgICAgICAgLnVwZGF0ZShjb3VudGVyKVxyXG4gICAgICAgICAgICAgICAgLmRpZ2VzdCgpO1xyXG4gICAgICAgICAgICBpZiAoY2h1bmsubGVuZ3RoID4gc3VibWFzay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNodW5rID0gY2h1bmsuc3ViYXJyYXkoMCwgc3VibWFzay5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1Ym1hc2suc2V0KGNodW5rKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1hc2s7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgUnNhRXNQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Qcm92aWRlckNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiUlNBRVMtUEtDUzEtdjFfNVwiO1xyXG4gICAgICAgIHRoaXMudXNhZ2VzID0ge1xyXG4gICAgICAgICAgICBwdWJsaWNLZXk6IFtcImVuY3J5cHRcIiwgXCJ3cmFwS2V5XCJdLFxyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBbXCJkZWNyeXB0XCIsIFwidW53cmFwS2V5XCJdLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBSc2FDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICAuLi5hbGdvcml0aG0sXHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcclxuICAgICAgICAgICAgcHVibGljS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wdWJsaWNLZXkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjaGVja0dlbmVyYXRlS2V5UGFyYW1zKGFsZ29yaXRobSkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJwdWJsaWNFeHBvbmVudFwiKTtcclxuICAgICAgICBpZiAoIShhbGdvcml0aG0ucHVibGljRXhwb25lbnQgJiYgYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInB1YmxpY0V4cG9uZW50OiBNaXNzaW5nIG9yIG5vdCBhIFVpbnQ4QXJyYXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHB1YmxpY0V4cG9uZW50ID0gcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjQoYWxnb3JpdGhtLnB1YmxpY0V4cG9uZW50KTtcclxuICAgICAgICBpZiAoIShwdWJsaWNFeHBvbmVudCA9PT0gXCJBdz09XCIgfHwgcHVibGljRXhwb25lbnQgPT09IFwiQVFBQlwiKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicHVibGljRXhwb25lbnQ6IE11c3QgYmUgWzNdIG9yIFsxLDAsMV1cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2hlY2tSZXF1aXJlZFByb3BlcnR5KGFsZ29yaXRobSwgXCJtb2R1bHVzTGVuZ3RoXCIpO1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtLm1vZHVsdXNMZW5ndGgpIHtcclxuICAgICAgICAgICAgY2FzZSAxMDI0OlxyXG4gICAgICAgICAgICBjYXNlIDIwNDg6XHJcbiAgICAgICAgICAgIGNhc2UgNDA5NjpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm1vZHVsdXNMZW5ndGg6IE11c3QgYmUgMTAyNCwgMjA0OCwgb3IgNDA5NlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkVuY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy50b0NyeXB0b09wdGlvbnMoa2V5KTtcclxuICAgICAgICBjb25zdCBlbmMgPSBjcnlwdG9fX25hbWVzcGFjZS5wdWJsaWNFbmNyeXB0KG9wdGlvbnMsIG5ldyBVaW50OEFycmF5KGRhdGEpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZW5jKS5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlY3J5cHQoYWxnb3JpdGhtLCBrZXksIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy50b0NyeXB0b09wdGlvbnMoa2V5KTtcclxuICAgICAgICBjb25zdCBkZWMgPSBjcnlwdG9fX25hbWVzcGFjZS5wcml2YXRlRGVjcnlwdChvcHRpb25zLCBuZXcgVWludDhBcnJheShkYXRhKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRlYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gUnNhQ3J5cHRvLmV4cG9ydEtleShmb3JtYXQsIGdldENyeXB0b0tleShrZXkpKTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgUnNhQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgaWYgKCEoaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBSc2FQcml2YXRlS2V5IHx8IGludGVybmFsS2V5IGluc3RhbmNlb2YgUnNhUHVibGljS2V5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwia2V5OiBJcyBub3QgUlNBIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b0NyeXB0b09wdGlvbnMoa2V5KSB7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGtleS50eXBlLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAga2V5OiBgLS0tLS1CRUdJTiAke3R5cGV9IEtFWS0tLS0tXFxuJHtnZXRDcnlwdG9LZXkoa2V5KS5kYXRhLnRvU3RyaW5nKFwiYmFzZTY0XCIpfVxcbi0tLS0tRU5EICR7dHlwZX0gS0VZLS0tLS1gLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiBjcnlwdG9fX25hbWVzcGFjZS5jb25zdGFudHMuUlNBX1BLQ1MxX1BBRERJTkcsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxuXG5jb25zdCBuYW1lZE9JRHMgPSB7XHJcbiAgICBcIjEuMi44NDAuMTAwNDUuMy4xLjdcIjogXCJQLTI1NlwiLFxyXG4gICAgXCJQLTI1NlwiOiBcIjEuMi44NDAuMTAwNDUuMy4xLjdcIixcclxuICAgIFwiMS4zLjEzMi4wLjM0XCI6IFwiUC0zODRcIixcclxuICAgIFwiUC0zODRcIjogXCIxLjMuMTMyLjAuMzRcIixcclxuICAgIFwiMS4zLjEzMi4wLjM1XCI6IFwiUC01MjFcIixcclxuICAgIFwiUC01MjFcIjogXCIxLjMuMTMyLjAuMzVcIixcclxuICAgIFwiMS4zLjEzMi4wLjEwXCI6IFwiSy0yNTZcIixcclxuICAgIFwiSy0yNTZcIjogXCIxLjMuMTMyLjAuMTBcIixcclxuICAgIFwiYnJhaW5wb29sUDE2MHIxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjFcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjFcIjogXCJicmFpbnBvb2xQMTYwcjFcIixcclxuICAgIFwiYnJhaW5wb29sUDE2MHQxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjJcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjJcIjogXCJicmFpbnBvb2xQMTYwdDFcIixcclxuICAgIFwiYnJhaW5wb29sUDE5MnIxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjNcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjNcIjogXCJicmFpbnBvb2xQMTkycjFcIixcclxuICAgIFwiYnJhaW5wb29sUDE5MnQxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjRcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjRcIjogXCJicmFpbnBvb2xQMTkydDFcIixcclxuICAgIFwiYnJhaW5wb29sUDIyNHIxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjVcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjVcIjogXCJicmFpbnBvb2xQMjI0cjFcIixcclxuICAgIFwiYnJhaW5wb29sUDIyNHQxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjZcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjZcIjogXCJicmFpbnBvb2xQMjI0dDFcIixcclxuICAgIFwiYnJhaW5wb29sUDI1NnIxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjdcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjdcIjogXCJicmFpbnBvb2xQMjU2cjFcIixcclxuICAgIFwiYnJhaW5wb29sUDI1NnQxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjhcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjhcIjogXCJicmFpbnBvb2xQMjU2dDFcIixcclxuICAgIFwiYnJhaW5wb29sUDMyMHIxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjlcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjlcIjogXCJicmFpbnBvb2xQMzIwcjFcIixcclxuICAgIFwiYnJhaW5wb29sUDMyMHQxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjEwXCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS4xMFwiOiBcImJyYWlucG9vbFAzMjB0MVwiLFxyXG4gICAgXCJicmFpbnBvb2xQMzg0cjFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTFcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjExXCI6IFwiYnJhaW5wb29sUDM4NHIxXCIsXHJcbiAgICBcImJyYWlucG9vbFAzODR0MVwiOiBcIjEuMy4zNi4zLjMuMi44LjEuMS4xMlwiLFxyXG4gICAgXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTJcIjogXCJicmFpbnBvb2xQMzg0dDFcIixcclxuICAgIFwiYnJhaW5wb29sUDUxMnIxXCI6IFwiMS4zLjM2LjMuMy4yLjguMS4xLjEzXCIsXHJcbiAgICBcIjEuMy4zNi4zLjMuMi44LjEuMS4xM1wiOiBcImJyYWlucG9vbFA1MTJyMVwiLFxyXG4gICAgXCJicmFpbnBvb2xQNTEydDFcIjogXCIxLjMuMzYuMy4zLjIuOC4xLjEuMTRcIixcclxuICAgIFwiMS4zLjM2LjMuMy4yLjguMS4xLjE0XCI6IFwiYnJhaW5wb29sUDUxMnQxXCIsXHJcbn07XHJcbmZ1bmN0aW9uIGdldE9pZEJ5TmFtZWRDdXJ2ZSQxKG5hbWVkQ3VydmUpIHtcclxuICAgIGNvbnN0IG9pZCA9IG5hbWVkT0lEc1tuYW1lZEN1cnZlXTtcclxuICAgIGlmICghb2lkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGNvbnZlcnQgV2ViQ3J5cHRvIG5hbWVkIGN1cnZlICcke25hbWVkQ3VydmV9JyB0byBPSURgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvaWQ7XHJcbn1cblxuY2xhc3MgRWNQcml2YXRlS2V5IGV4dGVuZHMgQXN5bW1ldHJpY0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwicHJpdmF0ZVwiO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5KCkge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZSh0aGlzLmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICByZXR1cm4gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5SW5mby5wcml2YXRlS2V5LCBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1ByaXZhdGVLZXkpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KCk7XHJcbiAgICAgICAgY29uc3QganNvbiA9IHtcclxuICAgICAgICAgICAga3R5OiBcIkVDXCIsXHJcbiAgICAgICAgICAgIGNydjogdGhpcy5hbGdvcml0aG0ubmFtZWRDdXJ2ZSxcclxuICAgICAgICAgICAga2V5X29wczogdGhpcy51c2FnZXMsXHJcbiAgICAgICAgICAgIGV4dDogdGhpcy5leHRyYWN0YWJsZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGpzb24sIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSkpO1xyXG4gICAgfVxyXG4gICAgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGlmICghanNvbi5jcnYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGdldCBuYW1lZCBjdXJ2ZSBmcm9tIEpXSy4gUHJvcGVydHkgJ2NydicgaXMgcmVxdWlyZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5hbGdvcml0aG0gPSBcIjEuMi44NDAuMTAwNDUuMi4xXCI7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5PYmplY3RJZGVudGlmaWVyKGdldE9pZEJ5TmFtZWRDdXJ2ZSQxKGpzb24uY3J2KSkpO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihqc29uLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNQcml2YXRlS2V5IH0pO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleSA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoa2V5KTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxuXG5jbGFzcyBFY1B1YmxpY0tleSBleHRlbmRzIEFzeW1tZXRyaWNLZXkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBcInB1YmxpY1wiO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5KCkge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZSh0aGlzLmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgIHJldHVybiBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNQdWJsaWNLZXkoa2V5SW5mby5wdWJsaWNLZXkpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KCk7XHJcbiAgICAgICAgY29uc3QganNvbiA9IHtcclxuICAgICAgICAgICAga3R5OiBcIkVDXCIsXHJcbiAgICAgICAgICAgIGNydjogdGhpcy5hbGdvcml0aG0ubmFtZWRDdXJ2ZSxcclxuICAgICAgICAgICAga2V5X29wczogdGhpcy51c2FnZXMsXHJcbiAgICAgICAgICAgIGV4dDogdGhpcy5leHRyYWN0YWJsZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGpzb24sIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSkpO1xyXG4gICAgfVxyXG4gICAgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGlmICghanNvbi5jcnYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGdldCBuYW1lZCBjdXJ2ZSBmcm9tIEpXSy4gUHJvcGVydHkgJ2NydicgaXMgcmVxdWlyZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGpzb24sIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1B1YmxpY0tleSB9KTtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gbmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnB1YmxpY0tleUFsZ29yaXRobS5hbGdvcml0aG0gPSBcIjEuMi44NDAuMTAwNDUuMi4xXCI7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUobmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLk9iamVjdElkZW50aWZpZXIoZ2V0T2lkQnlOYW1lZEN1cnZlJDEoanNvbi5jcnYpKSk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXkgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIudG9BU04oa2V5KS52YWx1ZUhleDtcclxuICAgICAgICB0aGlzLmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGExUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUHJvdmlkZXJDcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQS0xXCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hhMjU2UHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUHJvdmlkZXJDcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQS0yNTZcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGEzODRQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Qcm92aWRlckNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiU0hBLTM4NFwiO1xyXG4gICAgICAgIHRoaXMudXNhZ2VzID0gW107XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hhQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYTUxMlByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlByb3ZpZGVyQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJTSEEtNTEyXCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hhMzI1NlByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlByb3ZpZGVyQ3J5cHRvIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gXCJTSEEzLTI1NlwiO1xyXG4gICAgICAgIHRoaXMudXNhZ2VzID0gW107XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hhQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYTMzODRQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5Qcm92aWRlckNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiU0hBMy0zODRcIjtcclxuICAgICAgICB0aGlzLnVzYWdlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYUNyeXB0by5kaWdlc3QoYWxnb3JpdGhtLCBkYXRhKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGEzNTEyUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUHJvdmlkZXJDcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlNIQTMtNTEyXCI7XHJcbiAgICAgICAgdGhpcy51c2FnZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGlnZXN0KGFsZ29yaXRobSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBTaGFDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRWNDcnlwdG8ge1xyXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBuZXcgRWNQcml2YXRlS2V5KCk7XHJcbiAgICAgICAgcHJpdmF0ZUtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAgcHJpdmF0ZUtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIHByaXZhdGVLZXkudXNhZ2VzID0ga2V5VXNhZ2VzLmZpbHRlcigodXNhZ2UpID0+IHRoaXMucHJpdmF0ZUtleVVzYWdlcy5pbmRleE9mKHVzYWdlKSAhPT0gLTEpO1xyXG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IG5ldyBFY1B1YmxpY0tleSgpO1xyXG4gICAgICAgIHB1YmxpY0tleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAgcHVibGljS2V5LmV4dHJhY3RhYmxlID0gdHJ1ZTtcclxuICAgICAgICBwdWJsaWNLZXkudXNhZ2VzID0ga2V5VXNhZ2VzLmZpbHRlcigodXNhZ2UpID0+IHRoaXMucHVibGljS2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpICE9PSAtMSk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGNyeXB0by5nZW5lcmF0ZUtleVBhaXJTeW5jKFwiZWNcIiwge1xyXG4gICAgICAgICAgICBuYW1lZEN1cnZlOiB0aGlzLmdldE9wZW5TU0xOYW1lZEN1cnZlKGFsZ29yaXRobS5uYW1lZEN1cnZlKSxcclxuICAgICAgICAgICAgcHVibGljS2V5RW5jb2Rpbmc6IHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJkZXJcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwic3BraVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcml2YXRlS2V5RW5jb2Rpbmc6IHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJkZXJcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwicGtjczhcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBwcml2YXRlS2V5LmRhdGEgPSBrZXlzLnByaXZhdGVLZXk7XHJcbiAgICAgICAgcHVibGljS2V5LmRhdGEgPSBrZXlzLnB1YmxpY0tleTtcclxuICAgICAgICBjb25zdCByZXMgPSB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgc2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNyeXB0b0FsZyA9IFNoYUNyeXB0by5nZXRBbGdvcml0aG1OYW1lKGFsZ29yaXRobS5oYXNoKTtcclxuICAgICAgICBjb25zdCBzaWduZXIgPSBjcnlwdG8uY3JlYXRlU2lnbihjcnlwdG9BbGcpO1xyXG4gICAgICAgIHNpZ25lci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgIGlmICgha2V5LnBlbSkge1xyXG4gICAgICAgICAgICBrZXkucGVtID0gYC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleToga2V5LnBlbSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25lci5zaWduKG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IGVjU2lnbmF0dXJlID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoc2lnbmF0dXJlLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY0RzYVNpZ25hdHVyZSk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlUmF3ID0gY29yZV9fbmFtZXNwYWNlLkVjVXRpbHMuZW5jb2RlU2lnbmF0dXJlKGVjU2lnbmF0dXJlLCBjb3JlX19uYW1lc3BhY2UuRWNDdXJ2ZXMuZ2V0KGtleS5hbGdvcml0aG0ubmFtZWRDdXJ2ZSkuc2l6ZSk7XHJcbiAgICAgICAgcmV0dXJuIHNpZ25hdHVyZVJhdy5idWZmZXI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgdmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBjcnlwdG9BbGcgPSBTaGFDcnlwdG8uZ2V0QWxnb3JpdGhtTmFtZShhbGdvcml0aG0uaGFzaCk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmVyID0gY3J5cHRvLmNyZWF0ZVZlcmlmeShjcnlwdG9BbGcpO1xyXG4gICAgICAgIHNpZ25lci51cGRhdGUoQnVmZmVyLmZyb20oZGF0YSkpO1xyXG4gICAgICAgIGlmICgha2V5LnBlbSkge1xyXG4gICAgICAgICAgICBrZXkucGVtID0gYC0tLS0tQkVHSU4gUFVCTElDIEtFWS0tLS0tXFxuJHtrZXkuZGF0YS50b1N0cmluZyhcImJhc2U2NFwiKX1cXG4tLS0tLUVORCBQVUJMSUMgS0VZLS0tLS1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBrZXk6IGtleS5wZW0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBlY1NpZ25hdHVyZSA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY0RzYVNpZ25hdHVyZSgpO1xyXG4gICAgICAgIGNvbnN0IG5hbWVkQ3VydmUgPSBjb3JlX19uYW1lc3BhY2UuRWNDdXJ2ZXMuZ2V0KGtleS5hbGdvcml0aG0ubmFtZWRDdXJ2ZSk7XHJcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlUG9pbnQgPSBjb3JlX19uYW1lc3BhY2UuRWNVdGlscy5kZWNvZGVTaWduYXR1cmUoc2lnbmF0dXJlLCBuYW1lZEN1cnZlLnNpemUpO1xyXG4gICAgICAgIGVjU2lnbmF0dXJlLnIgPSBwdnRzdXRpbHMuQnVmZmVyU291cmNlQ29udmVydGVyLnRvQXJyYXlCdWZmZXIoc2lnbmF0dXJlUG9pbnQucik7XHJcbiAgICAgICAgZWNTaWduYXR1cmUucyA9IHB2dHN1dGlscy5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihzaWduYXR1cmVQb2ludC5zKTtcclxuICAgICAgICBjb25zdCBlY1NpZ25hdHVyZVJhdyA9IEJ1ZmZlci5mcm9tKGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoZWNTaWduYXR1cmUpKTtcclxuICAgICAgICBjb25zdCBvayA9IHNpZ25lci52ZXJpZnkob3B0aW9ucywgZWNTaWduYXR1cmVSYXcpO1xyXG4gICAgICAgIHJldHVybiBvaztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBkZXJpdmVCaXRzKGFsZ29yaXRobSwgYmFzZUtleSwgbGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gdGhpcy5nZXRPcGVuU1NMTmFtZWRDdXJ2ZShiYXNlS2V5LmFsZ29yaXRobS5uYW1lZEN1cnZlKTtcclxuICAgICAgICBjb25zdCBlY2RoID0gY3J5cHRvLmNyZWF0ZUVDREgoY3J5cHRvQWxnKTtcclxuICAgICAgICBjb25zdCBhc25Qcml2YXRlS2V5ID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UoYmFzZUtleS5kYXRhLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbyk7XHJcbiAgICAgICAgY29uc3QgYXNuRWNQcml2YXRlS2V5ID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UoYXNuUHJpdmF0ZUtleS5wcml2YXRlS2V5LCBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1ByaXZhdGVLZXkpO1xyXG4gICAgICAgIGVjZGguc2V0UHJpdmF0ZUtleShCdWZmZXIuZnJvbShhc25FY1ByaXZhdGVLZXkucHJpdmF0ZUtleSkpO1xyXG4gICAgICAgIGNvbnN0IGFzblB1YmxpY0tleSA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGFsZ29yaXRobS5wdWJsaWMuZGF0YSwgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbyk7XHJcbiAgICAgICAgY29uc3QgYml0cyA9IGVjZGguY29tcHV0ZVNlY3JldChCdWZmZXIuZnJvbShhc25QdWJsaWNLZXkucHVibGljS2V5KSk7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYml0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJpdHMpLmJ1ZmZlci5zbGljZSgwLCBsZW5ndGggPj4gMyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZXhwb3J0S2V5KGZvcm1hdCwga2V5KSB7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvblNjaGVtYS5Kc29uU2VyaWFsaXplci50b0pTT04oa2V5KTtcclxuICAgICAgICAgICAgY2FzZSBcInBrY3M4XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJzcGtpXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoa2V5LmRhdGEpLmJ1ZmZlcjtcclxuICAgICAgICAgICAgY2FzZSBcInJhd1wiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNLZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5LmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlB1YmxpY0tleUluZm8pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHB1YmxpY0tleUluZm8ucHVibGljS2V5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snLCAncmF3JywgcGtjczgnIG9yICdzcGtpJ1wiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiandrXCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGp3ayA9IGtleURhdGE7XHJcbiAgICAgICAgICAgICAgICBpZiAoandrLmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oa2V5RGF0YSwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHJpdmF0ZUtleSB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogY29yZV9fbmFtZXNwYWNlLmFzbjEuRWNQdWJsaWNLZXkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1B1YmxpY0tleShrZXlEYXRhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFB1YmxpY0tleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcInNwa2lcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKG5ldyBVaW50OEFycmF5KGtleURhdGEpLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFzbktleSA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5FY1B1YmxpY0tleShrZXlJbmZvLnB1YmxpY0tleSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2VydEtleVBhcmFtZXRlcnMoa2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0ucGFyYW1ldGVycywgYWxnb3JpdGhtLm5hbWVkQ3VydmUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKG5ldyBVaW50OEFycmF5KGtleURhdGEpLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXlJbmZvLnByaXZhdGVLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLkVjUHJpdmF0ZUtleSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2VydEtleVBhcmFtZXRlcnMoa2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMsIGFsZ29yaXRobS5uYW1lZEN1cnZlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFByaXZhdGVLZXkoYXNuS2V5LCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snLCAncmF3JywgJ3BrY3M4JyBvciAnc3BraSdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzc2VydEtleVBhcmFtZXRlcnMocGFyYW1ldGVycywgbmFtZWRDdXJ2ZSkge1xyXG4gICAgICAgIGlmICghcGFyYW1ldGVycykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLkNyeXB0b0Vycm9yKFwiS2V5IGluZm8gZG9lc24ndCBoYXZlIHJlcXVpcmVkIHBhcmFtZXRlcnNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuYW1lZEN1cnZlSWRlbnRpZmllciA9IFwiXCI7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgbmFtZWRDdXJ2ZUlkZW50aWZpZXIgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShwYXJhbWV0ZXJzLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5PYmplY3RJZGVudGlmaWVyKS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5DcnlwdG9FcnJvcihcIkNhbm5vdCByZWFkIGtleSBpbmZvIHBhcmFtZXRlcnNcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChnZXRPaWRCeU5hbWVkQ3VydmUkMShuYW1lZEN1cnZlKSAhPT0gbmFtZWRDdXJ2ZUlkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5DcnlwdG9FcnJvcihcIktleSBpbmZvIHBhcmFtZXRlciBkb2Vzbid0IG1hdGNoIHRvIG5hbWVkIGN1cnZlXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhc3luYyBpbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobS5hbGdvcml0aG0gPSBcIjEuMi44NDAuMTAwNDUuMi4xXCI7XHJcbiAgICAgICAga2V5SW5mby5wcml2YXRlS2V5QWxnb3JpdGhtLnBhcmFtZXRlcnMgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5PYmplY3RJZGVudGlmaWVyKGdldE9pZEJ5TmFtZWRDdXJ2ZSQxKGFsZ29yaXRobS5uYW1lZEN1cnZlKSkpO1xyXG4gICAgICAgIGtleUluZm8ucHJpdmF0ZUtleSA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUoYXNuS2V5KTtcclxuICAgICAgICBjb25zdCBrZXkgPSBuZXcgRWNQcml2YXRlS2V5KCk7XHJcbiAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleUluZm8pKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gT2JqZWN0LmFzc2lnbih7fSwgYWxnb3JpdGhtKTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5SW5mbyA9IG5ldyBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKCk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gXCIxLjIuODQwLjEwMDQ1LjIuMVwiO1xyXG4gICAgICAgIGNvbnN0IG5hbWVkQ3VydmUgPSBnZXRPaWRCeU5hbWVkQ3VydmUkMShhbGdvcml0aG0ubmFtZWRDdXJ2ZSk7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXlBbGdvcml0aG0ucGFyYW1ldGVycyA9IGFzbjFTY2hlbWEuQXNuU2VyaWFsaXplci5zZXJpYWxpemUobmV3IGNvcmVfX25hbWVzcGFjZS5hc24xLk9iamVjdElkZW50aWZpZXIobmFtZWRDdXJ2ZSkpO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5ID0gYXNuS2V5LnZhbHVlO1xyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBFY1B1YmxpY0tleSgpO1xyXG4gICAgICAgIGtleS5kYXRhID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XHJcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IE9iamVjdC5hc3NpZ24oe30sIGFsZ29yaXRobSk7XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICByZXR1cm4ga2V5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldE9wZW5TU0xOYW1lZEN1cnZlKGN1cnZlKSB7XHJcbiAgICAgICAgc3dpdGNoIChjdXJ2ZS50b1VwcGVyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJQLTI1NlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwicHJpbWUyNTZ2MVwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiSy0yNTZcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNlY3AyNTZrMVwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiUC0zODRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNlY3AzODRyMVwiO1xyXG4gICAgICAgICAgICBjYXNlIFwiUC01MjFcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInNlY3A1MjFyMVwiO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnZlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5FY0NyeXB0by5wdWJsaWNLZXlVc2FnZXMgPSBbXCJ2ZXJpZnlcIl07XHJcbkVjQ3J5cHRvLnByaXZhdGVLZXlVc2FnZXMgPSBbXCJzaWduXCIsIFwiZGVyaXZlS2V5XCIsIFwiZGVyaXZlQml0c1wiXTtcblxuY2xhc3MgRWNkc2FQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5FY2RzYVByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lZEN1cnZlcyA9IGNvcmVfX25hbWVzcGFjZS5FY0N1cnZlcy5uYW1lcztcclxuICAgICAgICB0aGlzLmhhc2hBbGdvcml0aG1zID0gW1xyXG4gICAgICAgICAgICBcIlNIQS0xXCIsIFwiU0hBLTI1NlwiLCBcIlNIQS0zODRcIiwgXCJTSEEtNTEyXCIsXHJcbiAgICAgICAgICAgIFwic2hha2UxMjhcIiwgXCJzaGFrZTI1NlwiLFxyXG4gICAgICAgICAgICBcIlNIQTMtMjU2XCIsIFwiU0hBMy0zODRcIiwgXCJTSEEzLTUxMlwiXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGF3YWl0IEVjQ3J5cHRvLmdlbmVyYXRlS2V5KHtcclxuICAgICAgICAgICAgLi4uYWxnb3JpdGhtLFxyXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25TaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEVjQ3J5cHRvLnNpZ24oYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25WZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBFY0NyeXB0by52ZXJpZnkoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gRWNDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBFY0NyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IC4uLmFsZ29yaXRobSwgbmFtZTogdGhpcy5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBjb25zdCBpbnRlcm5hbEtleSA9IGdldENyeXB0b0tleShrZXkpO1xyXG4gICAgICAgIGlmICghKGludGVybmFsS2V5IGluc3RhbmNlb2YgRWNQcml2YXRlS2V5IHx8IGludGVybmFsS2V5IGluc3RhbmNlb2YgRWNQdWJsaWNLZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBFQyBDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEVjZGhQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5FY2RoUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWVkQ3VydmVzID0gY29yZV9fbmFtZXNwYWNlLkVjQ3VydmVzLm5hbWVzO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25HZW5lcmF0ZUtleShhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXlzID0gYXdhaXQgRWNDcnlwdG8uZ2VuZXJhdGVLZXkoe1xyXG4gICAgICAgICAgICAuLi5hbGdvcml0aG0sXHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcclxuICAgICAgICAgICAgcHVibGljS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wdWJsaWNLZXkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHJldHVybiBFY0NyeXB0by5leHBvcnRLZXkoZm9ybWF0LCBnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IEVjQ3J5cHRvLmltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIHsgLi4uYWxnb3JpdGhtLCBuYW1lOiB0aGlzLm5hbWUgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGNvbnN0IGludGVybmFsS2V5ID0gZ2V0Q3J5cHRvS2V5KGtleSk7XHJcbiAgICAgICAgaWYgKCEoaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBFY1ByaXZhdGVLZXkgfHwgaW50ZXJuYWxLZXkgaW5zdGFuY2VvZiBFY1B1YmxpY0tleSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleTogSXMgbm90IEVDIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBiaXRzID0gYXdhaXQgRWNDcnlwdG8uZGVyaXZlQml0cyh7IC4uLmFsZ29yaXRobSwgcHVibGljOiBnZXRDcnlwdG9LZXkoYWxnb3JpdGhtLnB1YmxpYykgfSwgZ2V0Q3J5cHRvS2V5KGJhc2VLZXkpLCBsZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgfVxyXG59XG5cbmNvbnN0IGVkT0lEcyA9IHtcclxuICAgIFtjb3JlX19uYW1lc3BhY2UuYXNuMS5pZEVkNDQ4XTogXCJFZDQ0OFwiLFxyXG4gICAgXCJlZDQ0OFwiOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5pZEVkNDQ4LFxyXG4gICAgW2NvcmVfX25hbWVzcGFjZS5hc24xLmlkWDQ0OF06IFwiWDQ0OFwiLFxyXG4gICAgXCJ4NDQ4XCI6IGNvcmVfX25hbWVzcGFjZS5hc24xLmlkWDQ0OCxcclxuICAgIFtjb3JlX19uYW1lc3BhY2UuYXNuMS5pZEVkMjU1MTldOiBcIkVkMjU1MTlcIixcclxuICAgIFwiZWQyNTUxOVwiOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5pZEVkMjU1MTksXHJcbiAgICBbY29yZV9fbmFtZXNwYWNlLmFzbjEuaWRYMjU1MTldOiBcIlgyNTUxOVwiLFxyXG4gICAgXCJ4MjU1MTlcIjogY29yZV9fbmFtZXNwYWNlLmFzbjEuaWRYMjU1MTksXHJcbn07XHJcbmZ1bmN0aW9uIGdldE9pZEJ5TmFtZWRDdXJ2ZShuYW1lZEN1cnZlKSB7XHJcbiAgICBjb25zdCBvaWQgPSBlZE9JRHNbbmFtZWRDdXJ2ZS50b0xvd2VyQ2FzZSgpXTtcclxuICAgIGlmICghb2lkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGNvbnZlcnQgV2ViQ3J5cHRvIG5hbWVkIGN1cnZlICcke25hbWVkQ3VydmV9JyB0byBPSURgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvaWQ7XHJcbn1cblxuY2xhc3MgRWRQcml2YXRlS2V5IGV4dGVuZHMgQXN5bW1ldHJpY0tleSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFwicHJpdmF0ZVwiO1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5KCkge1xyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZSh0aGlzLmRhdGEsIGNvcmVfX25hbWVzcGFjZS5hc24xLlByaXZhdGVLZXlJbmZvKTtcclxuICAgICAgICByZXR1cm4gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2Uoa2V5SW5mby5wcml2YXRlS2V5LCBjb3JlX19uYW1lc3BhY2UuYXNuMS5DdXJ2ZVByaXZhdGVLZXkpO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5KCk7XHJcbiAgICAgICAgY29uc3QganNvbiA9IHtcclxuICAgICAgICAgICAga3R5OiBcIk9LUFwiLFxyXG4gICAgICAgICAgICBjcnY6IHRoaXMuYWxnb3JpdGhtLm5hbWVkQ3VydmUsXHJcbiAgICAgICAgICAgIGtleV9vcHM6IHRoaXMudXNhZ2VzLFxyXG4gICAgICAgICAgICBleHQ6IHRoaXMuZXh0cmFjdGFibGUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihqc29uLCBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihrZXkpKTtcclxuICAgIH1cclxuICAgIGZyb21KU09OKGpzb24pIHtcclxuICAgICAgICBpZiAoIWpzb24uY3J2KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlX19uYW1lc3BhY2UuT3BlcmF0aW9uRXJyb3IoYENhbm5vdCBnZXQgbmFtZWQgY3VydmUgZnJvbSBKV0suIFByb3BlcnR5ICdjcnYnIGlzIHJlcXVpcmVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHJpdmF0ZUtleUluZm8oKTtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXlBbGdvcml0aG0uYWxnb3JpdGhtID0gZ2V0T2lkQnlOYW1lZEN1cnZlKGpzb24uY3J2KTtcclxuICAgICAgICBjb25zdCBrZXkgPSBqc29uU2NoZW1hLkpzb25QYXJzZXIuZnJvbUpTT04oanNvbiwgeyB0YXJnZXRTY2hlbWE6IGNvcmVfX25hbWVzcGFjZS5hc24xLkN1cnZlUHJpdmF0ZUtleSB9KTtcclxuICAgICAgICBrZXlJbmZvLnByaXZhdGVLZXkgPSBhc24xU2NoZW1hLkFzblNlcmlhbGl6ZXIuc2VyaWFsaXplKGtleSk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRWRQdWJsaWNLZXkgZXh0ZW5kcyBBc3ltbWV0cmljS2V5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gXCJwdWJsaWNcIjtcclxuICAgIH1cclxuICAgIGdldEtleSgpIHtcclxuICAgICAgICBjb25zdCBrZXlJbmZvID0gYXNuMVNjaGVtYS5Bc25QYXJzZXIucGFyc2UodGhpcy5kYXRhLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKTtcclxuICAgICAgICByZXR1cm4ga2V5SW5mby5wdWJsaWNLZXk7XHJcbiAgICB9XHJcbiAgICB0b0pTT04oKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXkoKTtcclxuICAgICAgICBjb25zdCBqc29uID0ge1xyXG4gICAgICAgICAgICBrdHk6IFwiT0tQXCIsXHJcbiAgICAgICAgICAgIGNydjogdGhpcy5hbGdvcml0aG0ubmFtZWRDdXJ2ZSxcclxuICAgICAgICAgICAga2V5X29wczogdGhpcy51c2FnZXMsXHJcbiAgICAgICAgICAgIGV4dDogdGhpcy5leHRyYWN0YWJsZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGpzb24sIHtcclxuICAgICAgICAgICAgeDogcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwoa2V5KVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIGlmICghanNvbi5jcnYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGdldCBuYW1lZCBjdXJ2ZSBmcm9tIEpXSy4gUHJvcGVydHkgJ2NydicgaXMgcmVxdWlyZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFqc29uLngpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihgQ2Fubm90IGdldCBwcm9wZXJ0eSBmcm9tIEpXSy4gUHJvcGVydHkgJ3gnIGlzIHJlcXVpcmVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGtleUluZm8gPSBuZXcgY29yZV9fbmFtZXNwYWNlLmFzbjEuUHVibGljS2V5SW5mbygpO1xyXG4gICAgICAgIGtleUluZm8ucHVibGljS2V5QWxnb3JpdGhtLmFsZ29yaXRobSA9IGdldE9pZEJ5TmFtZWRDdXJ2ZShqc29uLmNydik7XHJcbiAgICAgICAga2V5SW5mby5wdWJsaWNLZXkgPSBwdnRzdXRpbHMuQ29udmVydC5Gcm9tQmFzZTY0VXJsKGpzb24ueCk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gQnVmZmVyLmZyb20oYXNuMVNjaGVtYS5Bc25TZXJpYWxpemVyLnNlcmlhbGl6ZShrZXlJbmZvKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgRWRDcnlwdG8ge1xyXG4gICAgc3RhdGljIGFzeW5jIGdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBuZXcgRWRQcml2YXRlS2V5KCk7XHJcbiAgICAgICAgcHJpdmF0ZUtleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAgcHJpdmF0ZUtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIHByaXZhdGVLZXkudXNhZ2VzID0ga2V5VXNhZ2VzLmZpbHRlcigodXNhZ2UpID0+IHRoaXMucHJpdmF0ZUtleVVzYWdlcy5pbmRleE9mKHVzYWdlKSAhPT0gLTEpO1xyXG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IG5ldyBFZFB1YmxpY0tleSgpO1xyXG4gICAgICAgIHB1YmxpY0tleS5hbGdvcml0aG0gPSBhbGdvcml0aG07XHJcbiAgICAgICAgcHVibGljS2V5LmV4dHJhY3RhYmxlID0gdHJ1ZTtcclxuICAgICAgICBwdWJsaWNLZXkudXNhZ2VzID0ga2V5VXNhZ2VzLmZpbHRlcigodXNhZ2UpID0+IHRoaXMucHVibGljS2V5VXNhZ2VzLmluZGV4T2YodXNhZ2UpICE9PSAtMSk7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGFsZ29yaXRobS5uYW1lZEN1cnZlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgY29uc3Qga2V5cyA9IGNyeXB0by5nZW5lcmF0ZUtleVBhaXJTeW5jKHR5cGUsIHtcclxuICAgICAgICAgICAgcHVibGljS2V5RW5jb2Rpbmc6IHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJkZXJcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwic3BraVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwcml2YXRlS2V5RW5jb2Rpbmc6IHtcclxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJkZXJcIixcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwicGtjczhcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBwcml2YXRlS2V5LmRhdGEgPSBrZXlzLnByaXZhdGVLZXk7XHJcbiAgICAgICAgcHVibGljS2V5LmRhdGEgPSBrZXlzLnB1YmxpY0tleTtcclxuICAgICAgICBjb25zdCByZXMgPSB7XHJcbiAgICAgICAgICAgIHByaXZhdGVLZXksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgc2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkge1xyXG4gICAgICAgIGlmICgha2V5LnBlbSkge1xyXG4gICAgICAgICAgICBrZXkucGVtID0gYC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGtleToga2V5LnBlbSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGNyeXB0by5zaWduKG51bGwsIEJ1ZmZlci5mcm9tKGRhdGEpLCBvcHRpb25zKTtcclxuICAgICAgICByZXR1cm4gY29yZV9fbmFtZXNwYWNlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b0FycmF5QnVmZmVyKHNpZ25hdHVyZSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgdmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcclxuICAgICAgICBpZiAoIWtleS5wZW0pIHtcclxuICAgICAgICAgICAga2V5LnBlbSA9IGAtLS0tLUJFR0lOIFBVQkxJQyBLRVktLS0tLVxcbiR7a2V5LmRhdGEudG9TdHJpbmcoXCJiYXNlNjRcIil9XFxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAga2V5OiBrZXkucGVtLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3Qgb2sgPSBjcnlwdG8udmVyaWZ5KG51bGwsIEJ1ZmZlci5mcm9tKGRhdGEpLCBvcHRpb25zLCBCdWZmZXIuZnJvbShzaWduYXR1cmUpKTtcclxuICAgICAgICByZXR1cm4gb2s7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgZGVyaXZlQml0cyhhbGdvcml0aG0sIGJhc2VLZXksIGxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGNyeXB0by5jcmVhdGVQdWJsaWNLZXkoe1xyXG4gICAgICAgICAgICBrZXk6IGFsZ29yaXRobS5wdWJsaWMuZGF0YSxcclxuICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICB0eXBlOiBcInNwa2lcIixcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gY3J5cHRvLmNyZWF0ZVByaXZhdGVLZXkoe1xyXG4gICAgICAgICAgICBrZXk6IGJhc2VLZXkuZGF0YSxcclxuICAgICAgICAgICAgZm9ybWF0OiBcImRlclwiLFxyXG4gICAgICAgICAgICB0eXBlOiBcInBrY3M4XCIsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgYml0cyA9IGNyeXB0by5kaWZmaWVIZWxsbWFuKHtcclxuICAgICAgICAgICAgcHVibGljS2V5LFxyXG4gICAgICAgICAgICBwcml2YXRlS2V5LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShiaXRzKS5idWZmZXIuc2xpY2UoMCwgbGVuZ3RoID4+IDMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGV4cG9ydEtleShmb3JtYXQsIGtleSkge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25TY2hlbWEuSnNvblNlcmlhbGl6ZXIudG9KU09OKGtleSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwa2NzOFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwic3BraVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGtleS5kYXRhKS5idWZmZXI7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHVibGljS2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKGtleS5kYXRhLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwdWJsaWNLZXlJbmZvLnB1YmxpY0tleTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJywgJ3JhdycsIHBrY3M4JyBvciAnc3BraSdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFzeW5jIGltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0LnRvTG93ZXJDYXNlKCkpIHtcclxuICAgICAgICAgICAgY2FzZSBcImp3a1wiOiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBqd2sgPSBrZXlEYXRhO1xyXG4gICAgICAgICAgICAgICAgaWYgKGp3ay5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNuS2V5ID0ganNvblNjaGVtYS5Kc29uUGFyc2VyLmZyb21KU09OKGtleURhdGEsIHsgdGFyZ2V0U2NoZW1hOiBjb3JlX19uYW1lc3BhY2UuYXNuMS5DdXJ2ZVByaXZhdGVLZXkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHJpdmF0ZUtleShhc25LZXksIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWp3ay54KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXlEYXRhOiBDYW5ub3QgZ2V0IHJlcXVpcmVkICd4JyBmaWxlZFwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KHB2dHN1dGlscy5Db252ZXJ0LkZyb21CYXNlNjRVcmwoandrLngpLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjoge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW1wb3J0UHVibGljS2V5KGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcInNwa2lcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKG5ldyBVaW50OEFycmF5KGtleURhdGEpLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5QdWJsaWNLZXlJbmZvKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmltcG9ydFB1YmxpY0tleShrZXlJbmZvLnB1YmxpY0tleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIFwicGtjczhcIjoge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5SW5mbyA9IGFzbjFTY2hlbWEuQXNuUGFyc2VyLnBhcnNlKG5ldyBVaW50OEFycmF5KGtleURhdGEpLCBjb3JlX19uYW1lc3BhY2UuYXNuMS5Qcml2YXRlS2V5SW5mbyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhc25LZXkgPSBhc24xU2NoZW1hLkFzblBhcnNlci5wYXJzZShrZXlJbmZvLnByaXZhdGVLZXksIGNvcmVfX25hbWVzcGFjZS5hc24xLkN1cnZlUHJpdmF0ZUtleSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJywgJ3JhdycsICdwa2NzOCcgb3IgJ3Nwa2knXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBpbXBvcnRQcml2YXRlS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IEVkUHJpdmF0ZUtleSgpO1xyXG4gICAgICAgIGtleS5mcm9tSlNPTih7XHJcbiAgICAgICAgICAgIGNydjogYWxnb3JpdGhtLm5hbWVkQ3VydmUsXHJcbiAgICAgICAgICAgIGQ6IHB2dHN1dGlscy5Db252ZXJ0LlRvQmFzZTY0VXJsKGFzbktleS5kKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gT2JqZWN0LmFzc2lnbih7fSwgYWxnb3JpdGhtKTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0UHVibGljS2V5KGFzbktleSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IEVkUHVibGljS2V5KCk7XHJcbiAgICAgICAga2V5LmZyb21KU09OKHtcclxuICAgICAgICAgICAgY3J2OiBhbGdvcml0aG0ubmFtZWRDdXJ2ZSxcclxuICAgICAgICAgICAgeDogcHZ0c3V0aWxzLkNvbnZlcnQuVG9CYXNlNjRVcmwoYXNuS2V5KSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0gT2JqZWN0LmFzc2lnbih7fSwgYWxnb3JpdGhtKTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBrZXk7XHJcbiAgICB9XHJcbn1cclxuRWRDcnlwdG8ucHVibGljS2V5VXNhZ2VzID0gW1widmVyaWZ5XCJdO1xyXG5FZENyeXB0by5wcml2YXRlS2V5VXNhZ2VzID0gW1wic2lnblwiLCBcImRlcml2ZUtleVwiLCBcImRlcml2ZUJpdHNcIl07XG5cbmNsYXNzIEVkRHNhUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuRWREc2FQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBFZENyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbmFtZWRDdXJ2ZTogYWxnb3JpdGhtLm5hbWVkQ3VydmUucmVwbGFjZSgvXmVkL2ksIFwiRWRcIiksXHJcbiAgICAgICAgfSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcHJpdmF0ZUtleTogc2V0Q3J5cHRvS2V5KGtleXMucHJpdmF0ZUtleSksXHJcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2V0Q3J5cHRvS2V5KGtleXMucHVibGljS2V5KSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25TaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIEVkQ3J5cHRvLnNpZ24oYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25WZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBFZENyeXB0by52ZXJpZnkoYWxnb3JpdGhtLCBnZXRDcnlwdG9LZXkoa2V5KSwgbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSwgbmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gRWRDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBFZENyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IC4uLmFsZ29yaXRobSwgbmFtZTogdGhpcy5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBFY2RoRXNQcm92aWRlciBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5FY2RoRXNQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkdlbmVyYXRlS2V5KGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBhd2FpdCBFZENyeXB0by5nZW5lcmF0ZUtleSh7XHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbmFtZWRDdXJ2ZTogYWxnb3JpdGhtLm5hbWVkQ3VydmUudG9VcHBlckNhc2UoKSxcclxuICAgICAgICB9LCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwcml2YXRlS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wcml2YXRlS2V5KSxcclxuICAgICAgICAgICAgcHVibGljS2V5OiBzZXRDcnlwdG9LZXkoa2V5cy5wdWJsaWNLZXkpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkRlcml2ZUJpdHMoYWxnb3JpdGhtLCBiYXNlS2V5LCBsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBiaXRzID0gYXdhaXQgRWRDcnlwdG8uZGVyaXZlQml0cyh7IC4uLmFsZ29yaXRobSwgcHVibGljOiBnZXRDcnlwdG9LZXkoYWxnb3JpdGhtLnB1YmxpYykgfSwgZ2V0Q3J5cHRvS2V5KGJhc2VLZXkpLCBsZW5ndGgpO1xyXG4gICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICByZXR1cm4gRWRDcnlwdG8uZXhwb3J0S2V5KGZvcm1hdCwgZ2V0Q3J5cHRvS2V5KGtleSkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25JbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCBhbGdvcml0aG0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBFZENyeXB0by5pbXBvcnRLZXkoZm9ybWF0LCBrZXlEYXRhLCB7IC4uLmFsZ29yaXRobSwgbmFtZTogdGhpcy5uYW1lIH0sIGV4dHJhY3RhYmxlLCBrZXlVc2FnZXMpO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBQYmtkZkNyeXB0b0tleSBleHRlbmRzIENyeXB0b0tleSB7XHJcbn1cblxuY2xhc3MgUGJrZGYyUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuUGJrZGYyUHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25EZXJpdmVCaXRzKGFsZ29yaXRobSwgYmFzZUtleSwgbGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2FsdCA9IGNvcmVfX25hbWVzcGFjZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9BcnJheUJ1ZmZlcihhbGdvcml0aG0uc2FsdCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSBhbGdvcml0aG0uaGFzaC5uYW1lLnJlcGxhY2UoXCItXCIsIFwiXCIpO1xyXG4gICAgICAgICAgICBjcnlwdG8ucGJrZGYyKGdldENyeXB0b0tleShiYXNlS2V5KS5kYXRhLCBCdWZmZXIuZnJvbShzYWx0KSwgYWxnb3JpdGhtLml0ZXJhdGlvbnMsIGxlbmd0aCA+PiAzLCBoYXNoLCAoZXJyLCBkZXJpdmVkQml0cykgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgVWludDhBcnJheShkZXJpdmVkQml0cykuYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwicmF3XCIpIHtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gbmV3IFBia2RmQ3J5cHRvS2V5KCk7XHJcbiAgICAgICAgICAgIGtleS5kYXRhID0gQnVmZmVyLmZyb20oa2V5RGF0YSk7XHJcbiAgICAgICAgICAgIGtleS5hbGdvcml0aG0gPSB7IG5hbWU6IHRoaXMubmFtZSB9O1xyXG4gICAgICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdyYXcnXCIpO1xyXG4gICAgfVxyXG4gICAgY2hlY2tDcnlwdG9LZXkoa2V5LCBrZXlVc2FnZSkge1xyXG4gICAgICAgIHN1cGVyLmNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpO1xyXG4gICAgICAgIGlmICghKGdldENyeXB0b0tleShrZXkpIGluc3RhbmNlb2YgUGJrZGZDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBQQktERiBDcnlwdG9LZXlcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIEhtYWNDcnlwdG9LZXkgZXh0ZW5kcyBDcnlwdG9LZXkge1xyXG4gICAgZ2V0IGFsZygpIHtcclxuICAgICAgICBjb25zdCBoYXNoID0gdGhpcy5hbGdvcml0aG0uaGFzaC5uYW1lLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgcmV0dXJuIGBIUyR7aGFzaC5yZXBsYWNlKFwiU0hBLVwiLCBcIlwiKX1gO1xyXG4gICAgfVxyXG4gICAgc2V0IGFsZyh2YWx1ZSkge1xyXG4gICAgfVxyXG59XHJcbnRzbGliLl9fZGVjb3JhdGUoW1xyXG4gICAganNvblNjaGVtYS5Kc29uUHJvcCh7IG5hbWU6IFwia1wiLCBjb252ZXJ0ZXI6IEpzb25CYXNlNjRVcmxDb252ZXJ0ZXIgfSlcclxuXSwgSG1hY0NyeXB0b0tleS5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuXG5jbGFzcyBIbWFjUHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuSG1hY1Byb3ZpZGVyIHtcclxuICAgIGFzeW5jIG9uR2VuZXJhdGVLZXkoYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gKGFsZ29yaXRobS5sZW5ndGggfHwgdGhpcy5nZXREZWZhdWx0TGVuZ3RoKGFsZ29yaXRobS5oYXNoLm5hbWUpKSA+PiAzIDw8IDM7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IEhtYWNDcnlwdG9LZXkoKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0ge1xyXG4gICAgICAgICAgICAuLi5hbGdvcml0aG0sXHJcbiAgICAgICAgICAgIGxlbmd0aCxcclxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAga2V5LmV4dHJhY3RhYmxlID0gZXh0cmFjdGFibGU7XHJcbiAgICAgICAga2V5LnVzYWdlcyA9IGtleVVzYWdlcztcclxuICAgICAgICBrZXkuZGF0YSA9IGNyeXB0by5yYW5kb21CeXRlcyhsZW5ndGggPj4gMyk7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25TaWduKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgY3J5cHRvQWxnID0gU2hhQ3J5cHRvLmdldEFsZ29yaXRobU5hbWUoa2V5LmFsZ29yaXRobS5oYXNoKTtcclxuICAgICAgICBjb25zdCBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoY3J5cHRvQWxnLCBnZXRDcnlwdG9LZXkoa2V5KS5kYXRhKVxyXG4gICAgICAgICAgICAudXBkYXRlKEJ1ZmZlci5mcm9tKGRhdGEpKS5kaWdlc3QoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaG1hYykuYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25WZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNyeXB0b0FsZyA9IFNoYUNyeXB0by5nZXRBbGdvcml0aG1OYW1lKGtleS5hbGdvcml0aG0uaGFzaCk7XHJcbiAgICAgICAgY29uc3QgaG1hYyA9IGNyeXB0by5jcmVhdGVIbWFjKGNyeXB0b0FsZywgZ2V0Q3J5cHRvS2V5KGtleSkuZGF0YSlcclxuICAgICAgICAgICAgLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSkuZGlnZXN0KCk7XHJcbiAgICAgICAgcmV0dXJuIGhtYWMuY29tcGFyZShCdWZmZXIuZnJvbShzaWduYXR1cmUpKSA9PT0gMDtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uSW1wb3J0S2V5KGZvcm1hdCwga2V5RGF0YSwgYWxnb3JpdGhtLCBleHRyYWN0YWJsZSwga2V5VXNhZ2VzKSB7XHJcbiAgICAgICAgbGV0IGtleTtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIGtleSA9IGpzb25TY2hlbWEuSnNvblBhcnNlci5mcm9tSlNPTihrZXlEYXRhLCB7IHRhcmdldFNjaGVtYTogSG1hY0NyeXB0b0tleSB9KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwicmF3XCI6XHJcbiAgICAgICAgICAgICAgICBrZXkgPSBuZXcgSG1hY0NyeXB0b0tleSgpO1xyXG4gICAgICAgICAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShrZXlEYXRhKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfX25hbWVzcGFjZS5PcGVyYXRpb25FcnJvcihcImZvcm1hdDogTXVzdCBiZSAnandrJyBvciAncmF3J1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAga2V5LmFsZ29yaXRobSA9IHtcclxuICAgICAgICAgICAgaGFzaDogeyBuYW1lOiBhbGdvcml0aG0uaGFzaC5uYW1lIH0sXHJcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcclxuICAgICAgICAgICAgbGVuZ3RoOiBrZXkuZGF0YS5sZW5ndGggPDwgMyxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGtleS5leHRyYWN0YWJsZSA9IGV4dHJhY3RhYmxlO1xyXG4gICAgICAgIGtleS51c2FnZXMgPSBrZXlVc2FnZXM7XHJcbiAgICAgICAgcmV0dXJuIHNldENyeXB0b0tleShrZXkpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgb25FeHBvcnRLZXkoZm9ybWF0LCBrZXkpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdC50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJqd2tcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBqc29uU2NoZW1hLkpzb25TZXJpYWxpemVyLnRvSlNPTihnZXRDcnlwdG9LZXkoa2V5KSk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShnZXRDcnlwdG9LZXkoa2V5KS5kYXRhKS5idWZmZXI7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiZm9ybWF0OiBNdXN0IGJlICdqd2snIG9yICdyYXcnXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEhtYWNDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBITUFDIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgSGtkZkNyeXB0b0tleSBleHRlbmRzIENyeXB0b0tleSB7XHJcbn1cblxuY2xhc3MgSGtkZlByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLkhrZGZQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkltcG9ydEtleShmb3JtYXQsIGtleURhdGEsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIGtleVVzYWdlcykge1xyXG4gICAgICAgIGlmIChmb3JtYXQudG9Mb3dlckNhc2UoKSAhPT0gXCJyYXdcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZV9fbmFtZXNwYWNlLk9wZXJhdGlvbkVycm9yKFwiT3BlcmF0aW9uIG5vdCBzdXBwb3J0ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBIa2RmQ3J5cHRvS2V5KCk7XHJcbiAgICAgICAga2V5LmRhdGEgPSBCdWZmZXIuZnJvbShrZXlEYXRhKTtcclxuICAgICAgICBrZXkuYWxnb3JpdGhtID0geyBuYW1lOiB0aGlzLm5hbWUgfTtcclxuICAgICAgICBrZXkuZXh0cmFjdGFibGUgPSBleHRyYWN0YWJsZTtcclxuICAgICAgICBrZXkudXNhZ2VzID0ga2V5VXNhZ2VzO1xyXG4gICAgICAgIHJldHVybiBzZXRDcnlwdG9LZXkoa2V5KTtcclxuICAgIH1cclxuICAgIGFzeW5jIG9uRGVyaXZlQml0cyhwYXJhbXMsIGJhc2VLZXksIGxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGhhc2ggPSBwYXJhbXMuaGFzaC5uYW1lLnJlcGxhY2UoXCItXCIsIFwiXCIpO1xyXG4gICAgICAgIGNvbnN0IGhhc2hMZW5ndGggPSBjcnlwdG8uY3JlYXRlSGFzaChoYXNoKS5kaWdlc3QoKS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IGxlbmd0aCAvIDg7XHJcbiAgICAgICAgY29uc3QgaW5mbyA9IGNvcmUuQnVmZmVyU291cmNlQ29udmVydGVyLnRvVWludDhBcnJheShwYXJhbXMuaW5mbyk7XHJcbiAgICAgICAgY29uc3QgUFJLID0gY3J5cHRvLmNyZWF0ZUhtYWMoaGFzaCwgY29yZS5CdWZmZXJTb3VyY2VDb252ZXJ0ZXIudG9VaW50OEFycmF5KHBhcmFtcy5zYWx0KSlcclxuICAgICAgICAgICAgLnVwZGF0ZShjb3JlLkJ1ZmZlclNvdXJjZUNvbnZlcnRlci50b1VpbnQ4QXJyYXkoZ2V0Q3J5cHRvS2V5KGJhc2VLZXkpLmRhdGEpKVxyXG4gICAgICAgICAgICAuZGlnZXN0KCk7XHJcbiAgICAgICAgY29uc3QgYmxvY2tzID0gW0J1ZmZlci5hbGxvYygwKV07XHJcbiAgICAgICAgY29uc3QgYmxvY2tDb3VudCA9IE1hdGguY2VpbChieXRlTGVuZ3RoIC8gaGFzaExlbmd0aCkgKyAxO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgYmxvY2tDb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGNyeXB0by5jcmVhdGVIbWFjKGhhc2gsIFBSSylcclxuICAgICAgICAgICAgICAgIC51cGRhdGUoQnVmZmVyLmNvbmNhdChbYmxvY2tzW2kgLSAxXSwgaW5mbywgQnVmZmVyLmZyb20oW2ldKV0pKVxyXG4gICAgICAgICAgICAgICAgLmRpZ2VzdCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYmxvY2tzKS5zbGljZSgwLCBieXRlTGVuZ3RoKTtcclxuICAgIH1cclxuICAgIGNoZWNrQ3J5cHRvS2V5KGtleSwga2V5VXNhZ2UpIHtcclxuICAgICAgICBzdXBlci5jaGVja0NyeXB0b0tleShrZXksIGtleVVzYWdlKTtcclxuICAgICAgICBpZiAoIShnZXRDcnlwdG9LZXkoa2V5KSBpbnN0YW5jZW9mIEhrZGZDcnlwdG9LZXkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJrZXk6IElzIG5vdCBIS0RGIENyeXB0b0tleVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hha2VDcnlwdG8ge1xyXG4gICAgc3RhdGljIGRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goYWxnb3JpdGhtLm5hbWUudG9Mb3dlckNhc2UoKSwgeyBvdXRwdXRMZW5ndGg6IGFsZ29yaXRobS5sZW5ndGggfSlcclxuICAgICAgICAgICAgLnVwZGF0ZShCdWZmZXIuZnJvbShkYXRhKSkuZGlnZXN0KCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGhhc2gpLmJ1ZmZlcjtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTaGFrZTEyOFByb3ZpZGVyIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlNoYWtlMTI4UHJvdmlkZXIge1xyXG4gICAgYXN5bmMgb25EaWdlc3QoYWxnb3JpdGhtLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNoYWtlQ3J5cHRvLmRpZ2VzdChhbGdvcml0aG0sIGRhdGEpO1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFNoYWtlMjU2UHJvdmlkZXIgZXh0ZW5kcyBjb3JlX19uYW1lc3BhY2UuU2hha2UyNTZQcm92aWRlciB7XHJcbiAgICBhc3luYyBvbkRpZ2VzdChhbGdvcml0aG0sIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU2hha2VDcnlwdG8uZGlnZXN0KGFsZ29yaXRobSwgZGF0YSk7XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU3VidGxlQ3J5cHRvIGV4dGVuZHMgY29yZV9fbmFtZXNwYWNlLlN1YnRsZUNyeXB0byB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0NiY1Byb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgQWVzQ3RyUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBBZXNHY21Qcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0NtYWNQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEFlc0t3UHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBBZXNFY2JQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IERlc0NiY1Byb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgRGVzRWRlM0NiY1Byb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgUnNhU3NhUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBSc2FQc3NQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFJzYU9hZXBQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFJzYUVzUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBFY2RzYVByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgRWNkaFByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hhMVByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hhMjU2UHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGEzODRQcm92aWRlcigpKTtcclxuICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYTUxMlByb3ZpZGVyKCkpO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgUGJrZGYyUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBIbWFjUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBIa2RmUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgY29uc3Qgbm9kZU1ham9yVmVyc2lvbiA9IChfYSA9IC9edihcXGQrKS8uZXhlYyhwcm9jZXNzX19uYW1lc3BhY2UudmVyc2lvbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsxXTtcclxuICAgICAgICBpZiAobm9kZU1ham9yVmVyc2lvbiAmJiBwYXJzZUludChub2RlTWFqb3JWZXJzaW9uLCAxMCkgPj0gMTIpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGFrZTEyOFByb3ZpZGVyKCkpO1xyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYWtlMjU2UHJvdmlkZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGhhc2hlcyA9IGNyeXB0b19fbmFtZXNwYWNlLmdldEhhc2hlcygpO1xyXG4gICAgICAgIGlmIChoYXNoZXMuaW5jbHVkZXMoXCJzaGEzLTI1NlwiKSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IFNoYTMyNTZQcm92aWRlcigpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc2hlcy5pbmNsdWRlcyhcInNoYTMtMzg0XCIpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgU2hhMzM4NFByb3ZpZGVyKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzaGVzLmluY2x1ZGVzKFwic2hhMy01MTJcIikpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5ldyBTaGEzNTEyUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlTWFqb3JWZXJzaW9uICYmIHBhcnNlSW50KG5vZGVNYWpvclZlcnNpb24sIDEwKSA+PSAxNCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVycy5zZXQobmV3IEVkRHNhUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLnNldChuZXcgRWNkaEVzUHJvdmlkZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbmNsYXNzIENyeXB0byBleHRlbmRzIGNvcmVfX25hbWVzcGFjZS5DcnlwdG8ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnN1YnRsZSA9IG5ldyBTdWJ0bGVDcnlwdG8oKTtcclxuICAgIH1cclxuICAgIGdldFJhbmRvbVZhbHVlcyhhcnJheSkge1xyXG4gICAgICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KGFycmF5KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ2dldFJhbmRvbVZhbHVlcycgb24gJ0NyeXB0byc6IHBhcmFtZXRlciAxIGlzIG5vdCBvZiB0eXBlICdBcnJheUJ1ZmZlclZpZXcnXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShhcnJheS5idWZmZXIsIGFycmF5LmJ5dGVPZmZzZXQsIGFycmF5LmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIGNyeXB0by5yYW5kb21GaWxsU3luYyhidWZmZXIpO1xyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH1cclxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0NyeXB0b0tleScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlLkNyeXB0b0tleTsgfVxufSk7XG5leHBvcnRzLkNyeXB0byA9IENyeXB0bztcbiJdLCJuYW1lcyI6WyJjb3JlIiwicmVxdWlyZSIsImNyeXB0byIsInByb2Nlc3MiLCJ0c2xpYiIsImpzb25TY2hlbWEiLCJwdnRzdXRpbHMiLCJhc24xU2NoZW1hIiwiX2ludGVyb3BOYW1lc3BhY2VEZWZhdWx0IiwiZSIsIm4iLCJPYmplY3QiLCJjcmVhdGUiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJlbnVtZXJhYmxlIiwiZGVmYXVsdCIsImZyZWV6ZSIsImNvcmVfX25hbWVzcGFjZSIsImNyeXB0b19fbmFtZXNwYWNlIiwicHJvY2Vzc19fbmFtZXNwYWNlIiwiSnNvbkJhc2U2NFVybENvbnZlcnRlciIsImZyb21KU09OIiwidmFsdWUiLCJCdWZmZXIiLCJmcm9tIiwiQ29udmVydCIsIkZyb21CYXNlNjRVcmwiLCJ0b0pTT04iLCJUb0Jhc2U2NFVybCIsIkNyeXB0b0tleSIsImNvbnN0cnVjdG9yIiwiYXJndW1lbnRzIiwiZGF0YSIsImFsbG9jIiwiYWxnb3JpdGhtIiwibmFtZSIsImV4dHJhY3RhYmxlIiwidHlwZSIsInVzYWdlcyIsImt0eSIsImFsZyIsIl9fZGVjb3JhdGUiLCJKc29uUHJvcCIsIkpzb25Qcm9wVHlwZXMiLCJCb29sZWFuIiwib3B0aW9uYWwiLCJwcm90b3R5cGUiLCJTdHJpbmciLCJyZXBlYXRlZCIsIlN5bW1ldHJpY0tleSIsIkFzeW1tZXRyaWNLZXkiLCJBZXNDcnlwdG9LZXkiLCJ0b1VwcGVyQ2FzZSIsImxlbmd0aCIsIkFsZ29yaXRobUVycm9yIiwiY29udmVydGVyIiwia2V5U3RvcmFnZSIsIldlYWtNYXAiLCJnZXRDcnlwdG9LZXkiLCJrZXkiLCJyZXMiLCJPcGVyYXRpb25FcnJvciIsInNldENyeXB0b0tleSIsInNldCIsIkFlc0NyeXB0byIsImdlbmVyYXRlS2V5Iiwia2V5VXNhZ2VzIiwicmFuZG9tQnl0ZXMiLCJleHBvcnRLZXkiLCJmb3JtYXQiLCJFcnJvciIsInRvTG93ZXJDYXNlIiwiSnNvblNlcmlhbGl6ZXIiLCJVaW50OEFycmF5IiwiYnVmZmVyIiwiaW1wb3J0S2V5Iiwia2V5RGF0YSIsIkpzb25QYXJzZXIiLCJ0YXJnZXRTY2hlbWEiLCJlbmNyeXB0IiwiZW5jcnlwdEFlc0NCQyIsImVuY3J5cHRBZXNDVFIiLCJlbmNyeXB0QWVzR0NNIiwiZW5jcnlwdEFlc0tXIiwiZW5jcnlwdEFlc0VDQiIsImRlY3J5cHQiLCJkZWNyeXB0QWVzQ0JDIiwiZGVjcnlwdEFlc0NUUiIsImRlY3J5cHRBZXNHQ00iLCJkZWNyeXB0QWVzS1ciLCJkZWNyeXB0QWVzRUNCIiwiY2lwaGVyIiwiY3JlYXRlQ2lwaGVyaXYiLCJpdiIsImVuYyIsInVwZGF0ZSIsImNvbmNhdCIsImZpbmFsIiwiZGVjaXBoZXIiLCJjcmVhdGVEZWNpcGhlcml2IiwiZGVjIiwiY291bnRlciIsImF1dGhUYWdMZW5ndGgiLCJ0YWdMZW5ndGgiLCJhZGRpdGlvbmFsRGF0YSIsInNldEFBRCIsImdldEF1dGhUYWciLCJzbGljZSIsInRhZyIsInNldEF1dGhUYWciLCJBRVNfS1dfSVYiLCJBZXNDYmNQcm92aWRlciIsIm9uR2VuZXJhdGVLZXkiLCJvbkVuY3J5cHQiLCJvbkRlY3J5cHQiLCJvbkV4cG9ydEtleSIsIm9uSW1wb3J0S2V5IiwiY2hlY2tDcnlwdG9LZXkiLCJrZXlVc2FnZSIsIlR5cGVFcnJvciIsInplcm8iLCJyYiIsImJsb2NrU2l6ZSIsImJpdFNoaWZ0TGVmdCIsInNoaWZ0ZWQiLCJsYXN0IiwiaW5kZXgiLCJ4b3IiLCJhIiwiYiIsIk1hdGgiLCJtaW4iLCJvdXRwdXQiLCJhZXMiLCJtZXNzYWdlIiwicmVzdWx0IiwiZ2V0TWVzc2FnZUJsb2NrIiwiYmxvY2tJbmRleCIsImJsb2NrIiwic3RhcnQiLCJlbmQiLCJjb3B5IiwiZ2V0UGFkZGVkTWVzc2FnZUJsb2NrIiwiZmlsbCIsImdlbmVyYXRlU3Via2V5cyIsImwiLCJzdWJrZXkxIiwic3Via2V5MiIsImFlc0NtYWMiLCJzdWJrZXlzIiwiYmxvY2tDb3VudCIsImNlaWwiLCJsYXN0QmxvY2tDb21wbGV0ZUZsYWciLCJsYXN0QmxvY2siLCJsYXN0QmxvY2tJbmRleCIsIngiLCJ5IiwiQWVzQ21hY1Byb3ZpZGVyIiwib25TaWduIiwib25WZXJpZnkiLCJzaWduYXR1cmUiLCJzaWduYXR1cmUyIiwic2lnbiIsImNvbXBhcmUiLCJBZXNDdHJQcm92aWRlciIsIkFlc0djbVByb3ZpZGVyIiwiQWVzS3dQcm92aWRlciIsIkFlc0VjYlByb3ZpZGVyIiwiRGVzQ3J5cHRvS2V5IiwiRGVzQ3J5cHRvIiwiZW5jcnlwdERlc0NCQyIsImVuY3J5cHREZXNFREUzQ0JDIiwiZGVjcnlwdERlc0NCQyIsImRlY3J5cHREZXNFREUzQ0JDIiwiRGVzQ2JjUHJvdmlkZXIiLCJEZXNQcm92aWRlciIsImtleVNpemVCaXRzIiwiaXZTaXplIiwiRGVzRWRlM0NiY1Byb3ZpZGVyIiwiZ2V0SndrQWxnb3JpdGhtIiwibWRTaXplIiwiZXhlYyIsImhhc2giLCJSc2FQcml2YXRlS2V5IiwiZ2V0S2V5Iiwia2V5SW5mbyIsIkFzblBhcnNlciIsInBhcnNlIiwiYXNuMSIsIlByaXZhdGVLZXlJbmZvIiwicHJpdmF0ZUtleSIsImpzb24iLCJrZXlfb3BzIiwiZXh0IiwiYXNzaWduIiwicHJpdmF0ZUtleUFsZ29yaXRobSIsInBhcmFtZXRlcnMiLCJBc25TZXJpYWxpemVyIiwic2VyaWFsaXplIiwiUnNhUHVibGljS2V5IiwiUHVibGljS2V5SW5mbyIsInB1YmxpY0tleSIsInB1YmxpY0tleUFsZ29yaXRobSIsIlJzYUNyeXB0byIsImZpbHRlciIsInVzYWdlIiwicHJpdmF0ZUtleVVzYWdlcyIsImluZGV4T2YiLCJwdWJsaWNLZXlVc2FnZXMiLCJwdWJsaWNFeHBvbmVudCIsImJ5dGVMZW5ndGgiLCJyZWFkSW50MzJCRSIsImdlbmVyYXRlS2V5UGFpclN5bmMiLCJtb2R1bHVzTGVuZ3RoIiwicHVibGljS2V5RW5jb2RpbmciLCJwcml2YXRlS2V5RW5jb2RpbmciLCJqd2siLCJhc25LZXkiLCJpbXBvcnRQcml2YXRlS2V5IiwiaW1wb3J0UHVibGljS2V5Iiwic2lnblJzYSIsInZlcmlmeSIsInZlcmlmeVNTQSIsImVuY3J5cHRPQUVQIiwiZGVjcnlwdE9BRVAiLCJtb2R1bHVzIiwiZ2V0Q3J5cHRvQWxnb3JpdGhtIiwiY3J5cHRvQWxnIiwic2lnbmVyIiwiY3JlYXRlU2lnbiIsInBlbSIsInRvU3RyaW5nIiwib3B0aW9ucyIsInBhZGRpbmciLCJjb25zdGFudHMiLCJSU0FfUEtDUzFfUFNTX1BBRERJTkciLCJzYWx0TGVuZ3RoIiwiY3JlYXRlVmVyaWZ5Iiwib2siLCJSU0FfUEtDUzFfT0FFUF9QQURESU5HIiwibGFiZWwiLCJwdWJsaWNFbmNyeXB0IiwicHJpdmF0ZURlY3J5cHQiLCJSc2FTc2FQcm92aWRlciIsImhhc2hBbGdvcml0aG1zIiwiaW50ZXJuYWxLZXkiLCJSc2FQc3NQcm92aWRlciIsIlNoYUNyeXB0byIsInNpemUiLCJnZXRBbGdvcml0aG1OYW1lIiwiZGlnZXN0IiwiaGFzaEFsZyIsImNyZWF0ZUhhc2giLCJSc2FPYWVwUHJvdmlkZXIiLCJkYXRhVmlldyIsImtleVNpemUiLCJoYXNoU2l6ZSIsImRhdGFMZW5ndGgiLCJwc0xlbmd0aCIsInNlZWQiLCJzdWJhcnJheSIsImRhdGFCbG9jayIsImxhYmVsSGFzaCIsInJlcGxhY2UiLCJCdWZmZXJTb3VyY2VDb252ZXJ0ZXIiLCJ0b1VpbnQ4QXJyYXkiLCJyYW5kb21GaWxsU3luYyIsImRhdGFCbG9ja01hc2siLCJtZ2YxIiwiaSIsInNlZWRNYXNrIiwicGtjczAiLCJSU0FfTk9fUEFERElORyIsInoiLCJwc0VuZCIsInBzeiIsIm1hc2siLCJjaHVua3MiLCJzdWJtYXNrIiwiY2h1bmsiLCJSc2FFc1Byb3ZpZGVyIiwiUHJvdmlkZXJDcnlwdG8iLCJjaGVja0dlbmVyYXRlS2V5UGFyYW1zIiwiY2hlY2tSZXF1aXJlZFByb3BlcnR5IiwiVG9CYXNlNjQiLCJ0b0NyeXB0b09wdGlvbnMiLCJSU0FfUEtDUzFfUEFERElORyIsIm5hbWVkT0lEcyIsImdldE9pZEJ5TmFtZWRDdXJ2ZSQxIiwibmFtZWRDdXJ2ZSIsIm9pZCIsIkVjUHJpdmF0ZUtleSIsImNydiIsIk9iamVjdElkZW50aWZpZXIiLCJFY1B1YmxpY0tleSIsInRvQVNOIiwidmFsdWVIZXgiLCJTaGExUHJvdmlkZXIiLCJvbkRpZ2VzdCIsIlNoYTI1NlByb3ZpZGVyIiwiU2hhMzg0UHJvdmlkZXIiLCJTaGE1MTJQcm92aWRlciIsIlNoYTMyNTZQcm92aWRlciIsIlNoYTMzODRQcm92aWRlciIsIlNoYTM1MTJQcm92aWRlciIsIkVjQ3J5cHRvIiwiZ2V0T3BlblNTTE5hbWVkQ3VydmUiLCJlY1NpZ25hdHVyZSIsIkVjRHNhU2lnbmF0dXJlIiwic2lnbmF0dXJlUmF3IiwiRWNVdGlscyIsImVuY29kZVNpZ25hdHVyZSIsIkVjQ3VydmVzIiwic2lnbmF0dXJlUG9pbnQiLCJkZWNvZGVTaWduYXR1cmUiLCJyIiwidG9BcnJheUJ1ZmZlciIsInMiLCJlY1NpZ25hdHVyZVJhdyIsImRlcml2ZUJpdHMiLCJiYXNlS2V5IiwiZWNkaCIsImNyZWF0ZUVDREgiLCJhc25Qcml2YXRlS2V5IiwiYXNuRWNQcml2YXRlS2V5Iiwic2V0UHJpdmF0ZUtleSIsImFzblB1YmxpY0tleSIsInB1YmxpYyIsImJpdHMiLCJjb21wdXRlU2VjcmV0IiwicHVibGljS2V5SW5mbyIsImFzc2VydEtleVBhcmFtZXRlcnMiLCJDcnlwdG9FcnJvciIsIm5hbWVkQ3VydmVJZGVudGlmaWVyIiwiY3VydmUiLCJFY2RzYVByb3ZpZGVyIiwibmFtZWRDdXJ2ZXMiLCJuYW1lcyIsIkVjZGhQcm92aWRlciIsIm9uRGVyaXZlQml0cyIsImVkT0lEcyIsImlkRWQ0NDgiLCJpZFg0NDgiLCJpZEVkMjU1MTkiLCJpZFgyNTUxOSIsImdldE9pZEJ5TmFtZWRDdXJ2ZSIsIkVkUHJpdmF0ZUtleSIsIkN1cnZlUHJpdmF0ZUtleSIsIkVkUHVibGljS2V5IiwiRWRDcnlwdG8iLCJjcmVhdGVQdWJsaWNLZXkiLCJjcmVhdGVQcml2YXRlS2V5IiwiZGlmZmllSGVsbG1hbiIsIkVkRHNhUHJvdmlkZXIiLCJFY2RoRXNQcm92aWRlciIsIlBia2RmQ3J5cHRvS2V5IiwiUGJrZGYyUHJvdmlkZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInNhbHQiLCJwYmtkZjIiLCJpdGVyYXRpb25zIiwiZXJyIiwiZGVyaXZlZEJpdHMiLCJIbWFjQ3J5cHRvS2V5IiwiSG1hY1Byb3ZpZGVyIiwiZ2V0RGVmYXVsdExlbmd0aCIsImhtYWMiLCJjcmVhdGVIbWFjIiwiSGtkZkNyeXB0b0tleSIsIkhrZGZQcm92aWRlciIsInBhcmFtcyIsImhhc2hMZW5ndGgiLCJpbmZvIiwiUFJLIiwiYmxvY2tzIiwicHVzaCIsIlNoYWtlQ3J5cHRvIiwib3V0cHV0TGVuZ3RoIiwiU2hha2UxMjhQcm92aWRlciIsIlNoYWtlMjU2UHJvdmlkZXIiLCJTdWJ0bGVDcnlwdG8iLCJfYSIsInByb3ZpZGVycyIsIm5vZGVNYWpvclZlcnNpb24iLCJ2ZXJzaW9uIiwicGFyc2VJbnQiLCJoYXNoZXMiLCJnZXRIYXNoZXMiLCJpbmNsdWRlcyIsIkNyeXB0byIsInN1YnRsZSIsImdldFJhbmRvbVZhbHVlcyIsImFycmF5IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJieXRlT2Zmc2V0IiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@peculiar/webcrypto/build/webcrypto.js\n");

/***/ })

};
;